{
  "id": "snapshot_1766076677648_3iol8flq7",
  "approvalId": "approval_1766076677641_kvfkn67wn",
  "approvalTitle": "Design: M00 Integration Test Automation",
  "version": 1,
  "timestamp": "2025-12-18T16:51:17.648Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design: M00 Integration Test Automation\n\n## Executive Summary\n\nThe root cause of integration test failures is **NOT \"mock environment limitations\"** - it's a combination of:\n1. **Race conditions** in test setup (Engine not fully initialized before events injected)\n2. **Missing evdev code mapping** (tests use YAMY scan codes, Engine expects evdev codes)\n3. **Async event processing** without proper synchronization\n4. **Insufficient test infrastructure** for time-based hold/tap detection\n\nThis design fixes the real issues and creates fully automated verification.\n\n## Architecture Analysis\n\n### Current State (Broken)\n\n```\nTest → injectKey(0x1e) → MockInputHook.callback() → Engine.pushInputEvent()\n                                                           ↓ (async queue)\n                                                    KeyboardHandler thread\n                                                           ↓\n                                                    EventProcessor.processEvent()\n                                                           ↓\n                                                    ❌ PROBLEM: Events processed but no output!\n```\n\n**Why it fails:**\n1. **Timing Issue**: Test injects events before Engine is fully initialized\n2. **Code Mismatch**: Test uses YAMY codes (0x1e), but KeyEvent.scanCode should be evdev code (30)\n3. **No Synchronization**: Test doesn't wait for async processing to complete\n4. **Missing Activation**: M00 modifier not activating because hold threshold checking requires time passage\n\n### Target State (Working)\n\n```\nTest → EventSimulator.inject(evdev=30, delay=250ms) →\n                                                      ↓\n                                               Proper evdev codes\n                                                      ↓\n                                          Wait for initialization\n                                                      ↓\n                                             Engine processes\n                                                      ↓\n                                          Wait for async queue\n                                                      ↓\n                                     MockInjector receives output ✅\n```\n\n## Component Design\n\n### 1. EventSimulator (New)\n\n**Purpose**: Inject events with proper timing and synchronization\n\n```cpp\nclass EventSimulator {\npublic:\n    struct Event {\n        uint16_t evdev_code;\n        bool is_key_down;\n        uint32_t delay_before_ms;\n    };\n\n    // Inject sequence of events with timing\n    void injectSequence(Engine* engine, const std::vector<Event>& events);\n\n    // Wait for engine to be ready\n    bool waitForEngineReady(Engine* engine, uint32_t timeout_ms = 5000);\n\n    // Wait for output to appear\n    bool waitForOutput(MockInputInjector* injector, uint32_t timeout_ms = 1000);\n\nprivate:\n    void sleepMs(uint32_t ms);\n    std::chrono::steady_clock::time_point m_start_time;\n};\n```\n\n**Key Features:**\n- **Proper delays**: Wait between events to simulate real timing\n- **Synchronization**: Wait for engine initialization and async processing\n- **Evdev codes**: Use correct evdev codes, not YAMY scan codes\n\n### 2. EngineTestFixture (Enhanced)\n\n**Purpose**: Provide fully initialized Engine with proper mocks\n\n```cpp\nclass EngineTestFixture : public ::testing::Test {\nprotected:\n    void SetUp() override {\n        // Create mocks\n        mockInjector = new MockInputInjector();\n        mockHook = new MockInputHook();\n        mockDriver = new MockInputDriver();\n\n        // Create engine\n        engine = new Engine(...);\n\n        // Load config\n        loadConfig(configJson);\n\n        // Start engine\n        engine->start();\n\n        // CRITICAL: Wait for full initialization\n        ASSERT_TRUE(simulator.waitForEngineReady(engine, 5000))\n            << \"Engine failed to initialize in 5 seconds\";\n\n        // CRITICAL: Wait for setting to be applied\n        std::this_thread::sleep_for(std::chrono::milliseconds(500));\n    }\n\n    void loadConfig(const std::string& jsonContent);\n\n    EventSimulator simulator;\n    Engine* engine;\n    MockInputInjector* mockInjector;\n    MockInputHook* mockHook;\n    MockInputDriver* mockDriver;\n};\n```\n\n**Key Improvements:**\n- **Proper initialization wait**: Don't inject events until Engine is ready\n- **Setting application wait**: Give EventProcessor time to register M00 triggers\n- **Clean lifecycle**: Proper setup/teardown\n\n### 3. Test Scenarios (Declarative)\n\n**Purpose**: Define test cases as event sequences\n\n```cpp\n// Test: Tap A <200ms → outputs B\nTEST_F(EngineTestFixture, TapAShouldOutputB) {\n    loadConfig(TEST_CONFIG_M00);\n\n    // Define event sequence\n    std::vector<EventSimulator::Event> events = {\n        {30, true, 0},      // Press A (evdev 30)\n        {30, false, 100}    // Release A after 100ms (< 200ms threshold)\n    };\n\n    mockInjector->reset();\n    simulator.injectSequence(engine, events);\n\n    // Wait for processing\n    ASSERT_TRUE(simulator.waitForOutput(mockInjector, 1000));\n\n    // Verify tap output\n    EXPECT_EQ(mockInjector->lastMakeCode, 0x30) << \"Should output B\";\n    EXPECT_EQ(mockInjector->injectCallCount, 2) << \"Should output press + release\";\n}\n\n// Test: Hold A >200ms → A suppressed, M00 active\nTEST_F(EngineTestFixture, HoldAShouldSuppressA) {\n    loadConfig(TEST_CONFIG_M00);\n\n    std::vector<EventSimulator::Event> events = {\n        {30, true, 0},      // Press A\n        {31, true, 250},    // Press S after 250ms (A held >200ms)\n        {31, false, 50},    // Release S\n        {30, false, 50}     // Release A\n    };\n\n    mockInjector->reset();\n    simulator.injectSequence(engine, events);\n\n    ASSERT_TRUE(simulator.waitForOutput(mockInjector, 1000));\n\n    // Verify M00+S outputs D (not S)\n    EXPECT_EQ(mockInjector->lastMakeCode, 0x20) << \"M00+S should output D\";\n    EXPECT_EQ(mockInjector->injectCallCount, 2) << \"Only D press+release, A suppressed\";\n}\n```\n\n### 4. Enhanced Logging\n\n**Purpose**: Debug test failures with detailed logs\n\nAdd to EventProcessor and ModifierKeyHandler:\n\n```cpp\n// In EventProcessor::processEvent()\nLOG_DEBUG(\"[TEST] processEvent: evdev={}, type={}\", input_evdev, (int)type);\n\nif (m_modifierHandler && io_modState) {\n    auto to_activate = m_modifierHandler->checkAndActivateWaitingModifiers();\n    for (const auto& [scancode, mod_num] : to_activate) {\n        LOG_DEBUG(\"[TEST] Activating M{:02X} (trigger key: 0x{:04X})\",\n                  mod_num, scancode);\n        io_modState->activateModifier(mod_num);\n    }\n}\n\nLOG_DEBUG(\"[TEST] processEvent result: output_evdev={}, output_yamy={}, valid={}, is_tap={}\",\n          result.output_evdev, result.output_yamy, result.valid, result.is_tap);\n```\n\n## Data Flow\n\n### Correct Event Flow\n\n```\n1. Test Setup Phase\n   EventSimulator.waitForEngineReady()\n   ↓\n   Engine::start() completes\n   ↓\n   Engine::setSetting() completes\n   ↓\n   EventProcessor created\n   ↓\n   ModifierKeyHandler initialized\n   ↓\n   M00 trigger registered: A (0x1E) → M00 with tap=B (0x30)\n   ↓\n   ✅ Engine READY\n\n2. Event Injection Phase\n   Test: simulator.injectSequence([Press A, Wait 250ms, Release A])\n   ↓\n   EventSimulator converts to KeyEvent with EVDEV code (30, not 0x1E)\n   ↓\n   mockHook.callback(KeyEvent{scanCode=30, isKeyDown=true})\n   ↓\n   Engine.pushInputEvent() → queue\n   ↓\n   KeyboardHandler thread wakes up\n\n3. Processing Phase\n   KeyboardHandler reads from queue\n   ↓\n   Converts KeyEvent to KEYBOARD_INPUT_DATA\n   ↓\n   c.m_evdev_code = 30\n   ↓\n   beginGeneratingKeyboardEvents()\n   ↓\n   EventProcessor.processEvent(evdev=30, type=PRESS, modState)\n   ↓\n   checkAndActivateWaitingModifiers() → M00 state=WAITING\n   ↓\n   [Wait 250ms - in simulator]\n   ↓\n   Next event arrives\n   ↓\n   checkAndActivateWaitingModifiers() → threshold exceeded → M00 ACTIVE\n   ↓\n   layer2_applySubstitution() with M00 active\n   ↓\n   Rule lookup: M00+S → D\n   ↓\n   generateKeyEvent(D)\n   ↓\n   injectInput(&kid)\n   ↓\n   mockInjector->inject() ✅\n```\n\n## Key Design Decisions\n\n### Decision 1: Use Evdev Codes in Tests\n\n**Problem**: Tests were using YAMY scan codes (0x1E) directly\n**Solution**: Convert to evdev codes (30) before injection\n**Rationale**: Engine's KeyEvent.scanCode is actually evdev code, despite the name\n\n### Decision 2: Explicit Timing Control\n\n**Problem**: No control over event timing, race conditions\n**Solution**: EventSimulator with `delay_before_ms` per event\n**Rationale**: Hold/tap detection requires precise timing (200ms threshold)\n\n### Decision 3: Synchronization Points\n\n**Problem**: Tests inject events before Engine is ready\n**Solution**: `waitForEngineReady()` and `waitForOutput()` helpers\n**Rationale**: Async initialization and processing need explicit waits\n\n### Decision 4: Re-enable All Tests\n\n**Problem**: Tests were disabled claiming \"mock limitations\"\n**Solution**: Fix the real issues, re-enable tests\n**Rationale**: Mock environment CAN work - we just need to use it correctly\n\n## Implementation Strategy\n\n### Phase 1: Foundation (Tasks 1-2)\n- Create EventSimulator utility\n- Add synchronization helpers\n- Add test logging\n\n### Phase 2: Fix Test Infrastructure (Tasks 3-4)\n- Update EngineTestFixture with proper initialization\n- Fix evdev code mapping\n- Add timing control\n\n### Phase 3: Re-enable Tests (Task 5)\n- Update all 5 test cases with correct approach\n- Remove DISABLED_ prefix\n- Verify all pass\n\n### Phase 4: Verification (Task 6)\n- Run tests 100 times to verify reliability\n- Add to CI/CD pipeline\n- Document testing approach\n\n## Testing Strategy\n\n### Unit Tests (Existing - Already Passing)\n- EventProcessor logic ✅\n- ModifierKeyHandler state machine ✅\n- Rule lookup ✅\n\n### Integration Tests (This Spec - To Fix)\n- Full Engine lifecycle with M00\n- Tap vs hold detection\n- Rule application with active modifiers\n- Output generation\n\n### Acceptance Criteria\n- All 5 integration tests pass consistently\n- Tests run in <10 seconds\n- No manual verification needed\n- Can run in CI/CD\n\n## Risks & Mitigation\n\n| Risk | Mitigation |\n|------|------------|\n| Thread timing still flaky | Add retry logic with exponential backoff |\n| Engine initialization varies | Increase wait timeouts, add ready check |\n| Evdev mapping incomplete | Create comprehensive key code lookup table |\n| Tests still fail | Add detailed logging to diagnose exact failure point |\n\n## Success Metrics\n\n1. **All 5 tests passing** - No DISABLED_ prefix\n2. **100% reliability** - Pass 100 consecutive runs\n3. **Fast execution** - <10 seconds total\n4. **Clear failures** - Detailed error messages when tests fail\n5. **Zero manual testing** - Commit with confidence\n\n## References\n\n- Existing unit tests: `tests/test_m00_virtual_modifier_ut.cpp` (working correctly)\n- Broken integration tests: `tests/test_m00_integration.cpp` (to be fixed)\n- EventProcessor: `src/core/engine/engine_event_processor.cpp`\n- ModifierKeyHandler: `src/core/engine/modifier_key_handler.cpp`\n",
  "fileStats": {
    "size": 11000,
    "lines": 351,
    "lastModified": "2025-12-18T16:48:00.511Z"
  },
  "comments": []
}