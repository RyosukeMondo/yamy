{
  "id": "snapshot_1765380717329_3i82nysqc",
  "approvalId": "approval_1765379658521_z60wg42j7",
  "approvalTitle": "Steering: Technology Stack",
  "version": 4,
  "timestamp": "2025-12-10T15:31:57.329Z",
  "trigger": "approved",
  "status": "approved",
  "content": "# YAMY Technical Architecture\n\n## Technology Stack\n\n### Core Technologies\n\n**Language**: C++17\n- **Rationale**: Performance-critical input handling, cross-platform portability\n- **Benefits**: Zero-overhead abstractions, RAII, standard library maturity\n- **Trade-offs**: Longer compile times, steeper learning curve than C\n\n**Build System**: CMake 3.10+\n- **Rationale**: Cross-platform builds, conditional compilation, IDE integration\n- **Benefits**: One build system for Windows/Linux, widely understood\n- **Trade-offs**: Verbose syntax, but necessary for platform-specific code\n\n### Platform-Specific Technologies\n\n#### Windows\n| Component | Technology | Purpose |\n|-----------|------------|---------|\n| **GUI** | Win32 API | System tray, dialogs, native look-and-feel |\n| **Input Hook** | SetWindowsHookEx | Global keyboard interception |\n| **Input Injection** | SendInput API | Synthesize key events |\n| **Window System** | Win32 Window API | Window manipulation, focus tracking |\n| **IPC** | Named Pipes + Windows Messages | Hook-to-engine communication |\n| **Configuration** | Windows Registry | Settings persistence |\n\n#### Linux\n| Component | Technology | Purpose |\n|-----------|------------|---------|\n| **GUI** | Qt5 (Widgets) | System tray, dialogs, cross-DE compatibility |\n| **Input Hook** | evdev | Keyboard event capture from `/dev/input/*` |\n| **Input Injection** | uinput | Synthesize key events |\n| **Window System** | X11 (Xlib + Xrandr) | Window manipulation, focus tracking |\n| **IPC** | Unix Domain Sockets | Hook-to-engine communication |\n| **Configuration** | QSettings (INI format) | Settings persistence |\n\n---\n\n## Architecture Layers\n\n### Layer 1: Platform Abstraction\n\n**Purpose**: Hide OS-specific APIs behind uniform interfaces\n\n**Key Interfaces**:\n```cpp\nnamespace yamy::platform {\n    // Window system operations\n    class IWindowSystem {\n        virtual WindowHandle getForegroundWindow() = 0;\n        virtual std::string getWindowText(WindowHandle hwnd) = 0;\n        virtual Rect getWindowRect(WindowHandle hwnd) = 0;\n        virtual void moveWindow(WindowHandle hwnd, const Rect& rect) = 0;\n        // ... 40+ methods\n    };\n\n    // Input event injection\n    class IInputInjector {\n        virtual void keyDown(uint16_t scancode) = 0;\n        virtual void keyUp(uint16_t scancode) = 0;\n        virtual void mouseMove(int dx, int dy) = 0;\n        // ... 10+ methods\n    };\n\n    // Input event capture\n    class IInputHook {\n        virtual void install(std::function<void(const InputEvent&)> callback) = 0;\n        virtual void uninstall() = 0;\n    };\n\n    // Input device management (Linux-specific for multi-keyboard)\n    class IInputDriver {\n        virtual std::vector<DeviceInfo> enumerateDevices() = 0;\n        virtual void openDevice(const std::string& path) = 0;\n        virtual InputEvent readEvent() = 0;\n    };\n}\n```\n\n**Implementation Pattern**:\n```cpp\n// Factory functions in each platform\nIWindowSystem* createWindowSystem() {\n    #ifdef _WIN32\n        return new WindowSystemWin32();\n    #else\n        return new WindowSystemLinux();\n    #endif\n}\n```\n\n---\n\n### Layer 2: Core Engine\n\n**Purpose**: Platform-agnostic keyboard remapping logic\n\n**Key Components**:\n\n1. **Engine** (`engine.cpp`) - Main orchestrator\n   - Input event processing\n   - Keymap selection\n   - Modifier state tracking\n   - Focus window awareness\n\n2. **Setting** (`setting.cpp`) - Configuration representation\n   - Parsed .mayu files\n   - Keymap hierarchy\n   - Key binding registry\n\n3. **SettingLoader** (`setting_loader.cpp`) - Parser\n   - Lexical analysis\n   - Syntax parsing\n   - Preprocessor (ifdef, define)\n   - Error reporting\n\n4. **Keymap** (`keymap.cpp`) - Key binding container\n   - Hash table for fast lookup\n   - Parent keymap chain\n   - Per-window overrides\n\n5. **Action/Function** (`function.cpp`) - Action executors\n   - Shell commands\n   - Window manipulation\n   - Mouse control\n   - Clipboard operations\n\n**Data Flow**:\n```\nInput Device → IInputDriver → Engine::handleInput() →\n    Keymap::lookup() → Action::execute() → IInputInjector\n```\n\n---\n\n### Layer 3: UI Layer\n\n**Windows**: Win32 native UI\n- **Tray Icon**: `Shell_NotifyIcon`, `NOTIFYICONDATA`\n- **Dialogs**: Resource-based (`DialogBox`, `.rc` files)\n- **Log Stream**: `tomsgstream` redirects to edit control via `PostMessage`\n\n**Linux**: Qt5 Widgets\n- **Tray Icon**: `QSystemTrayIcon`, `QMenu`\n- **Dialogs**: Code-based layouts (`QVBoxLayout`, `QHBoxLayout`)\n- **Log Stream**: Qt signals/slots to `QTextEdit`\n\n**Abstraction Strategy**:\n- UI and engine are **loosely coupled** via message passing\n- Engine posts notifications → UI updates\n- UI triggers actions → Engine executes\n- No direct UI object access from engine\n\n---\n\n## Cross-Platform Strategy\n\n### Conditional Compilation Approach\n\n**Pattern 1: Platform-Specific Files**\n```\nsrc/platform/windows/\n    window_system_win32.cpp\n    input_injector_win32.cpp\n    input_hook_win32.cpp\n\nsrc/platform/linux/\n    window_system_linux.cpp\n    input_injector_linux.cpp\n    input_hook_linux.cpp\n```\n\n**CMake Selection**:\n```cmake\nif(WIN32)\n    list(APPEND SOURCES src/platform/windows/*.cpp)\nelse()\n    list(APPEND SOURCES src/platform/linux/*.cpp)\nendif()\n```\n\n**Pattern 2: Inline Conditionals (Minimal)**\n```cpp\n// Only for trivial differences\n#ifdef _WIN32\n    #include <windows.h>\n    typedef HWND PlatformHandle;\n#else\n    #include <X11/Xlib.h>\n    typedef Window PlatformHandle;\n#endif\n```\n\n**Anti-Pattern (Avoid)**:\n```cpp\n// DON'T do this - creates ifdef hell\nvoid someFunction() {\n    #ifdef _WIN32\n        // 50 lines of Windows code\n    #else\n        // 50 lines of Linux code\n    #endif\n}\n```\n**Instead**: Separate files with shared interface\n\n---\n\n## Technology Decisions\n\n### Decision 1: Qt5 vs GTK+ for Linux GUI\n\n**Options Considered**:\n1. **Qt5 Widgets** (CHOSEN)\n   - ✅ Excellent cross-DE compatibility (GNOME, KDE, XFCE)\n   - ✅ Native system tray support\n   - ✅ Signals/slots for event handling\n   - ✅ Mature, stable API\n   - ❌ Larger dependency (~50MB installed)\n\n2. **GTK3/GTK4**\n   - ✅ Native on GNOME\n   - ✅ Smaller footprint\n   - ❌ System tray deprecated (requires AppIndicator)\n   - ❌ KDE integration issues\n\n3. **Raw X11 + Xlib**\n   - ✅ Zero dependencies\n   - ❌ Massive development effort\n   - ❌ Poor Wayland future\n\n**Decision**: Qt5 for broad compatibility and velocity\n\n---\n\n### Decision 2: evdev vs X11 for Input Capture\n\n**Options Considered**:\n1. **evdev + uinput** (CHOSEN)\n   - ✅ Low-level, reliable capture\n   - ✅ Works on Wayland (via uinput)\n   - ✅ Multi-keyboard support\n   - ❌ Requires root or `input` group membership\n\n2. **X11 XGrabKey**\n   - ✅ No special permissions\n   - ❌ Wayland incompatible\n   - ❌ Can't intercept grabbed keys\n   - ❌ Race conditions with other apps\n\n3. **libinput API**\n   - ✅ Modern, Wayland-ready\n   - ❌ Still experimental (2025)\n   - ❌ Complex integration\n\n**Decision**: evdev now, libinput future\n\n---\n\n### Decision 3: IPC Mechanism\n\n**Windows**: Named Pipes + PostMessage\n- **Rationale**: Hook DLL runs in target app process, needs IPC to main\n- **Implementation**: Mailslot for async, PostMessage for sync\n\n**Linux**: Unix Domain Sockets\n- **Rationale**: evdev runs in YAMY process (no injection), simpler IPC\n- **Implementation**: Single socket for all communication\n\n**Abstraction**: `IIPCChannel` interface hides platform differences\n\n---\n\n## Build System Architecture\n\n### CMake Structure\n\n```\nCMakeLists.txt (root)\n├── Windows Build\n│   ├── yamy_hook.dll (32/64-bit hook library)\n│   ├── yamy32.exe / yamy64.exe (main engine + Win32 GUI)\n│   ├── yamyd32.exe (32-bit helper for 64-bit systems)\n│   └── yamy.exe (launcher, selects 32/64-bit version)\n├── Linux Build\n│   ├── yamy_stub (main engine + evdev backend)\n│   └── yamy_qt_gui.a (Qt GUI library, static linked)\n└── Common\n    ├── Shared core engine sources\n    └── Platform-agnostic headers\n```\n\n### Build Targets\n\n| Target | Platform | Purpose |\n|--------|----------|---------|\n| `yamy_hook` | Windows | DLL injected into target apps |\n| `yamy_engine_new` | Windows | Main executable (engine + GUI) |\n| `yamy_launcher` | Windows | Architecture selector |\n| `yamyd` | Windows | 32-bit helper for WOW64 |\n| `yamy_stub` | Linux | Main executable (engine + Qt GUI) |\n| `yamy_qt_gui` | Linux | Static library for Qt widgets |\n| `yamy_test` | Both | Google Test suite |\n\n### Conditional Compilation Flags\n\n```cmake\n# Platform detection\nif(WIN32)\n    add_compile_definitions(WIN32 _WINDOWS UNICODE _UNICODE)\nelseif(UNIX AND NOT APPLE)\n    add_compile_definitions(__linux__)\nendif()\n\n# Feature flags\noption(BUILD_QT_GUI \"Build Qt5 GUI for Linux\" ON)\noption(BUILD_TESTING \"Build test suite\" OFF)\noption(USE_INI \"Use INI instead of registry (Windows)\" OFF)\n```\n\n---\n\n## Threading Model\n\n### Windows: Multi-Threaded\n\n1. **Main Thread**: UI message loop (Win32 window messages)\n2. **Engine Thread**: Keyboard handler (processes hook callbacks)\n3. **Mailslot Thread**: IPC receiver (async I/O completion routine)\n\n**Synchronization**: `CriticalSection` (Windows mutexes)\n\n### Linux: Single-Threaded (Initially)\n\n1. **Main Thread**: Qt event loop + engine + evdev polling\n\n**Future**: Move evdev to worker thread if latency issues\n\n**Synchronization**: Qt signals/slots (thread-safe by default)\n\n---\n\n## Configuration File Format (.mayu)\n\n### Syntax Overview\n\n```\n# Comments start with #\ninclude \"base.mayu\"          # File inclusion\ndefine USE_EMACS_BINDINGS    # Preprocessor\n\nkey *C-A = &Ignore           # Global binding (all windows)\nkey ~C-x = &Prefix           # Prefix key (chording)\nkey A-Tab = &OtherWindow     # Modifier combinations\n\nwindow Firefox /            # Window-specific bindings\n    key C-r = &Reload\n/end\n```\n\n### Parser Architecture\n\n**Lexer** (`setting_loader.cpp`):\n- Regex-based token recognition\n- Line-by-line streaming\n- UTF-8 support\n\n**Parser**:\n- Recursive descent\n- No AST (direct object construction)\n- Error recovery (continue after syntax errors)\n\n**Preprocessor**:\n- `include` - File merging\n- `ifdef`/`ifndef` - Conditional compilation\n- `define` - Symbol definition\n\n---\n\n## Testing Strategy\n\n### Unit Tests (Google Test)\n\n**Coverage**:\n- String utilities (UTF-8 conversion, parsing)\n- Keymap lookup (hash table correctness)\n- Modifier state machine\n- Configuration parsing edge cases\n\n**Example**:\n```cpp\nTEST(KeymapTest, BasicLookup) {\n    Keymap km;\n    km.define(ModifiedKey(VK_A, M_Ctrl), new ActionFunction(\"test\"));\n    Action* result = km.lookup(ModifiedKey(VK_A, M_Ctrl));\n    ASSERT_NE(nullptr, result);\n}\n```\n\n### Integration Tests\n\n**Windows**: `test.mayu` configuration\n- Real keyboard simulation via SendInput\n- Window focus changes\n- Multi-monitor scenarios\n\n**Linux**: evdev mock device\n- Virtual `/dev/input/eventX` device\n- Inject events, verify output\n- uinput validation\n\n### Manual Testing Checklist\n\n```\n[ ] All keys on 104/109 layout work\n[ ] Modifiers combine correctly (C-M-S-A)\n[ ] Prefix keys don't leak\n[ ] Focus change triggers keymap switch\n[ ] Multi-keyboard input (Linux)\n[ ] Wayland compatibility (basic, via XWayland)\n[ ] Performance: <1ms latency, <1% CPU\n```\n\n---\n\n## Performance Considerations\n\n### Critical Path Optimization\n\n**Hot Path**: Input event → Action execution\n```\nevdev read (100μs) → Lookup (10μs) → Execute (100μs) = ~210μs total\n```\n\n**Optimization Strategies**:\n1. **Hash table for keymap lookup** - O(1) average case\n2. **Inline modifier state checks** - No function calls\n3. **Pre-compiled actions** - No parsing at runtime\n4. **Minimal allocations** - Reuse Action objects\n\n### Memory Usage\n\n**Target**: <10MB resident set size\n\n**Breakdown**:\n- Engine core: ~2MB\n- Parsed .mayu: ~1MB (typical config)\n- Qt GUI: ~5MB (when active)\n- Buffers: ~1MB\n\n### Latency Budget\n\n| Operation | Target | Measurement |\n|-----------|--------|-------------|\n| Event read | <100μs | `clock_gettime()` before/after |\n| Keymap lookup | <10μs | Hash table profiling |\n| Action execute | <100μs | Per-action timing |\n| **Total** | **<1ms** | 99th percentile |\n\n**Monitoring**: Built-in `--benchmark` flag logs timing stats\n\n---\n\n## Dependencies\n\n### Windows Dependencies\n```\n- Windows SDK 10.0+\n- MSVC 2019+ or MinGW-w64\n- CMake 3.10+\n```\n\n### Linux Dependencies\n\n**Build-time**:\n```\n- GCC 7+ or Clang 8+\n- CMake 3.10+\n- Qt5 dev packages (qtbase5-dev, qttools5-dev)\n- X11 dev packages (libx11-dev, libxrandr-dev)\n- libudev-dev (for evdev device enumeration)\n```\n\n**Runtime**:\n```\n- Qt5 runtime (QtCore, QtWidgets, QtGui)\n- X11 libraries (Xlib, Xrandr)\n- libudev (for device discovery)\n- Membership in 'input' group (for /dev/input/* access)\n```\n\n---\n\n## Security Considerations\n\n### Privilege Requirements\n\n**Windows**: Administrator for install (hook DLL registration)\n- Runtime: Normal user (hooks work unprivileged)\n\n**Linux**: User must be in `input` group\n```bash\nsudo usermod -aG input $USER\n# Log out and back in for group to take effect\n```\n\n**Rationale**: evdev requires `/dev/input/*` read access\n\n### Attack Surface\n\n**Threat 1: Arbitrary Code Execution via .mayu**\n- **Risk**: User loads malicious .mayu file with shell commands\n- **Mitigation**: .mayu files are **user-created configuration**, not untrusted input\n- **Policy**: YAMY does not download/fetch .mayu files automatically\n\n**Threat 2: Privilege Escalation (Linux)**\n- **Risk**: Malicious app tricks YAMY into injecting input as root\n- **Mitigation**: YAMY runs as regular user, no setuid bit\n- **Defense**: Input group membership is by design, not escalation\n\n**Threat 3: Keylogger Perception**\n- **Risk**: Antivirus flags YAMY as keylogger\n- **Mitigation**: Code signing (Windows), reputation building\n- **Transparency**: Open source, auditable\n\n---\n\n## Future Technology Roadmap\n\n### 2025 Q2-Q3: Wayland Native Support\n\n**Goal**: Remove X11 dependency\n\n**Approach**:\n- `libinput` integration for event capture\n- `wlroots` virtual keyboard protocol for injection\n- Per-compositor quirks (GNOME vs KDE vs Sway)\n\n**Challenges**:\n- Wayland security model restricts input capture\n- Need compositor cooperation (not guaranteed)\n- Fallback to XWayland may be permanent\n\n### 2025 Q4: Plugin System\n\n**Goal**: User-extensible actions via scripting\n\n**Technology**: Lua 5.4 embedded\n- **Rationale**: Lightweight, easy C++ integration, fast\n- **API**: Expose `yamy.*` namespace for actions\n- **Sandboxing**: Restricted I/O, no filesystem except config dir\n\n**Example**:\n```lua\n-- Custom action: Open URL in browser\nfunction yamy.action.openURL(url)\n    os.execute(\"xdg-open \" .. url)\nend\n```\n\n### 2026+: GPU Acceleration (Experimental)\n\n**Goal**: Sub-100μs latency via GPU-accelerated lookup\n\n**Technology**: Vulkan compute shaders\n- **Rationale**: Keymap lookup is embarrassingly parallel\n- **Approach**: Upload keymap to VRAM, GPU does hash table lookup\n- **Challenge**: CPU-GPU transfer overhead may negate benefit\n\n**Status**: Research phase, may not be practical\n\n---\n\n## Technology Debt & Cleanup\n\n### Known Technical Debt\n\n1. **Windows-Specific Types in Core**\n   - **Problem**: `HWND`, `tstring`, `SW_*` constants everywhere\n   - **Impact**: Prevents Linux compilation of core engine\n   - **Fix**: Track 1 refactoring (60 tasks, 80 hours)\n   - **Priority**: CRITICAL (blocks all Linux work)\n\n2. **Single-Threaded Engine (Linux)**\n   - **Problem**: evdev polling blocks event processing\n   - **Impact**: Potential latency spikes under load\n   - **Fix**: Move evdev to worker thread with queue\n   - **Priority**: MEDIUM (optimize after v1.0)\n\n3. **Hardcoded Paths**\n   - **Problem**: Windows uses `C:\\mayu`, Linux uses `~/.yamy`\n   - **Impact**: Poor cross-platform config sharing\n   - **Fix**: XDG Base Directory spec compliance\n   - **Priority**: LOW (cosmetic)\n\n4. **Lack of Async I/O (Linux)**\n   - **Problem**: Synchronous evdev reads\n   - **Impact**: Could miss events under heavy load\n   - **Fix**: `io_uring` for async evdev reads\n   - **Priority**: LOW (io_uring requires Linux 5.1+)\n\n### Refactoring Priorities\n\n**Q1 2025** (Track 1): Remove Windows types\n**Q2 2025** (Track 2-5): Implement missing features\n**Q3 2025**: Performance optimization\n**Q4 2025**: Plugin system\n\n---\n\n## Documentation Standards\n\n### Code Documentation\n\n**Doxygen Comments**:\n```cpp\n/**\n * @brief Brief description\n *\n * Detailed description with examples.\n *\n * @param i_param Input parameter\n * @param o_param Output parameter\n * @return Return value description\n */\n```\n\n**Internal Comments**:\n- Why, not what (code shows what)\n- Edge cases and non-obvious behavior\n- Performance considerations\n- TODO with GitHub issue links\n\n### Architecture Decision Records (ADRs)\n\n**Format**:\n```markdown\n# ADR-NNN: Title\n\nDate: YYYY-MM-DD\nStatus: Accepted | Rejected | Superseded\n\n## Context\nProblem statement\n\n## Decision\nWhat we decided\n\n## Consequences\nTrade-offs and implications\n```\n\n**Location**: `docs/adr/`\n\n---\n\n**Document Version**: 1.0\n**Last Updated**: 2025-12-10\n**Reviewed By**: (Pending approval)\n",
  "fileStats": {
    "size": 17043,
    "lines": 662,
    "lastModified": "2025-12-10T14:56:16.301Z"
  },
  "comments": []
}