diff --git a/src/core/engine/engine.cpp b/src/core/engine/engine.cpp
index 97daf8c..a0eb7e7 100644
--- a/src/core/engine/engine.cpp
+++ b/src/core/engine/engine.cpp
@@ -13,6 +13,7 @@
 #endif
 #include "../platform/sync.h"
 #include "../../utils/metrics.h"
+#include "../platform/ipc.h"
 
 #include <iomanip>
 #ifdef _WIN32
diff --git a/src/core/engine/engine.h b/src/core/engine/engine.h
index 48c1d37..d2f3223 100644
--- a/src/core/engine/engine.h
+++ b/src/core/engine/engine.h
@@ -15,6 +15,8 @@
 #  include "../platform/input_driver_interface.h"
 #  include "../utils/config_store.h"
 #  include "../settings/config_manager.h"
+#  include "engine_state.h"
+#  include "../platform/ipc_defs.h"
 #  include <set>
 #  include <queue>
 #  include "../functions/function.h"
@@ -192,6 +194,7 @@ private:
     yamy::platform::EventHandle m_eSync;                /// event for synchronization
     int m_generateKeyboardEventsRecursionGuard;    /** guard against too many
                                                     recursion */
+    yamy::EngineState m_state;              /// current engine state
 
     // current key state
     Modifier m_currentLock;            /// current lock key's state
@@ -240,7 +243,11 @@ private:
     std::string m_helpMessage;            /// for &amp;HelpMessage
     std::string m_helpTitle;                /// for &amp;HelpMessage
     int m_variable;                /// for &amp;Variable,
+    std::chrono::steady_clock::time_point m_lastFocusChangedTime; /// for debouncing focus change notifications
     ///  &amp;Repeat
+    
+    yamy::platform::ThreadHandle m_perfThreadHandle; /// thread for performance metrics
+    bool volatile m_isPerfThreadRunning;     /// flag to control performance thread
 
 public:
     tomsgstream &m_log;                /** log stream (output to log
@@ -272,6 +279,11 @@ private:
     ///
     void keyboardHandler();
 
+    /// performance metrics thread
+    static unsigned int WINAPI perfMetricsHandler(void *i_this);
+    ///
+    void perfMetricsHandler();
+
     /// check focus window
     void checkFocusWindow();
     /// is modifier pressed ?
@@ -302,6 +314,12 @@ private:
     ///
     void beginGeneratingKeyboardEvents(const Current &i_c, bool i_isModifier);
 
+    /// Set the current engine state and log the transition
+    void setState(yamy::EngineState i_newState);
+
+    /// Send a notification message to the GUI via the IPC channel
+    void notifyGUI(yamy::MessageType i_type, const std::string &i_data = "");
+
     /// pop all pressed key on win32
     void keyboardResetOnWin32();
 
@@ -456,6 +474,11 @@ public:
         return m_currentFocusOfThread->m_titleName;
     }
 
+    /// Get the current engine state
+    yamy::EngineState getState() const {
+        return m_state;
+    }
+
     // StrExprSystem overrides
     std::string getClipboardText() const override;
     std::string getStrExprWindowClassName() const override;
diff --git a/src/core/engine/engine_focus.cpp b/src/core/engine/engine_focus.cpp
index 21da662..4e3af34 100644
--- a/src/core/engine/engine_focus.cpp
+++ b/src/core/engine/engine_focus.cpp
@@ -73,6 +73,13 @@ restart:
                     m_hwndFocus = m_currentFocusOfThread->m_hwndFocus;
                     checkShow(m_hwndFocus);
 
+                    // Debounce focus change notifications
+                    auto now = std::chrono::steady_clock::now();
+                    if (std::chrono::duration_cast<std::chrono::milliseconds>(now - m_lastFocusChangedTime).count() > 100) {
+                        notifyGUI(yamy::MessageType::FocusChanged, m_currentFocusOfThread->m_titleName);
+                        m_lastFocusChangedTime = now;
+                    }
+
                     Acquire a(&m_log, 1);
                     m_log << "FocusChanged" << std::endl;
                     m_log << "\tHWND:\t"
diff --git a/src/core/engine/engine_lifecycle.cpp b/src/core/engine/engine_lifecycle.cpp
index f0da157..c41abf8 100644
--- a/src/core/engine/engine_lifecycle.cpp
+++ b/src/core/engine/engine_lifecycle.cpp
@@ -14,12 +14,15 @@
 #include "../platform/message_constants.h"
 #include "../platform/sync.h"
 #include "../../utils/metrics.h"
+#include "../platform/ipc_defs.h"
 
 #include <iomanip>
 #ifdef _WIN32
 #include <process.h>
 #endif
 #include <string>
+#include <chrono>
+#include <thread>
 
 
 Engine::Engine(tomsgstream &i_log, yamy::platform::IWindowSystem *i_windowSystem, ConfigStore *i_configStore, yamy::platform::IInputInjector *i_inputInjector, yamy::platform::IInputHook *i_inputHook, yamy::platform::IInputDriver *i_inputDriver)
@@ -51,7 +54,10 @@ Engine::Engine(tomsgstream &i_log, yamy::platform::IWindowSystem *i_windowSystem
         m_hwndFocus(nullptr),
         m_afShellExecute(nullptr),
         m_variable(0),
-        m_log(i_log) {
+        m_log(i_log),
+        m_perfThreadHandle(nullptr),
+        m_isPerfThreadRunning(false) {
+    m_state = yamy::EngineState::Stopped;
     // Enable receiving WM_COPYDATA from lower integrity processes
     m_windowSystem->changeMessageFilter(yamy::platform::MSG_COPYDATA,
                                        yamy::platform::MSGFLT_ADD);
@@ -95,6 +101,9 @@ Engine::~Engine() {
 
 // start keyboard handler thread
 void Engine::start() {
+    setState(yamy::EngineState::Loading);
+    notifyGUI(yamy::MessageType::EngineStarting);
+
     // Start performance metrics collection with 60-second reporting interval
     yamy::metrics::PerformanceMetrics::instance().startPeriodicLogging(60);
 
@@ -126,15 +135,31 @@ void Engine::start() {
 
 #ifdef _WIN32
     CHECK_TRUE( m_threadHandle = reinterpret_cast<yamy::platform::ThreadHandle>(_beginthreadex(nullptr, 0, keyboardHandler, this, 0, &m_threadId)) );
+    m_isPerfThreadRunning = true;
+    CHECK_TRUE( m_perfThreadHandle = reinterpret_cast<yamy::platform::ThreadHandle>(_beginthreadex(nullptr, 0, perfMetricsHandler, this, 0, nullptr)) );
 #endif
+
+    setState(yamy::EngineState::Running);
+    notifyGUI(yamy::MessageType::EngineStarted);
 }
 
 
 // stop keyboard handler thread
 void Engine::stop() {
+    notifyGUI(yamy::MessageType::EngineStopping);
+
     // Stop performance metrics collection
     yamy::metrics::PerformanceMetrics::instance().stopPeriodicLogging();
 
+    m_isPerfThreadRunning = false;
+#ifdef _WIN32
+    if (m_perfThreadHandle) {
+        yamy::platform::waitForObject(m_perfThreadHandle, 2000);
+        CHECK_TRUE( CloseHandle(m_perfThreadHandle) );
+        m_perfThreadHandle = nullptr;
+    }
+#endif
+
     m_inputHook->uninstall();
     m_inputDriver->close();
 
@@ -157,6 +182,9 @@ void Engine::stop() {
          i != m_attachedThreadIds.end(); i++) {
          PostThreadMessage(*i, WM_NULL, 0, 0);
     }
+
+    setState(yamy::EngineState::Stopped);
+    notifyGUI(yamy::MessageType::EngineStopped);
 }
 
 
@@ -193,6 +221,14 @@ void Engine::updateLastPressedKey(Key *i_key)
 // set current keymap
 void Engine::setCurrentKeymap(const Keymap *i_keymap, bool i_doesAddToHistory)
 {
+    if (m_currentKeymap != i_keymap) {
+        if (i_keymap) {
+            notifyGUI(yamy::MessageType::KeymapSwitched, i_keymap->getName());
+        } else {
+            notifyGUI(yamy::MessageType::KeymapSwitched, "Default");
+        }
+    }
+
     if (i_doesAddToHistory) {
         m_keymapPrefixHistory.push_back(const_cast<Keymap *>(m_currentKeymap));
         if (MAX_KEYMAP_PREFIX_HISTORY < m_keymapPrefixHistory.size())
@@ -228,3 +264,47 @@ KEYBOARD_INPUT_DATA Engine::keyEventToKID(const yamy::platform::KeyEvent &event)
     kid.ExtraInformation = static_cast<unsigned long>(event.extraInfo);
     return kid;
 }
+
+void Engine::setState(yamy::EngineState i_newState)
+{
+    if (m_state == i_newState)
+        return;
+
+    // TODO: Add logging for state transitions
+    m_state = i_newState;
+}
+
+void Engine::notifyGUI(yamy::MessageType i_type, const std::string &i_data)
+{
+    if (!m_windowSystem || !m_hwndAssocWindow)
+        return;
+
+    yamy::platform::CopyData cd;
+    cd.id = static_cast<uint32_t>(i_type);
+    cd.size = static_cast<uint32_t>(i_data.size());
+    cd.data = i_data.c_str();
+
+    m_windowSystem->sendCopyData(nullptr, m_hwndAssocWindow, cd, yamy::platform::SendMessageFlags::NORMAL, 100, nullptr);
+}
+
+unsigned int WINAPI Engine::perfMetricsHandler(void *i_this)
+{
+    reinterpret_cast<Engine *>(i_this)->perfMetricsHandler();
+    return 0;
+}
+
+void Engine::perfMetricsHandler()
+{
+    while (m_isPerfThreadRunning) {
+        std::this_thread::sleep_for(std::chrono::seconds(60));
+        if (!m_isPerfThreadRunning) break;
+
+        // Send latency report
+        // This is a placeholder for actual latency reporting
+        notifyGUI(yamy::MessageType::LatencyReport, "P95: 1.2ms");
+
+        // Send CPU usage report
+        // This is a placeholder for actual CPU usage reporting
+        notifyGUI(yamy::MessageType::CpuUsageReport, "CPU: 5%");
+    }
+}
diff --git a/src/core/engine/engine_setting.cpp b/src/core/engine/engine_setting.cpp
index b45a290..32747ec 100644
--- a/src/core/engine/engine_setting.cpp
+++ b/src/core/engine/engine_setting.cpp
@@ -87,6 +87,8 @@ bool Engine::setSetting(Setting *i_setting) {
 bool Engine::switchConfiguration(const std::string& configPath) {
     namespace fs = std::filesystem;
 
+    notifyGUI(yamy::MessageType::ConfigLoading, configPath);
+
     // Validate config path exists
     if (!fs::exists(configPath) || !fs::is_regular_file(configPath)) {
         Acquire a(&m_log, 0);
@@ -94,6 +96,7 @@ bool Engine::switchConfiguration(const std::string& configPath) {
         if (m_configSwitchCallback) {
             m_configSwitchCallback(false, configPath);
         }
+        notifyGUI(yamy::MessageType::ConfigError, "File not found");
         return false;
     }
 
@@ -109,10 +112,12 @@ bool Engine::switchConfiguration(const std::string& configPath) {
         Acquire a(&m_log, 0);
         m_log << "switchConfiguration: parse exception: " << e.what() << std::endl;
         parseSuccess = false;
+        notifyGUI(yamy::MessageType::ConfigError, e.what());
     } catch (...) {
         Acquire a(&m_log, 0);
         m_log << "switchConfiguration: unknown parse exception" << std::endl;
         parseSuccess = false;
+        notifyGUI(yamy::MessageType::ConfigError, "Unknown parsing error");
     }
 
     if (!parseSuccess) {
@@ -123,6 +128,8 @@ bool Engine::switchConfiguration(const std::string& configPath) {
         if (m_configSwitchCallback) {
             m_configSwitchCallback(false, configPath);
         }
+        // Assuming the loader logs the specific error, a generic message is sent.
+        notifyGUI(yamy::MessageType::ConfigError, "Failed to parse config");
         return false;
     }
 
@@ -152,6 +159,7 @@ bool Engine::switchConfiguration(const std::string& configPath) {
         if (m_configSwitchCallback) {
             m_configSwitchCallback(false, configPath);
         }
+        notifyGUI(yamy::MessageType::ConfigError, "Failed to apply setting (engine busy)");
         return false;
     }
 
@@ -172,5 +180,6 @@ bool Engine::switchConfiguration(const std::string& configPath) {
         m_configSwitchCallback(true, configPath);
     }
 
+    notifyGUI(yamy::MessageType::ConfigLoaded, configPath);
     return true;
 }
diff --git a/src/core/engine/engine_state.h b/src/core/engine/engine_state.h
new file mode 100644
index 0000000..8401e3c
--- /dev/null
+++ b/src/core/engine/engine_state.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#ifndef _ENGINE_STATE_H
+#define _ENGINE_STATE_H
+
+namespace yamy {
+
+/// Defines the major operational states of the Engine
+enum class EngineState {
+    Stopped,    /// The engine is not running and not processing input.
+    Loading,    /// The engine is starting up and loading the configuration.
+    Running,    /// The engine is active and processing input.
+    Error,      /// The engine has encountered a fatal error and is stopped.
+};
+
+} // namespace yamy
+
+#endif // _ENGINE_STATE_H
diff --git a/src/core/platform/ipc_defs.h b/src/core/platform/ipc_defs.h
new file mode 100644
index 0000000..c0b20ff
--- /dev/null
+++ b/src/core/platform/ipc_defs.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#ifndef _PLATFORM_IPC_DEFS_H
+#define _PLATFORM_IPC_DEFS_H
+
+#include <cstdint>
+
+namespace yamy {
+
+/// IPC Message Types for GUI Notifications
+enum class MessageType : uint32_t {
+    // Engine Lifecycle
+    EngineStarting = 0x1001,
+    EngineStarted = 0x1002,
+    EngineStopping = 0x1003,
+    EngineStopped = 0x1004,
+    EngineError = 0x1005,
+
+    // Configuration
+    ConfigLoading = 0x2001,
+    ConfigLoaded = 0x2002,
+    ConfigError = 0x2003,
+    ConfigValidating = 0x2004,
+
+    // Runtime Events
+    KeymapSwitched = 0x3001,
+    FocusChanged = 0x3002,
+    ModifierChanged = 0x3003,
+
+    // Performance Metrics
+    LatencyReport = 0x4001,
+    CpuUsageReport = 0x4002,
+};
+
+} // namespace yamy
+
+#endif // _PLATFORM_IPC_DEFS_H

