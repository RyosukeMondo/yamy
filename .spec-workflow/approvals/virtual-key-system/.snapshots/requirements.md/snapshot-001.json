{
  "id": "snapshot_1765787128242_mxzoi1hsd",
  "approvalId": "approval_1765787128226_ncq06u7ak",
  "approvalTitle": "Requirements: Virtual Key System",
  "version": 1,
  "timestamp": "2025-12-15T08:25:28.242Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements: Virtual Key System\n\n**Spec Name**: virtual-key-system\n**Created**: 2025-12-15\n**Status**: Draft\n\n## Overview\n\nReplace the current broken modal modifier system with a clean virtual key architecture that provides:\n- Virtual regular keys (V_ prefix) to distinguish physical from virtual keys\n- 256 modal modifiers (M00-MFF) with tap/hold behavior\n- 256 lock keys (L00-LFF) with persistent state and GUI indicators\n\nThis solves critical issues:\n- Current modal modifier system doesn't work (mod0 activation fails)\n- Ambiguity between physical and virtual keys in substitutions\n- Need for visual feedback on lock state\n- Artificial limits on number of modifiers/locks\n\n## User Stories\n\n### US1: Virtual Keys Eliminate Ambiguity\n\n**As a** power user\n**I want** to distinguish between physical and virtual keys in my config\n**So that** I can have different behaviors for physical B vs substituted B\n\n**Acceptance Criteria**:\n- WHEN I define `def subst *A = *V_B`\n- AND I define `key M00-B = *C` and `key M00-V_B = *D`\n- THEN pressing M00+physical_B outputs C\n- AND pressing M00+physical_A (which becomes V_B) outputs D\n\n**EARS Format**:\n- WHILE in any keymap\n- WHEN physical key is substituted to virtual key\n- THE system SHALL distinguish between physical and virtual key in modifier combinations\n- WHERE virtual keys use V_ prefix\n\n### US2: Short Modifier Notation\n\n**As a** config author\n**I want** concise modifier notation\n**So that** complex key combinations are readable\n\n**Acceptance Criteria**:\n- WHEN I write `key M00-M01-L00-A = *B`\n- THEN it's clear this requires M00, M01, and L00 active with key A\n- AND it's more readable than `MOD_00-MOD_01-LOCK_00-A`\n\n**EARS Format**:\n- WHILE writing .mayu configuration\n- WHEN defining modifier/lock combinations\n- THE system SHALL accept short notation M00-MFF and L00-LFF\n- WHERE M=modifier, L=lock, followed by 2-digit hex\n\n### US3: Implicit Modifier Registration\n\n**As a** config author\n**I want** modifiers to work without explicit registration\n**So that** I write less boilerplate\n\n**Acceptance Criteria**:\n- WHEN I define `def subst *Space = *M00`\n- THEN M00 automatically works as a modal modifier\n- AND I don't need to write `mod mod0 = !!M00`\n\n**EARS Format**:\n- WHILE parsing .mayu configuration\n- WHEN M00-MFF key is referenced\n- THE system SHALL automatically register it as a modal modifier\n- WHERE default behavior is toggle/one-shot\n\n### US4: Modifier Tap Assignment\n\n**As a** user\n**I want** modifiers to output keys on tap\n**So that** one key can serve dual purposes (tap vs hold)\n\n**Acceptance Criteria**:\n- WHEN I define `mod assign M00 = *Enter`\n- AND I quickly tap the M00 key (<200ms)\n- THEN it outputs Enter\n- WHEN I hold the M00 key (≥200ms)\n- THEN it activates M00 modifier state without outputting\n\n**EARS Format**:\n- WHILE M00-MFF modifier key is pressed\n- WHEN key is released before threshold (default 200ms)\n- THE system SHALL output the assigned tap action\n- WHERE tap action is defined via `mod assign M00 = *Key`\n- IF no tap action is defined\n- THE system SHALL suppress output\n\n### US5: Modifier Combinations\n\n**As a** power user\n**I want** to combine multiple modifiers\n**So that** I can create complex key bindings\n\n**Acceptance Criteria**:\n- WHEN I define `key M00-M01-A = *Home`\n- AND I hold M00, hold M01, and press A\n- THEN it outputs Home\n- AND it matches most specific rule (most modifiers)\n\n**EARS Format**:\n- WHILE multiple modifiers M00-MFF are active\n- WHEN key is pressed\n- THE system SHALL match keymap entries requiring all active modifiers\n- WHERE most specific match (most modifiers) wins\n\n### US6: 256 Lock Keys with Persistent State\n\n**As a** user\n**I want** toggle-able lock keys that stay active\n**So that** I can lock into modes without holding keys\n\n**Acceptance Criteria**:\n- WHEN I press L00 key\n- THEN L00 toggles on (if off) or off (if on)\n- AND L00 stays active until toggled again\n- WHEN L00 is active\n- AND I press a key mapped with L00 prefix\n- THEN it outputs the L00-mapped action\n\n**EARS Format**:\n- WHILE L00-LFF lock key is pressed\n- WHEN key is released\n- THE system SHALL toggle lock state (on↔off)\n- WHERE state persists until next toggle\n- AND lock state affects keymap matching\n\n### US7: Lock Combinations (Treasure Hunting)\n\n**As a** power user\n**I want** to define behavior for multiple locks simultaneously active\n**So that** I can create combinatorial key bindings\n\n**Acceptance Criteria**:\n- WHEN I define `key L00-L01-A = *Secret`\n- AND both L00 and L01 are active\n- AND I press A\n- THEN it outputs Secret\n\n**EARS Format**:\n- WHILE multiple locks L00-LFF are active simultaneously\n- WHEN key is pressed\n- THE system SHALL match keymap entries requiring all active locks\n- WHERE most specific match (most locks) wins\n\n### US8: Visual Lock Indicators in GUI\n\n**As a** user\n**I want** to see which locks are active\n**So that** I know what mode I'm in\n\n**Acceptance Criteria**:\n- WHEN L00 is toggled on\n- THEN GUI shows L00 indicator as green/active\n- WHEN L00 is toggled off\n- THEN GUI shows L00 indicator as gray/inactive\n- AND updates happen in real-time via IPC\n\n**EARS Format**:\n- WHILE GUI is running\n- WHEN lock state changes\n- THE system SHALL send IPC notification to GUI\n- WHERE GUI displays lock status with color indicators\n- AND shows lock number (L00-LFF)\n\n### US9: 256 Modifiers and Locks (No Artificial Limits)\n\n**As a** power user\n**I want** 256 modifiers (M00-MFF) and 256 locks (L00-LFF)\n**So that** I can organize my layers however I want\n\n**Acceptance Criteria**:\n- WHEN I define M00, M01, ... MFF\n- THEN all work as modal modifiers\n- WHEN I define L00, L01, ... LFF\n- THEN all work as lock keys\n- AND hex notation (00-FF) is used for clarity\n\n**EARS Format**:\n- WHILE parsing configuration\n- WHEN M00-MFF or L00-LFF is referenced\n- THE system SHALL support full range 0x00-0xFF (256 each)\n- WHERE hex notation matches programming conventions\n\n### US10: Backward Compatibility Not Required\n\n**As a** developer\n**I want** to implement clean design\n**So that** old broken modal modifier code can be removed\n\n**Acceptance Criteria**:\n- WHEN implementing virtual key system\n- THEN old `mod mod0 = !!B` syntax is NOT supported\n- AND documentation explains migration to new syntax\n- AND existing configs must be updated\n\n**EARS Format**:\n- WHILE implementing new system\n- WHEN old syntax is encountered\n- THE system MAY show deprecation warning or error\n- WHERE users must update configs to new syntax\n\n## Non-Functional Requirements\n\n### NFR1: Performance\n- Modifier state check: <10μs\n- Lock state check: <10μs\n- Virtual key lookup: <5μs\n- No performance degradation vs current system\n\n### NFR2: Memory\n- Modifier state: 32 bytes (256 bits)\n- Lock state: 32 bytes (256 bits)\n- Virtual key mapping: O(1) hash lookup\n- Total overhead: <1KB\n\n### NFR3: Latency\n- Tap detection threshold: 200ms (configurable)\n- GUI lock indicator update: <50ms via IPC\n- Event processing: <1ms end-to-end\n\n### NFR4: Usability\n- Config syntax is clear and concise\n- Error messages explain V_ vs physical key issues\n- GUI lock indicators are visually obvious\n- Documentation includes migration guide\n\n## Out of Scope\n\n- Custom tap threshold per modifier (future enhancement)\n- Lock indicators in status bar (only in GUI)\n- Modifier/lock naming/labeling (use hex numbers only)\n- Tap-hold-tap patterns (future enhancement)\n- Backward compatibility with old modal modifier syntax\n\n## Success Metrics\n\n1. All E2E tests pass with new virtual key system\n2. M00 modal modifier activates correctly (current bug fixed)\n3. V_ virtual keys resolve physical/virtual ambiguity\n4. Lock indicators update in GUI within 50ms\n5. Config files are more concise (fewer lines than old syntax)\n6. Zero performance regression vs baseline\n\n## Dependencies\n\n- IPC system (already implemented)\n- GUI framework (Qt, already implemented)\n- Event processing pipeline (3-layer architecture exists)\n- Parser for .mayu files (needs updates for new syntax)\n\n## Risks\n\n1. **Migration effort**: All existing configs need updating\n   - Mitigation: Provide migration guide and examples\n\n2. **Parser complexity**: New syntax for V_, M00, L00\n   - Mitigation: Reuse existing parser patterns\n\n3. **Testing coverage**: Need comprehensive E2E tests\n   - Mitigation: Use existing test infrastructure from E2E testing framework\n\n## References\n\n- Current E2E testing status: `/home/rmondo/repos/yamy/CURRENT_E2E_STATUS.md`\n- Architecture document: `/home/rmondo/repos/yamy/ARCHITECTURE_REFACTOR.md`\n- Event processing: `src/core/engine/engine_event_processor.cpp`\n- Modal modifiers (broken): `src/core/engine/modifier_key_handler.cpp`\n",
  "fileStats": {
    "size": 8630,
    "lines": 275,
    "lastModified": "2025-12-15T08:25:03.746Z"
  },
  "comments": []
}