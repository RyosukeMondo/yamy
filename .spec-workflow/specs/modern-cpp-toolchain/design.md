# Design Document: Modern C++ Toolchain

## Architecture Overview

This document specifies the architectural design for modernizing YAMY's C++ development stack. The design focuses on achieving **<5-second iteration cycles** while maintaining **<1ms runtime latency** through modern build infrastructure, zero-latency observability, and mathematical correctness guarantees.

### Core Principles

1. **Velocity through Toolchain**: Build times solved by modern linkers (Mold/LLD), not architecture changes
2. **Zero-Cost Observability**: Quill logging with SPSC ring buffers eliminates hot-path blocking
3. **Fail-Fast Correctness**: GSL contracts catch bugs at precondition checks, not in production
4. **Generative Testing**: RapidCheck explores state machine combinatorics that unit tests miss
5. **AI-First Documentation**: Structure optimized for AI agent navigation and code generation

---

## Technology Stack

### Build Infrastructure

#### Linker Strategy

**Linux: Mold**
- **Mechanism**: Concurrent hashing, massive parallelism, memory-mapped I/O
- **Performance**: Links Clang 19 in 1.35s vs 42s for GNU ld (31x speedup)
- **Integration**: Via `add_link_options("-fuse-ld=mold")` in CMake
- **Fallback**: LLD if Mold unavailable

**Windows: LLD (lld-link)**
- **Mechanism**: LLVM linker with incremental linking support
- **Performance**: 3-5x faster than MSVC link.exe
- **Integration**: Via `add_link_options("/clang:-fuse-ld=lld")` with clang-cl
- **Rationale**: Mold Windows support not production-ready as of Q4 2024

**Decision Rationale**:
- GNU ld and MSVC link.exe are bottlenecks (10-60s link times)
- Mold's architecture (parallel section merging) ideal for C++ templates
- Unified Clang toolchain (Clang + Mold/LLD) ensures cross-platform consistency

#### Build Generator: Ninja

**Advantages over Make**:
- Pre-computed dependency graph (no recursive parsing)
- Starts builds in ~0.4s vs 10-30s for Make
- Perfect for incremental builds (checks only changed files)

**Integration**:
```cmake
# CMakePresets.json
"generator": "Ninja"
```

**Trade-offs**:
- ✅ 10-20x faster null builds
- ✅ Better parallelization
- ❌ Less human-readable build files (acceptable, autogenerated by CMake)

#### Build Cache: ccache

**Mechanism**:
- Caches compilation results keyed by preprocessed source + compiler flags
- Reuses cached objects across branch switches and clean builds

**Configuration**:
```cmake
find_program(CCACHE_PROGRAM ccache)
if(CCACHE_PROGRAM)
    set(CMAKE_CXX_COMPILER_LAUNCHER "${CCACHE_PROGRAM}")
    set(CMAKE_C_COMPILER_LAUNCHER "${CCACHE_PROGRAM}")
endif()
```

**Benefits**:
- 80-95% cache hit rate on branch switches
- Near-instant rebuilds for unchanged files
- Shared cache across developers (if configured)

**Storage**:
- Default: 5GB (`ccache -M 5G`)
- Location: `~/.ccache` (configurable)

---

### Dependency Management: Conan 2.0

**Why Conan**:
1. Native CMake integration via `conan_toolchain.cmake`
2. Binary caching (eliminates recompilation of dependencies)
3. Version pinning for reproducibility
4. Wide package ecosystem (Quill, GSL, RapidCheck all available)

**Dependencies**:

| Package | Version | Purpose |
|---------|---------|---------|
| **Quill** | 4.1.0+ | Zero-latency logging |
| **Microsoft GSL** | 4.0.0+ | Contract programming |
| **RapidCheck** | cci.20230815+ | Property-based testing |
| **Catch2** | 3.5.0+ | Unit testing framework |
| **fmt** | 10.2.1+ | Formatting (Quill dependency) |

**Workflow**:
```bash
# Generate toolchain
conan install . --build=missing --output-folder=build

# CMake uses generated toolchain
cmake --preset linux-debug  # Loads build/conan_toolchain.cmake

# Build
cmake --build --preset linux-debug
```

**Binary Caching**:
- Local cache: `~/.conan2`
- Remote cache: Artifactory / Conan Center (optional)
- Clean build time: <2min (vs 10min without cache)

---

### Logging Infrastructure: Quill

#### Architecture

**SPSC Ring Buffer Design**:
```
┌─────────────┐          ┌──────────────┐          ┌─────────────┐
│ Hot Path    │──Push──→ │ Ring Buffer  │──Poll──→ │ Backend     │
│ (Engine)    │          │ (Lock-free)  │          │ I/O Thread  │
└─────────────┘          └──────────────┘          └─────────────┘
   <1μs latency           Thread-local              Formatting + I/O
```

**Hot Path Operation**:
1. Serialize log arguments directly into ring buffer (no allocation)
2. Advance atomic index (single instruction)
3. Return immediately (no blocking)

**Backend Thread**:
1. Poll ring buffers from all threads
2. Format messages using libfmt
3. Write to disk/console
4. Handle I/O errors (no impact on hot path)

#### RDTSC Timestamping

**Problem**: `clock_gettime()` is a syscall (~100ns overhead)

**Solution**: Read CPU Time Stamp Counter directly
```cpp
uint64_t timestamp = __rdtsc();  // ~5ns, no syscall
```

**Benefits**:
- Nanosecond-precision timestamps
- Zero syscall overhead
- Monotonic ordering (per-core)

**Trade-offs**:
- ❌ TSC not synchronized across cores (Quill handles this)
- ❌ Frequency scaling can affect accuracy (modern CPUs have invariant TSC)

#### Structured Logging

**JSON Output**:
```cpp
LOG_INFO(logger, "Key {code} mapped to {mapped}",
         "code", input.code, "mapped", output.code);
```

**Output**:
```json
{
  "timestamp": 1234567890123,
  "level": "INFO",
  "code": 65,
  "mapped": 66,
  "message": "Key 65 mapped to 66"
}
```

**Benefits**:
- AI-compatible analysis (feed JSON to Claude/GPT-4o)
- Perfetto/Chrome tracing integration
- Programmatic log querying

---

### Contracts: Microsoft GSL

#### Design by Contract

**Philosophy**: Bugs should crash at **precondition check**, not in production

**Contract Types**:

1. **Preconditions** (`Expects`):
   - Caller's responsibility to satisfy
   - Example: `Expects(key_code < MAX_KEYS);`
   - Failure = caller bug

2. **Postconditions** (`Ensures`):
   - Function's responsibility to satisfy
   - Example: `Ensures(result != nullptr);`
   - Failure = implementation bug

3. **Invariants** (implicit):
   - Class invariants checked at entry/exit
   - Example: `Expects(!m_activeKeys.empty())` in modifier tracking

**Bounds Safety**:
```cpp
// DON'T: Pointer + size (error-prone)
void process(const InputEvent* events, size_t count);

// DO: gsl::span (bounds-checked in debug)
void process(gsl::span<const InputEvent> events);
```

**Debug vs Release**:

| Mode | Behavior | Rationale |
|------|----------|-----------|
| **Debug** | `gsl::fail_fast` → debugger breakpoint | Catch bugs immediately |
| **Release** | Optimized out OR `std::terminate` | Zero cost OR fail-safe |

**Configuration**:
```cmake
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    target_compile_definitions(yamy_core PRIVATE GSL_THROW_ON_CONTRACT_VIOLATION)
else()
    target_compile_definitions(yamy_core PRIVATE GSL_UNENFORCED_ON_CONTRACT_VIOLATION)
endif()
```

---

### Testing: RapidCheck Property-Based Testing

#### Why Property-Based Testing

**Unit Test Limitation**:
```cpp
TEST_CASE("Ctrl+A mapping") {
    Engine e;
    e.process(KeyDown(VK_CTRL));
    e.process(KeyDown(VK_A));
    REQUIRE(e.output() == ActionSelectAll);
}
```
- Tests **one** specific sequence
- Misses edge cases (e.g., Ctrl released before A)

**Property-Based Solution**:
```cpp
rc::check("All key-down events have matching key-up",
  [](const std::vector<InputEvent>& events) {
    Engine e;
    for (auto evt : events) {
        e.process(evt);
    }
    RC_ASSERT(e.activeKeys().empty());
  });
```
- Tests **thousands** of random sequences
- Explores combinations: Layers × Modifiers × History
- **Shrinks** failing cases to minimal reproduction

#### Shrinking Example

**Generated Sequence** (100 events, fails):
```
KeyDown(A), KeyDown(Shift), KeyDown(B), ..., KeyUp(Shift), ...
```

**Shrunk Sequence** (4 events, still fails):
```
KeyDown(A), KeyDown(Shift), KeyDown(B), KeyUp(A)
```

**Output**: "Bug: Key-up for A doesn't release if Shift is held"

#### Integration with Catch2

```cpp
#include <catch2/catch_test_macros.hpp>
#include <rapidcheck.h>

TEST_CASE("Property: Modifier state consistency") {
    rc::check([](std::vector<InputEvent> events) {
        // Property definition
    });
}
```

**CI Integration**:
- Run 1000 test cases per property in CI
- Run 10,000 test cases nightly (stress testing)

---

## CMakePresets.json Architecture

### Purpose

**Problem**: AI agents and developers need deterministic build commands

**Solution**: Single file specifying all build configurations

### Preset Structure

```json
{
  "version": 3,
  "configurePresets": [
    {
      "name": "linux-debug",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build/debug",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_TOOLCHAIN_FILE": "${sourceDir}/build/conan_toolchain.cmake",
        "CMAKE_CXX_COMPILER": "clang++",
        "CMAKE_C_COMPILER": "clang",
        "CMAKE_LINKER": "mold",
        "CMAKE_CXX_COMPILER_LAUNCHER": "ccache",
        "ENABLE_CONTRACTS": "ON",
        "BUILD_TESTING": "ON"
      }
    },
    {
      "name": "linux-release",
      "inherits": "linux-debug",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_INTERPROCEDURAL_OPTIMIZATION": "ON",
        "ENABLE_CONTRACTS": "OFF"
      }
    }
  ]
}
```

### Key Design Decisions

1. **Conan Toolchain Path**: Relative to source dir (works in CI and local)
2. **Compiler Launcher**: ccache enabled by default
3. **Linker Selection**: Explicit (Mold/LLD), not auto-detection
4. **Contracts**: ON in debug, OFF in release (zero cost)
5. **LTO**: Only in release (slow to compile)

---

## AI-Compatible Structure

### docs/map.md Design

**Principle**: One-file project summary for AI context

**Structure**:
```markdown
# YAMY Codebase Map

## Core Engine (Critical Path)
- `src/core/engine/engine.cpp`: Main orchestrator. Single-threaded event loop.
- `src/core/engine/engine_input.cpp`: Input handler. <1ms latency requirement.
- `src/core/input/keymap.cpp`: Hash table. O(1) lookup.

## Platform Abstraction
- `src/core/platform/window_system_interface.h`: Interface (40+ methods).
- `src/platform/linux/window_system_linux.cpp`: X11/Xlib implementation.
- `src/platform/windows/window_system_win32.cpp`: Win32 API implementation.

## Testing
- `tests/property_keymap.cpp`: RapidCheck properties for keymap invariants.
- `tests/test_engine.cpp`: Catch2 unit tests for engine lifecycle.
```

**Benefits**:
- AI reads map first (1 file vs 100+ files)
- Each entry: path + purpose + key constraint
- <100 lines total (fits in context window)

### .clinerules / .cursorrules Design

**Purpose**: System prompt injection for AI agents

**Critical Rules**:
```markdown
## Architecture Constraints

### Platform Abstraction
- ALL platform code in `src/platform/windows/` or `src/platform/linux/`
- Core engine MUST be platform-agnostic
- NEVER use `#ifdef _WIN32` in `src/core/`

### Contracts
- Preconditions: `Expects(condition)`
- Postconditions: `Ensures(condition)`
- Arrays: `gsl::span<T>` (not pointer+size)

### Logging
- Use Quill: `LOG_INFO(logger, "message")`
- NEVER use `printf`, `std::cout`, `std::cerr`
- NO logging inside input processing loop

### Testing
- Properties for state machines (RapidCheck)
- Unit tests for pure functions (Catch2)
- 80% coverage minimum (90% for critical paths)
```

**Enforcement**:
- AI agent receives as system prompt
- Pre-commit hooks verify (e.g., grep for `printf` in `src/core/`)

### Semantic Density Strategy

**Headers** (High density):
- Doxygen comments with usage examples
- Precondition/postcondition documentation
- Performance notes (e.g., "O(1) lookup")

**Implementations** (Low density):
- Minimal comments (code is self-documenting)
- Only explain **why**, not **what**

**Rationale**:
- AI reads headers to understand API
- AI generates implementation from specification
- Reduces context window usage by 50-70%

---

## Code Metrics Enforcement

### Limits

| Metric | Limit | Rationale |
|--------|-------|-----------|
| **Lines per file** | 500 | Fits in single screen scroll |
| **Lines per function** | 50 | Single responsibility principle |
| **Cyclomatic complexity** | 15 (10 critical) | Testability and maintainability |
| **Function parameters** | 5 | Use structs for >5 parameters |

### Enforcement Strategy

**Pre-commit Hook** (Git):
```bash
#!/bin/bash
# .git/hooks/pre-commit
lizard --length 500 --arguments 5 --CCN 15 src/ || exit 1
```

**CMake Target**:
```cmake
add_custom_target(check-metrics
    COMMAND lizard
        --length 500
        --CCN 15
        ${CMAKE_SOURCE_DIR}/src
    COMMENT "Checking code metrics"
)
```

**CI Pipeline**:
```yaml
- name: Code Metrics
  run: cmake --build --target check-metrics
```

---

## Migration Strategy

### Phase 1: Build Infrastructure (Week 1)

**Goal**: Establish fast build pipeline

**Tasks**:
1. Install Mold (Linux), LLD (Windows), Ninja, ccache
2. Create `CMakePresets.json` with debug/release presets
3. Configure CMake to detect and use Mold/LLD
4. Enable ccache via compiler launcher
5. Benchmark: Single-file change rebuild time

**Success Criteria**:
- Incremental build <5s
- Null build <1s

**Risks**:
- Mold compatibility issues → Fallback to LLD

---

### Phase 2: Dependency Management (Week 2)

**Goal**: Reproducible builds with Conan

**Tasks**:
1. Create `conanfile.txt` with all dependencies
2. Test `conan install` on Linux and Windows
3. Verify Conan generates `conan_toolchain.cmake` correctly
4. Integrate Conan toolchain into `CMakePresets.json`
5. Test clean build with binary cache

**Success Criteria**:
- Clean build <2min (with cache)
- All dependencies fetch without errors

**Risks**:
- Package version conflicts → Pin exact versions
- Remote binary cache unavailable → Use local cache

---

### Phase 3: Quill Logging Integration (Week 3)

**Goal**: Replace existing logging with Quill

**Tasks**:
1. Add Quill to `conanfile.txt`
2. Create Quill logger wrapper (`logger.h/cpp`)
3. Replace `printf` / `std::cout` with `LOG_INFO` macros
4. Configure JSON formatter
5. Benchmark logging latency on critical path

**Success Criteria**:
- Logging latency <1μs (99th percentile)
- JSON output compatible with Perfetto

**Risks**:
- Learning curve → Provide wrapper API and examples
- RDTSC issues on virtualized CI → Use `std::chrono` fallback

---

### Phase 4: GSL Contracts (Week 4)

**Goal**: Harden core engine APIs with contracts

**Tasks**:
1. Add Microsoft GSL to `conanfile.txt`
2. Identify critical preconditions (e.g., `key_code < MAX_KEYS`)
3. Add `Expects()` to all public engine APIs
4. Replace pointer+size with `gsl::span`
5. Configure debug/release contract behavior

**Success Criteria**:
- All engine APIs have preconditions
- Debug builds trap on violations
- Release builds have zero overhead

**Risks**:
- Over-contracting (too many checks) → Focus on public APIs only
- Performance regression in debug → Acceptable (debug is for development)

---

### Phase 5: RapidCheck Testing (Week 5)

**Goal**: Property-based tests for state machines

**Tasks**:
1. Add RapidCheck to `conanfile.txt`
2. Define 3 properties for keymap (e.g., "lookup is idempotent")
3. Define 3 properties for modifier tracking
4. Integrate with Catch2 test suite
5. Run in CI with 1000 test cases per property

**Success Criteria**:
- 80% code coverage (including property tests)
- At least 1 shrunk failure case discovered (validates shrinking works)

**Risks**:
- False positives → Use `RC_CLASSIFY` to categorize inputs
- Slow test execution → Reduce iterations in CI, increase in nightly builds

---

### Phase 6: AI Compatibility (Week 6)

**Goal**: Structure for AI agent navigation

**Tasks**:
1. Create `docs/map.md` with file-by-file descriptions
2. Create `.clinerules` and `.cursorrules` files
3. Update headers with Doxygen comments
4. Remove redundant comments from implementations
5. Test AI agent file location speed

**Success Criteria**:
- AI locates "input event processing" in <3 queries
- Headers are information-dense, implementations are sparse

**Risks**:
- Subjectivity of "good" documentation → Iterate based on AI feedback

---

### Phase 7: Metrics Enforcement (Week 7)

**Goal**: Enforce code quality bounds

**Tasks**:
1. Install lizard or cppcheck
2. Create pre-commit hook for metrics
3. Add `check-metrics` CMake target
4. Configure CI to run metrics check
5. Refactor any files exceeding limits

**Success Criteria**:
- No files >500 lines
- No functions >50 lines
- No functions with complexity >15

**Risks**:
- Existing code violations → Gradual refactoring, not blocking

---

### Phase 8: Documentation & Validation (Week 8)

**Goal**: Document and benchmark

**Tasks**:
1. Write "Modern C++ Toolchain Migration Guide"
2. Benchmark build times, logging latency, test coverage
3. Create before/after comparison table
4. Document troubleshooting (common issues)
5. Team review and feedback

**Success Criteria**:
- All requirements validated
- Documentation complete

---

## Performance Analysis

### Build Performance

**Baseline** (GCC + GNU ld + Make):
| Operation | Time |
|-----------|------|
| Clean build | 10 min |
| Incremental (1 file) | 45s |
| Null build | 12s |

**Target** (Clang + Mold + Ninja + ccache):
| Operation | Time | Improvement |
|-----------|------|-------------|
| Clean build (cache hit) | 1.5 min | 6.7x |
| Incremental (1 file) | 4s | 11x |
| Null build | 0.8s | 15x |

### Logging Performance

**Baseline** (spdlog async):
- Latency: ~10μs (mutex contention)
- Throughput: ~1M msgs/sec

**Target** (Quill SPSC):
- Latency: <1μs (lock-free)
- Throughput: ~10M msgs/sec (10x)

### Test Coverage

**Baseline** (unit tests only):
- Line coverage: 60%
- Branch coverage: 45%

**Target** (unit + property tests):
- Line coverage: 80%
- Branch coverage: 70%
- State space explored: 10,000x more combinations

---

## Security Considerations

### Contract Failures in Release

**Scenario**: Contract violation in production

**Options**:
1. **Optimize out** (no runtime check)
   - ✅ Zero cost
   - ❌ Undefined behavior on violation

2. **std::terminate**
   - ✅ Fail-safe (controlled crash)
   - ❌ User-visible crash

**Decision**: `std::terminate` for YAMY
- **Rationale**: Input remapper must not inject corrupted keystrokes
- **Trade-off**: Better to crash and restart than send arbitrary keys to OS

### Dependency Supply Chain

**Threat**: Malicious Conan packages

**Mitigation**:
- Pin exact versions in `conanfile.txt`
- Use checksums (Conan lockfiles)
- Audit dependencies (review source on GitHub)

---

## Open Questions

1. **Quill Configuration**:
   - Ring buffer size: 128KB (default) or 1MB (safer)?
   - Backend flush interval: 10ms or 100ms?

2. **Contract Granularity**:
   - Every function or just public APIs?
   - Internal invariants: assert or Expects?

3. **Property Test Iterations**:
   - CI: 1000 iterations (5min)
   - Nightly: 10,000 iterations (1hr)
   - Is this sufficient?

4. **Code Metrics**:
   - 500 lines per file too strict for platform implementations?
   - Allow exceptions for generated code?

---

**Document Version**: 1.0
**Created**: 2025-12-15
**Author**: AI Specification Generator
**Reviewed By**: (Pending approval)
