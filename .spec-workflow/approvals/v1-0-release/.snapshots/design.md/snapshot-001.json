{
  "id": "snapshot_1765467423160_nafr7uzo3",
  "approvalId": "approval_1765467423155_2yb88lpla",
  "approvalTitle": "Design Document - YAMY v1.0 Release",
  "version": 1,
  "timestamp": "2025-12-11T15:37:03.160Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: YAMY v1.0 Release\n\n## Overview\n\nThis design document outlines the technical approach for delivering YAMY v1.0, transforming the 98.5% complete Linux port into a production-ready release. The design focuses on completing pending work (integration tests, documentation), fixing code quality issues, formalizing quality assurance processes, and preparing release infrastructure.\n\n### Design Philosophy\n\n1. **Minimal Disruption**: Fix only what's broken, don't refactor working code\n2. **Test-Driven Validation**: Every fix must have corresponding test coverage\n3. **Documentation-First**: Write docs before finalizing APIs\n4. **Incremental Releases**: Prepare for ongoing maintenance, not one-off delivery\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Platform Abstraction Pattern**:\n- Fix remaining `tstring` typedef by completing migration to `std::string`\n- Replace Windows types (`BYTE`/`DWORD`) with platform-agnostic `uint8_t`/`uint32_t`\n- Ensure zero Windows-specific code in core engine\n\n**Threading Model**:\n- Add mutex protection for `m_readerThreads` vector in Linux input hook\n- Follow existing `CriticalSection` pattern (Windows) and `std::mutex` (Linux)\n\n**Testing Strategy**:\n- Extend Google Test integration test suite with 18 comprehensive test cases\n- Use Xvfb for headless GUI testing in CI\n- Integrate AddressSanitizer for memory leak detection\n\n**Build System**:\n- Fix CMakeLists.txt to include ConfigWatcher MOC generation\n- Link IIPCChannel interface implementation correctly\n- Generate coverage reports with lcov/gcov\n\n### Project Structure (structure.md)\n\n**Directory Organization** (maintained):\n```\ndocs/\n├── user-guide.md           # NEW: End-user documentation\n├── configuration-guide.md  # NEW: .mayu syntax reference\n├── troubleshooting.md      # NEW: FAQ and debugging\n├── CHANGELOG.md            # NEW: Version history\n└── RELEASE-NOTES-1.0.md    # NEW: v1.0 highlights\n\ntests/integration/\n└── integration_suite.cpp   # FIX: Complete implementation\n\nsrc/utils/\n├── stringtool.cpp          # REFACTOR: Split into multiple files\n└── stringtool_helpers.cpp  # NEW: Helper functions\n\nsrc/core/platform/\n└── config_store.h          # FIX: Remove Windows types\n\n.github/workflows/\n├── ci.yml                  # NEW: CI pipeline\n└── release.yml             # NEW: Release automation\n```\n\n**Coding Conventions** (enforced):\n- File size limit: <500 lines (stringtool.cpp violated, will refactor)\n- Function size limit: <50 lines (interpretMetaCharacters violated, will refactor)\n- Thread safety: All concurrent access protected by mutexes\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**1. Google Test Framework** (`tests/googletest/`)\n- Already integrated, 9 unit test files exist\n- Reuse test fixtures and utilities for integration tests\n- Extend with mocking framework for IPC testing\n\n**2. Integration Test Framework** (`tests/integration/integration_suite.cpp`)\n- 18 test cases already written (1,235 lines)\n- MockInputHook and MockInputInjector classes ready\n- Need to fix build errors (ConfigWatcher vtable, IIPCChannel)\n\n**3. Qt Test Framework** (available via Qt5Test module)\n- Use for GUI dialog testing\n- QTest::qWait() for async event handling\n- QSignalSpy for signal/slot verification\n\n**4. AddressSanitizer Support** (already in CMakeLists.txt)\n- Conditional compilation flag for memory leak detection\n- Integrate with CI for automated leak checks\n\n**5. CMake Test Integration** (CTest)\n- Already configured with `add_test()` commands\n- Extend for coverage reporting with `--coverage` flag\n\n### Integration Points\n\n**Build System → Test Suite**:\n- CMakeLists.txt links regression test executable\n- Missing: MOC generation for ConfigWatcher Qt signals\n- Missing: Link IIPCChannel base class implementation\n\n**Core Engine → Platform Layer**:\n- Engine uses platform interfaces (IWindowSystem, IInputHook, etc.)\n- Integration tests mock these interfaces\n- No changes needed, just test coverage\n\n**Documentation → Examples**:\n- Example .mayu files already exist in repository\n- Integrate into documentation with tested examples\n- Link to example plugin implementation (task 6.17)\n\n## Architecture\n\n### System Context Diagram\n\n```mermaid\ngraph TB\n    subgraph \"v1.0 Release Scope\"\n        IntTests[Integration Tests]\n        UserDocs[User Documentation]\n        BuildFix[Build System Fixes]\n        CodeQA[Code Quality Fixes]\n        CISystem[CI/CD Pipeline]\n        ReleasePkg[Release Packages]\n    end\n\n    subgraph \"Existing System (129/131 tasks complete)\"\n        Engine[Core Engine]\n        PlatformLinux[Linux Platform Layer]\n        QtGUI[Qt5 GUI]\n        IPC[IPC System]\n        ConfigMgr[Config Management]\n    end\n\n    IntTests -->|validates| Engine\n    IntTests -->|validates| PlatformLinux\n    IntTests -->|validates| QtGUI\n    IntTests -->|validates| IPC\n\n    UserDocs -->|documents| ConfigMgr\n    UserDocs -->|explains| QtGUI\n\n    BuildFix -->|compiles| IntTests\n    CodeQA -->|improves| Engine\n    CodeQA -->|fixes| PlatformLinux\n\n    CISystem -->|runs| IntTests\n    CISystem -->|generates| UserDocs\n    CISystem -->|builds| ReleasePkg\n\n    ReleasePkg -->|distributes| Engine\n    ReleasePkg -->|distributes| PlatformLinux\n    ReleasePkg -->|distributes| QtGUI\n```\n\n### Modular Design Principles\n\n**Integration Test Module** (isolated testing):\n- Create test-only mock implementations of platform interfaces\n- Use Google Test fixtures for setup/teardown\n- Run tests in isolated temp directories\n- No side effects on host system (use Xvfb, temp configs)\n\n**Documentation Module** (single source of truth):\n- Markdown files as primary documentation source\n- Generate HTML/PDF from markdown using mdBook or similar\n- Include code snippets from tested example files\n- Version docs alongside code (same Git repo)\n\n**Build System Module** (reproducible builds):\n- CMake generates native build files (Makefile, Ninja)\n- Separate targets for development vs release builds\n- Coverage builds use `--coverage` compiler flag\n- Release builds strip symbols and optimize (-O2/-O3)\n\n**CI/CD Module** (automated quality gates):\n- GitHub Actions workflows for PRs and releases\n- Matrix builds across Ubuntu/Fedora/Arch\n- Artifact caching for faster builds\n- Release artifact upload to GitHub Releases\n\n## Components and Interfaces\n\n### Component 1: Integration Test Suite\n\n**Purpose:** Validate all components working together, ensure no regressions\n\n**Interfaces:**\n```cpp\n// Test runner entry point (Google Test)\nint main(int argc, char** argv);\n\n// Test fixtures\nclass IntegrationLifecycleTest : public ::testing::Test;\nclass IntegrationIPCTest : public ::testing::Test;\nclass IntegrationSessionTest : public ::testing::Test;\nclass IntegrationPerformanceTest : public ::testing::Test;\n\n// Mock platform implementations (existing)\nclass MockInputHook : public platform::IInputHook;\nclass MockInputInjector : public platform::IInputInjector;\n```\n\n**Dependencies:**\n- Google Test framework (`gtest/gtest.h`)\n- Core engine (`engine.h`, `setting.h`, `keymap.h`)\n- Platform interfaces (`input_hook_interface.h`, etc.)\n- Session manager (`session_manager.h`)\n- Config manager (`config_manager.h`)\n\n**Reuses:**\n- Existing test fixtures from unit tests\n- Mock implementations from `tests/integration/integration_suite.cpp`\n- Test utilities from `tests/helpers/` (if exist)\n\n**Build Fix Requirements:**\n1. Add ConfigWatcher MOC generation to CMakeLists.txt:\n   ```cmake\n   qt5_wrap_cpp(CONFIG_WATCHER_MOC src/core/settings/config_watcher.h)\n   target_sources(yamy_regression_test PRIVATE ${CONFIG_WATCHER_MOC})\n   ```\n\n2. Implement IIPCChannel vtable (add empty implementation file):\n   ```cpp\n   // src/core/platform/ipc_interface.cpp\n   #include \"ipc_interface.h\"\n\n   namespace yamy::platform {\n       IIPCChannel::~IIPCChannel() = default;\n   }\n   ```\n\n3. Link Qt5Test module for Qt signal testing:\n   ```cmake\n   find_package(Qt5Test REQUIRED)\n   target_link_libraries(yamy_regression_test PRIVATE Qt5::Test)\n   ```\n\n---\n\n### Component 2: User Documentation System\n\n**Purpose:** Provide comprehensive, searchable, maintainable user documentation\n\n**Interfaces:**\n- Markdown files rendered to HTML (mdBook, Docusaurus, or Jekyll)\n- Internal cross-references (`[link text](path/to/doc.md)`)\n- Code snippets included from source (`{{#include path/to/file.cpp:lines}}`)\n\n**Dependencies:**\n- Markdown processor (mdBook recommended for simplicity)\n- Syntax highlighting (highlight.js)\n- Search index (lunr.js for static search)\n\n**Reuses:**\n- Existing example .mayu files\n- Screenshots from `docs/` directory\n- Architecture diagrams from `docs/GUI-ARCHITECTURE.md`\n\n**Structure:**\n```markdown\ndocs/\n├── user-guide.md\n│   ├── 1. Introduction\n│   ├── 2. Installation (Ubuntu, Fedora, Arch)\n│   ├── 3. Quick Start\n│   ├── 4. Basic Configuration\n│   ├── 5. System Tray Usage\n│   ├── 6. Investigate Dialog\n│   ├── 7. Log Viewer\n│   ├── 8. Preferences\n│   └── 9. Advanced Features\n│\n├── configuration-guide.md\n│   ├── 1. .mayu Syntax Overview\n│   ├── 2. Key Definitions\n│   ├── 3. Modifier Keys\n│   ├── 4. Window Matching (regex)\n│   ├── 5. Keymap Inheritance\n│   ├── 6. Functions Reference (100+ commands)\n│   ├── 7. Conditional Compilation (ifdef)\n│   └── 8. Example Configurations\n│       ├── Emacs bindings\n│       ├── Vim bindings\n│       └── International keyboards\n│\n└── troubleshooting.md\n    ├── 1. Common Issues\n    │   ├── Keys not remapping\n    │   ├── Config syntax errors\n    │   ├── Permission denied (/dev/input)\n    │   ├── Qt not found\n    │   └── X11 connection failed\n    ├── 2. Debugging Techniques\n    │   ├── Viewing logs (--debug flag)\n    │   ├── Using Investigate dialog\n    │   ├── Testing with yamy-ctl\n    │   └── Checking uinput module\n    ├── 3. Known Limitations\n    │   ├── Wayland limitations (via XWayland)\n    │   ├── Some window managers (i3, Sway quirks)\n    │   └── Multi-monitor edge cases\n    ├── 4. Reporting Bugs\n    │   └── GitHub issue template\n    └── 5. FAQ (20+ questions)\n```\n\n**Validation:**\n- All code examples must be tested (include from actual working files)\n- All commands must be runnable (verify with script)\n- All links must resolve (markdown linter)\n- Screenshots current with latest GUI (visual regression testing)\n\n---\n\n### Component 3: Code Quality Fixes\n\n**Purpose:** Eliminate architectural violations and thread safety issues\n\n**Fix 1: Remove tstring typedef**\n\n**Current State:**\n```cpp\n// src/utils/stringtool.h:31\nusing tstring = std::string;\n```\n\n**Problem:** Backward compatibility alias prevents full abstraction\n\n**Solution:** Search-and-replace across codebase\n```bash\n# Find all usages\ngrep -r \"tstring\" src/ --include=\"*.h\" --include=\"*.cpp\"\n\n# Replace with std::string\nsed -i 's/\\btstring\\b/std::string/g' src/**/*.{h,cpp}\n\n# Remove typedef\n# Delete line 31 from stringtool.h\n```\n\n**Impact:** ~100 files changed (estimated from previous refactoring)\n\n**Testing:** Full rebuild + unit tests must pass\n\n---\n\n**Fix 2: Replace Windows types in config_store.h**\n\n**Current State:**\n```cpp\n// src/utils/config_store.h:46-51\nvirtual bool read(const std::string& key, BYTE* o_value) = 0;\nvirtual bool write(const std::string& key, DWORD value) = 0;\n```\n\n**Problem:** Windows types in platform-agnostic interface\n\n**Solution:**\n```cpp\n// After fix\nvirtual bool read(const std::string& key, uint8_t* o_value) = 0;\nvirtual bool write(const std::string& key, uint32_t value) = 0;\n```\n\n**Implementation Sites:**\n- `src/platform/windows/config_store_win32.cpp`\n- `src/platform/linux/config_store_linux.cpp` (QSettings wrapper)\n\n**Testing:** Config management unit tests\n\n---\n\n**Fix 3: Add mutex protection to input_hook_linux.cpp**\n\n**Current State:**\n```cpp\n// src/platform/linux/input_hook_linux.cpp:259\n// m_readerThreads vector accessed without lock\nm_readerThreads.push_back(std::move(thread));\n```\n\n**Problem:** Race condition when threads start/stop concurrently\n\n**Solution:**\n```cpp\n// Add member variable\nstd::mutex m_readerThreadsMutex;\n\n// Protect all vector operations\n{\n    std::lock_guard<std::mutex> lock(m_readerThreadsMutex);\n    m_readerThreads.push_back(std::move(thread));\n}\n\n// Also protect reads\n{\n    std::lock_guard<std::mutex> lock(m_readerThreadsMutex);\n    for (auto& thread : m_readerThreads) {\n        if (thread.joinable()) thread.join();\n    }\n}\n```\n\n**Impact:** 5 vector operations need protection (push_back, clear, iteration, size, empty)\n\n**Testing:** Thread sanitizer (`-fsanitize=thread`) with concurrent device plug/unplug\n\n---\n\n**Fix 4: Refactor interpretMetaCharacters() function**\n\n**Current State:**\n- `src/utils/stringtool.cpp` line count: 569 (69 over limit)\n- `interpretMetaCharacters()` function: 152 lines (102 over limit)\n\n**Problem:** Function too complex, file too large\n\n**Solution Strategy:**\n\n1. **Extract helper functions:**\n```cpp\n// Extract state machine states\nenum class ParseState { Normal, Escape, Octal, Hex, Unicode };\n\n// Helper: Parse escape sequence\nstatic char parseEscapeSequence(const char*& p);\n\n// Helper: Parse octal number\nstatic char parseOctalNumber(const char*& p, int maxDigits);\n\n// Helper: Parse hex number\nstatic char parseHexNumber(const char*& p, int digits);\n\n// Helper: Parse unicode codepoint\nstatic std::string parseUnicodeCodepoint(const char*& p);\n\n// Refactored main function (now ~40 lines)\nstd::string interpretMetaCharacters(const std::string& input) {\n    std::string result;\n    const char* p = input.c_str();\n\n    while (*p) {\n        if (*p != '\\\\') {\n            result += *p++;\n            continue;\n        }\n\n        ++p;  // Skip backslash\n        result += parseEscapeSequence(p);\n    }\n\n    return result;\n}\n```\n\n2. **Split stringtool.cpp into multiple files:**\n```\nsrc/utils/\n├── stringtool.h              # Public API declarations\n├── stringtool.cpp            # Basic string functions (~200 lines)\n├── stringtool_conversion.cpp # Encoding conversion (~150 lines)\n├── stringtool_parsing.cpp    # Parsing utilities (~150 lines)\n└── stringtool_private.h      # Shared private helpers\n```\n\n**Testing:** Existing unit tests for string utilities must pass unchanged\n\n---\n\n### Component 4: Test Coverage Infrastructure\n\n**Purpose:** Measure and enforce code coverage thresholds\n\n**Architecture:**\n\n```\nDeveloper → CMake (--coverage) → Compiler (gcov) → lcov → HTML Report\n                                                          ↓\nCI System → CMake + CTest → Test Run → Coverage Check → Pass/Fail\n```\n\n**Implementation:**\n\n1. **CMake Coverage Target:**\n```cmake\noption(ENABLE_COVERAGE \"Enable code coverage\" OFF)\n\nif(ENABLE_COVERAGE)\n    add_compile_options(--coverage -O0 -g)\n    add_link_options(--coverage)\nendif()\n\n# Coverage target\nif(ENABLE_COVERAGE)\n    find_program(LCOV lcov REQUIRED)\n    find_program(GENHTML genhtml REQUIRED)\n\n    add_custom_target(coverage\n        COMMAND ${CMAKE_COMMAND} -E remove_directory coverage\n        COMMAND ${CMAKE_COMMAND} -E make_directory coverage\n        COMMAND ${LCOV} --directory . --zerocounters\n        COMMAND ${CMAKE_CTEST_COMMAND} --output-on-failure\n        COMMAND ${LCOV} --directory . --capture --output-file coverage/coverage.info\n        COMMAND ${LCOV} --remove coverage/coverage.info '/usr/*' '*/tests/*' --output-file coverage/coverage_filtered.info\n        COMMAND ${GENHTML} coverage/coverage_filtered.info --output-directory coverage/html\n        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n        COMMENT \"Generating code coverage report\"\n    )\nendif()\n```\n\n2. **Coverage Threshold Check:**\n```cmake\n# Fail build if coverage below threshold\nadd_custom_command(TARGET coverage POST_BUILD\n    COMMAND ${LCOV} --summary coverage/coverage_filtered.info | grep -oP \"lines......: \\\\K[0-9.]+\" | awk '{if ($1 < 80.0) exit 1}'\n    COMMENT \"Checking coverage threshold (80%)\"\n)\n```\n\n3. **CI Integration:**\n```yaml\n# .github/workflows/ci.yml\n- name: Build with coverage\n  run: cmake -B build -DENABLE_COVERAGE=ON && cmake --build build\n\n- name: Run tests and generate coverage\n  run: cmake --build build --target coverage\n\n- name: Upload coverage report\n  uses: codecov/codecov-action@v3\n  with:\n    files: build/coverage/coverage.info\n```\n\n**Reuses:**\n- Existing CTest integration\n- Google Test test suite\n- CMake build system\n\n---\n\n### Component 5: Platform Compatibility Validation\n\n**Purpose:** Ensure reliable operation across Linux distributions and desktop environments\n\n**Testing Matrix:**\n\n| Distribution | Desktop Environment | Display Server | Test Scope |\n|--------------|---------------------|----------------|------------|\n| Ubuntu 24.04 | GNOME 46           | Wayland (X11)  | Full       |\n| Fedora 40    | GNOME 46 (Wayland) | Wayland        | Full       |\n| Arch Linux   | KDE Plasma 6       | X11            | Full       |\n| Debian 12    | XFCE 4.18          | X11            | Smoke      |\n\n**Test Procedure:**\n\n1. **Installation Testing:**\n```bash\n# Ubuntu/Debian\nsudo dpkg -i yamy_1.0.0-1_amd64.deb\nyamy --version\nyamy-ctl status\n\n# Fedora\nsudo dnf install yamy-1.0.0-1.fc40.x86_64.rpm\nsystemctl --user status yamy\n\n# Arch (AUR)\nyay -S yamy\npacman -Qi yamy\n```\n\n2. **Functional Testing Checklist:**\n```\n[ ] System tray icon displays\n[ ] Left-click tray opens menu\n[ ] Right-click tray opens context menu\n[ ] Settings dialog opens and lists configs\n[ ] Investigate dialog captures window info\n[ ] Log viewer displays engine events\n[ ] Key remapping works (A→B test)\n[ ] Ctrl+A remaps correctly\n[ ] Window-specific keymaps activate\n[ ] Config reload (yamy-ctl reload) works\n[ ] Session restored on reboot\n[ ] No crashes after 1 hour operation\n```\n\n3. **Performance Benchmarking:**\n```bash\n# Latency measurement\nyamy --benchmark --duration=60 > benchmark.log\n\n# Parse results\ngrep \"p99 latency\" benchmark.log\n# Expected: <1.0ms\n\n# Memory usage\nps aux | grep yamy | awk '{print $6/1024 \" MB\"}'\n# Expected: <10 MB\n\n# CPU usage (idle)\ntop -b -n 60 -d 1 -p $(pgrep yamy) | grep yamy | awk '{sum+=$9; count++} END {print sum/count \"%\"}'\n# Expected: <1%\n```\n\n**Reuses:**\n- Existing performance metrics collection (task 6.6)\n- Built-in --benchmark flag\n- Integration tests for functional validation\n\n---\n\n### Component 6: Release Automation\n\n**Purpose:** Generate versioned, signed, distributable packages\n\n**Package Formats:**\n\n1. **.deb (Debian/Ubuntu):**\n```\nDEBIAN/\n├── control (metadata, dependencies)\n├── postinst (udev rules, group setup)\n├── prerm (service stop)\n└── postrm (cleanup)\n\nusr/\n├── bin/yamy\n├── bin/yamy-ctl\n├── share/\n│   ├── doc/yamy/ (user-guide, changelog)\n│   ├── icons/hicolor/256x256/apps/yamy.png\n│   └── applications/yamy.desktop\n└── lib/systemd/user/yamy.service\n```\n\n2. **.rpm (Fedora/openSUSE):**\n```spec\nName: yamy\nVersion: 1.0.0\nRelease: 1%{?dist}\nSummary: Cross-platform keyboard remapper\nLicense: MIT\nURL: https://github.com/user/yamy\n\nBuildRequires: gcc-c++, cmake, qt5-qtbase-devel, libX11-devel\nRequires: qt5-qtbase, libX11, libudev\n\n%description\nYAMY is a powerful keyboard remapping utility...\n\n%files\n/usr/bin/yamy\n/usr/bin/yamy-ctl\n...\n```\n\n3. **AUR PKGBUILD (Arch Linux):**\n```bash\n# PKGBUILD\npkgname=yamy\npkgver=1.0.0\npkgrel=1\npkgdesc=\"Cross-platform keyboard remapper\"\narch=('x86_64')\nurl=\"https://github.com/user/yamy\"\nlicense=('MIT')\ndepends=('qt5-base' 'libx11' 'libudev')\nmakedepends=('cmake' 'gcc')\nsource=(\"$pkgname-$pkgver.tar.gz::$url/archive/v$pkgver.tar.gz\")\nsha256sums=('SKIP')\n\nbuild() {\n    cmake -B build -S \"$pkgname-$pkgver\" \\\n        -DCMAKE_BUILD_TYPE=Release \\\n        -DCMAKE_INSTALL_PREFIX=/usr\n    cmake --build build\n}\n\npackage() {\n    DESTDIR=\"$pkgdir\" cmake --install build\n}\n```\n\n**CI Workflow:**\n```yaml\n# .github/workflows/release.yml\nname: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build-packages:\n    strategy:\n      matrix:\n        os: [ubuntu-24.04, fedora-40]\n    runs-on: ${{ matrix.os }}\n\n    steps:\n      - name: Build .deb package\n        if: matrix.os == 'ubuntu-24.04'\n        run: |\n          cmake -B build -DCMAKE_BUILD_TYPE=Release\n          cmake --build build --target package\n          mv build/yamy_*.deb artifacts/\n\n      - name: Build .rpm package\n        if: matrix.os == 'fedora-40'\n        run: |\n          cmake -B build -DCMAKE_BUILD_TYPE=Release\n          cpack -G RPM\n          mv build/yamy_*.rpm artifacts/\n\n      - name: Upload artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: packages-${{ matrix.os }}\n          path: artifacts/*\n\n  create-release:\n    needs: build-packages\n    runs-on: ubuntu-latest\n    steps:\n      - name: Create GitHub Release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: |\n            artifacts/*.deb\n            artifacts/*.rpm\n            artifacts/*.tar.gz\n          body_path: RELEASE-NOTES-1.0.md\n```\n\n---\n\n## Data Models\n\n### Coverage Report Model\n\n```cpp\nstruct CoverageData {\n    std::string file_path;           // Source file\n    int lines_total;                 // Total lines of code\n    int lines_covered;               // Lines executed by tests\n    double coverage_percentage;      // (covered / total) * 100\n    std::vector<int> uncovered_lines;// Line numbers not covered\n};\n\nstruct ProjectCoverage {\n    double overall_coverage;         // Project-wide percentage\n    std::map<std::string, CoverageData> file_coverage;\n    bool meets_threshold;            // true if >= 80%\n};\n```\n\n### Release Metadata Model\n\n```json\n{\n  \"version\": \"1.0.0\",\n  \"release_date\": \"2025-04-15\",\n  \"git_commit\": \"a1b2c3d4\",\n  \"build_number\": 42,\n  \"artifacts\": [\n    {\n      \"filename\": \"yamy_1.0.0-1_amd64.deb\",\n      \"sha256\": \"...\",\n      \"size_bytes\": 2457600,\n      \"platform\": \"ubuntu-24.04\"\n    }\n  ],\n  \"test_results\": {\n    \"unit_tests_passed\": 156,\n    \"integration_tests_passed\": 18,\n    \"coverage_percentage\": 82.4\n  }\n}\n```\n\n## Error Handling\n\n### Error Scenario 1: Integration Test Failures\n\n**Description:** One or more integration tests fail during CI run\n\n**Handling:**\n1. Parse Google Test XML output for failed test names\n2. Extract failure messages and stack traces\n3. Post comment on PR with failure details\n4. Block PR merge until tests pass\n\n**User Impact:** Developer sees clear error message in PR, knows which test failed\n\n---\n\n### Error Scenario 2: Coverage Below Threshold\n\n**Description:** Code coverage drops below 80% minimum\n\n**Handling:**\n1. lcov generates coverage report showing uncovered lines\n2. CMake post-build check fails with error message\n3. CI pipeline marked as failed\n4. Developer notified to add tests\n\n**User Impact:** Quality gate enforced, regression prevented\n\n---\n\n### Error Scenario 3: Package Build Failure\n\n**Description:** .deb or .rpm package fails to build\n\n**Handling:**\n1. cpack logs error details (missing files, permission issues)\n2. CI artifacts include full build log\n3. Release workflow aborts, no partial release\n4. Maintainer notified via email\n\n**User Impact:** Users never receive broken packages\n\n---\n\n### Error Scenario 4: Documentation Link Rot\n\n**Description:** Internal documentation links become broken\n\n**Handling:**\n1. markdown-link-check validates all links during build\n2. Dead links reported in CI output\n3. Build fails if critical links broken\n4. Optional: Generate redirect map for moved pages\n\n**User Impact:** Users never encounter 404 errors in docs\n\n## Testing Strategy\n\n### Unit Testing\n\n**Scope:** Individual functions and classes in isolation\n\n**Coverage:**\n- String utility refactored functions (interpretMetaCharacters helpers)\n- Config store Windows type replacements\n- Mutex-protected thread vector operations\n\n**Example:**\n```cpp\nTEST(StringToolTest, ParseEscapeSequenceHandlesBackslashN) {\n    const char* input = \"\\\\n\";\n    char result = parseEscapeSequence(input);\n    EXPECT_EQ('\\n', result);\n}\n\nTEST(ConfigStoreTest, ReadWriteUint8) {\n    ConfigStoreMock store;\n    uint8_t value = 42;\n    store.write(\"test_key\", value);\n\n    uint8_t read_value = 0;\n    ASSERT_TRUE(store.read(\"test_key\", &read_value));\n    EXPECT_EQ(42, read_value);\n}\n```\n\n---\n\n### Integration Testing\n\n**Scope:** End-to-end component interaction\n\n**Coverage:**\n- Full lifecycle (start engine, load config, process keys, stop)\n- IPC commands (reload, stop, status, metrics)\n- GUI integration (tray icon, dialogs, notifications)\n- Session save/restore\n- Performance benchmarks\n\n**Example:**\n```cpp\nTEST_F(IntegrationLifecycleTest, FullLifecycleInitLoadProcessShutdown) {\n    // Initialize engine\n    EXPECT_FALSE(m_inputHook->isInstalled());\n\n    // Load configuration\n    LoadConfig(getKeyDefinitions() + _T(\"keymap Global\\nkey A = B\\n\"));\n\n    // Install hook\n    m_inputHook->install(callback, nullptr);\n    ASSERT_TRUE(m_inputHook->isInstalled());\n\n    // Process events\n    m_inputHook->simulateKeyPressRelease(SC_A);\n    EXPECT_EQ(receivedEvents.size(), 2u);\n\n    // Shutdown\n    m_inputHook->uninstall();\n    EXPECT_FALSE(m_inputHook->isInstalled());\n}\n```\n\n---\n\n### End-to-End Testing\n\n**Scope:** Real system interaction on target platforms\n\n**Approach:**\n1. Deploy to VM (Ubuntu 24.04, Fedora 40, Arch)\n2. Install package using native package manager\n3. Run functional test suite (automated via expect/pexpect)\n4. Capture logs and screenshots for regression detection\n\n**Test Script:**\n```python\nimport subprocess\nimport pexpect\n\ndef test_basic_installation():\n    # Install package\n    child = pexpect.spawn('sudo dpkg -i yamy_1.0.0-1_amd64.deb')\n    child.expect('Setting up yamy')\n\n    # Start application\n    yamy = pexpect.spawn('yamy')\n    yamy.expect('Engine started')\n\n    # Test CLI control\n    subprocess.run(['yamy-ctl', 'status'], check=True)\n\n    # Cleanup\n    yamy.sendcontrol('c')\n    yamy.wait()\n```\n\n---\n\n### Performance Testing\n\n**Scope:** Latency and resource usage benchmarks\n\n**Metrics:**\n- Key processing latency (p50, p95, p99)\n- Memory usage (RSS, heap allocations)\n- CPU usage (idle, under load)\n\n**Baseline:** Must not regress from current measurements\n\n```bash\n# Automated benchmark run\nyamy --benchmark --duration=300 --output=benchmark.json\n\n# Parse results\njq '.latency_p99_ms' benchmark.json\n# Assert: value < 1.0\n```\n\n---\n\n## Modular Design Principles\n\n### Single File Responsibility\n\n**Before (violation):**\n```\nstringtool.cpp: 569 lines\n  - String conversion (UTF-8/UTF-16)\n  - Escape sequence parsing\n  - Regex utilities\n  - Miscellaneous string ops\n```\n\n**After (compliant):**\n```\nstringtool.cpp: 200 lines\n  - Basic string operations only\n\nstringtool_conversion.cpp: 150 lines\n  - UTF-8/UTF-16 conversion only\n\nstringtool_parsing.cpp: 150 lines\n  - Escape sequences and parsing only\n\nstringtool_regex.cpp: 70 lines\n  - Regex utilities only\n```\n\n### Component Isolation\n\n**Test Suite:**\n- No dependency on production platform implementations\n- Uses mock objects (MockInputHook, MockInputInjector)\n- Runs in isolated temp directories\n- No network or filesystem side effects\n\n**Documentation:**\n- Generated from source (single source of truth)\n- No manual copy-paste from code\n- Validated during CI (link checking, example testing)\n\n---\n\n## Release Checklist\n\n**Pre-Release (1 week before):**\n- [ ] All integration tests passing\n- [ ] Documentation complete and reviewed\n- [ ] Code quality issues resolved\n- [ ] Coverage ≥80% with report generated\n- [ ] Platform compatibility validated (3 distros)\n- [ ] Beta testing period complete (20+ testers, 2 weeks)\n- [ ] Release notes drafted and approved\n\n**Release Day:**\n- [ ] Tag version v1.0.0 in Git\n- [ ] CI builds all packages (.deb, .rpm, .tar.gz)\n- [ ] Verify package signatures\n- [ ] Create GitHub Release with artifacts\n- [ ] Update AUR PKGBUILD\n- [ ] Announce on forums (Reddit, HN, mailing list)\n\n**Post-Release (1 week after):**\n- [ ] Monitor issue tracker for critical bugs\n- [ ] Respond to user feedback\n- [ ] Plan v1.0.1 hotfix if needed\n- [ ] Document lessons learned\n\n---\n\n**Document Version**: 1.0\n**Last Updated**: 2025-12-12\n**Spec Name**: v1-0-release\n**Reviewed By**: (Pending approval)\n",
  "fileStats": {
    "size": 28368,
    "lines": 1040,
    "lastModified": "2025-12-11T15:33:18.361Z"
  },
  "comments": []
}