{
  "id": "snapshot_1765686808443_7efs49pbz",
  "approvalId": "approval_1765686808437_i4yegei7g",
  "approvalTitle": "Requirements: Modal Modifier Remapping",
  "version": 1,
  "timestamp": "2025-12-14T04:33:28.443Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document: Modal Modifier Remapping\n\n## Introduction\n\nModal modifier remapping is a core feature that enables advanced keyboard customization through hold-vs-tap key detection and modal layer activation. This feature allows users to transform any key into a dual-purpose key (tap for normal function, hold for modifier activation) and use modal modifiers (mod0-mod19) in key combinations.\n\n**Purpose**: Enable power users to maximize keyboard efficiency by eliminating the need for dedicated modifier keys, allowing any key to act as both a regular key and a modifier layer trigger.\n\n**Value**: This feature is critical for:\n- **Cross-platform developers**: Maintain identical keyboard layouts on Windows and Linux\n- **Emacs/Vim users**: System-wide modal editing with custom prefix keys\n- **Keyboard enthusiasts**: Full QMK-like functionality without custom hardware\n\n## Alignment with Product Vision\n\nThis feature directly supports the YAMY Product Vision (product.md):\n\n1. **Zero Compromise Cross-Platform** (Principle 1)\n   - Implements 100% feature parity with Windows modal modifier system\n   - Identical .mayu file syntax works on both platforms\n   - Same keyboard behavior on Windows and Linux\n\n2. **Performance First** (Principle 2)\n   - Sub-millisecond latency for modifier detection\n   - Efficient hold/tap threshold detection (default 200ms)\n   - No frame drops during modifier state transitions\n\n3. **Power User Focused** (Principle 3)\n   - Full Turing-complete modal layer programming\n   - 20 modal layers (mod0-mod19) for complex workflows\n   - Supports chording with standard modifiers (Ctrl+Mod9+X)\n\n4. **Respectful of Legacy** (Principle 4)\n   - Backward compatible with all existing .mayu files\n   - Preserves Windows modal modifier semantics\n   - No breaking changes to configuration syntax\n\n**Success Metric Alignment**:\n- Performance: <1ms input latency (99th percentile) ✅\n- Quality: <5 P0 bugs ✅\n- Adoption: Critical blocker for Linux feature parity ✅\n\n## Requirements\n\n### Requirement 1: Modal Modifier Definition and Parsing\n\n**User Story**: As a power user, I want to define modal modifiers in my .mayu file using `mod modX = !!key` syntax, so that holding a key activates a modal layer without requiring dedicated modifier keys.\n\n#### Acceptance Criteria (EARS Format)\n\n**Event**: WHEN user defines `mod mod9 = !!A` in .mayu configuration\n**Action**: System SHALL parse the modal modifier definition and register key A as a trigger for the Modifier::Type_Mod9 state\n**Result**: Configuration loads successfully with modal modifier registered within 100ms, no parsing errors\n\n**Baseline → Target**:\n- **Current**: Modal modifier definitions are parsed but NOT connected to hold detection system (0% functional)\n- **Target**: 100% of modal modifier definitions activate hold detection with correct modifier type mapping\n\n**Edge Cases**:\n1. WHEN user defines `mod mod9 = !!A` AND `def subst *A = *Tab` THEN system SHALL prioritize hold detection (hold → mod9, tap → Tab substitution)\n2. WHEN user defines invalid modifier number `mod mod25 = !!A` (>mod19) THEN system SHALL reject with clear error message\n3. WHEN user defines `mod mod9 = !!A` AND `mod mod9 = !!B` THEN system SHALL accept multiple triggers for same modifier\n4. IF key is already a hardware modifier (`mod mod9 = !!LShift`) THEN system SHALL reject with warning (hardware modifiers cannot be modal triggers)\n\n### Requirement 2: Number Modifier Definition and Registration\n\n**User Story**: As an advanced user, I want to define number modifiers using `def numbermod *_1 = *LShift` syntax, so that number keys can function as hardware modifiers when held.\n\n#### Acceptance Criteria (EARS Format)\n\n**Event**: WHEN user defines `def numbermod *_1 = *LShift` in .mayu configuration\n**Action**: System SHALL register the mapping and enable hold/tap detection for the _1 key\n**Result**: Number key behaves as LShift when held ≥200ms, normal key when tapped <200ms, within 1ms processing latency\n\n**Baseline → Target**:\n- **Current**: `def numbermod` syntax is parsed but number modifiers are NOT registered with EventProcessor (0% functional)\n- **Target**: 100% of number modifier definitions are activated with correct hardware modifier mapping\n\n**Edge Cases**:\n1. WHEN user holds _1 for 250ms THEN system SHALL generate VK_LSHIFT down event AND suppress the _1 key event\n2. WHEN user taps _1 for 50ms THEN system SHALL apply normal substitution (`*_1 = *LShift` becomes actual LShift key output)\n3. WHEN user defines `def numbermod *A = *LCtrl` (non-number key) THEN system SHALL accept (number modifier naming is historical, any key allowed)\n4. IF user defines multiple hardware modifiers for same key THEN system SHALL reject with error\n\n### Requirement 3: Hold vs Tap Detection State Machine\n\n**User Story**: As a developer, I want a robust state machine that detects hold vs tap gestures with configurable thresholds, so that modal modifiers activate reliably without false positives.\n\n#### Acceptance Criteria (EARS Format)\n\n**Event**: WHEN user presses a key registered as modal modifier or number modifier\n**Action**: System SHALL start timer and track state transition: IDLE → PRESS → WAITING → (TAP_DETECTED or MODIFIER_ACTIVE)\n**Result**: Modifier state is correctly determined within threshold time (default 200ms), with <1ms jitter\n\n**Baseline → Target**:\n- **Current**: ModifierKeyHandler class exists with full state machine BUT is never instantiated or used (50% complete)\n- **Target**: 100% of modal/number modifier keys use state machine with accurate hold/tap detection\n\n**State Machine Specification**:\n```\nIDLE: No key pressed\n  ↓ (Key Down)\nPRESS: Key just pressed, timer started\n  ↓ (Wait)\nWAITING: Timer running (0-200ms elapsed)\n  ↓ (Key Up before threshold)\nTAP_DETECTED: Release before 200ms → Apply substitution\n  ↓ (Threshold reached while held)\nMODIFIER_ACTIVE: Hold ≥200ms → Activate modifier\n  ↓ (Key Up)\nIDLE: Modifier deactivated\n```\n\n**Performance Requirements**:\n1. WHEN threshold is set to 200ms THEN detection accuracy SHALL be ±5ms (±2.5% error)\n2. IF system is under heavy load (1000 events/sec) THEN hold detection SHALL NOT delay by >10ms\n3. WHEN modifier is activated THEN latency from threshold to modifier down event SHALL be <1ms\n\n**Edge Cases**:\n1. WHEN user performs rapid tap-tap-hold sequence THEN each event SHALL be independently evaluated\n2. IF timer is running AND system suspends (laptop sleep) THEN timer SHALL reset on wake\n3. WHEN two modal modifier keys are held simultaneously THEN both modifiers SHALL be active concurrently\n\n### Requirement 4: Modifier State Tracking\n\n**User Story**: As the engine, I need to track the active state of all 20 modal modifiers (mod0-mod19) during runtime, so that modifier key combinations can be correctly matched against keymap definitions.\n\n#### Acceptance Criteria (EARS Format)\n\n**Event**: WHEN modal modifier key is held ≥200ms OR released\n**Action**: System SHALL update modifier state bitmask and propagate state change to keymap lookup system\n**Result**: Active modifiers are reflected in real-time for key combination matching with <0.5ms latency\n\n**Baseline → Target**:\n- **Current**: Modifier state is tracked for standard modifiers (Shift, Ctrl, Alt, Win) but NOT for modal modifiers mod0-mod19 (0% coverage)\n- **Target**: 100% of modal modifiers are tracked with same reliability as hardware modifiers\n\n**State Storage**:\n```cpp\n// Required data structure (example)\nstruct ModifierState {\n    uint32_t standard_modifiers;  // Shift(1), Ctrl(2), Alt(4), Win(8)\n    uint32_t modal_modifiers;     // mod0(1), mod1(2), ..., mod19(1<<19)\n\n    bool isActive(Modifier::Type type) const;\n    void activate(Modifier::Type type);\n    void deactivate(Modifier::Type type);\n};\n```\n\n**Edge Cases**:\n1. WHEN all 20 modal modifiers are active simultaneously THEN system SHALL track all without overflow\n2. IF focus changes while modifier is held THEN modifier state SHALL be preserved or cleared based on configuration\n3. WHEN system receives modifier up event without preceding down THEN state SHALL be force-cleared (recovery)\n\n### Requirement 5: Modifier Combination Keymap Lookup\n\n**User Story**: As a user, I want to define key combinations using modal modifiers like `key *W-*A-*S-*C-m9-*X = *W-*A-*S-*C-Y`, so that modal layers can be combined with standard modifiers.\n\n#### Acceptance Criteria (EARS Format)\n\n**Event**: WHEN user presses X key WHILE mod9 is active AND standard modifiers Ctrl+Alt+Shift are pressed\n**Action**: System SHALL lookup keymap for the complete modifier combination `*W-*A-*S-*C-m9-*X`\n**Result**: Correct output Y is generated within <1ms, matching the defined keymap entry\n\n**Baseline → Target**:\n- **Current**: Keymap definitions with modal modifiers are parsed and stored BUT never matched during lookup (0% functional)\n- **Target**: 100% of modal modifier combinations are correctly matched with same performance as standard combinations\n\n**Keymap Matching Priority** (highest to lowest):\n1. Exact match with all modifiers: `*W-*A-*S-*C-m9-*X`\n2. Match without modal: `*W-*A-*S-*C-*X` (fallback)\n3. Match with fewer modifiers: `*C-m9-*X`\n4. Default (no modifiers): `*X`\n\n**Edge Cases**:\n1. WHEN keymap has `m9-*X = Y` AND `m8-m9-*X = Z` THEN with both mod8+mod9 active, system SHALL match the more specific entry (Z)\n2. IF user holds mod9 but no keymap entries use mod9 THEN normal keymaps SHALL still match (mod9 ignored if not referenced)\n3. WHEN user defines duplicate entries `m9-*X = A` and `m9-*X = B` THEN last definition SHALL win (config file order)\n\n### Requirement 6: Integration with Event Processing Pipeline\n\n**User Story**: As the engine, I need modal modifier detection to integrate seamlessly into the existing 3-layer event processing pipeline, so that modifier remapping works alongside key substitution.\n\n#### Acceptance Criteria (EARS Format)\n\n**Event**: WHEN evdev input event is received for a key registered as modal/number modifier\n**Action**: System SHALL process event through: Layer 1 (evdev→YAMY) → Layer 2 (hold detection + substitution + modifier state) → Layer 3 (YAMY→evdev)\n**Result**: Correct output is generated with total pipeline latency <1ms (P99)\n\n**Baseline → Target**:\n- **Current**: Event pipeline exists but skips modifier detection (direct substitution lookup)\n- **Target**: 100% of modal/number modifier events go through full detection pipeline\n\n**Pipeline Integration Points**:\n```\nINPUT: evdev code (e.g., KEY_A = 30)\n   ↓\n[Layer 1] evdev → YAMY scan code\n   Result: 0x001E (KEY_A in YAMY)\n   ↓\n[Layer 2] Apply modifier detection + substitution\n   CRITICAL ORDER:\n   1. Check if key is modal/number modifier → ModifierKeyHandler::processNumberKey()\n   2. If WAITING_FOR_THRESHOLD → suppress event (return 0)\n   3. If TAP_DETECTED → proceed to substitution lookup\n   4. If MODIFIER_ACTIVE → update modifier state + return hardware VK code\n   5. Else → normal substitution lookup\n   ↓\n[Layer 3] YAMY scan code → evdev code\n   Result: Output evdev code\n   ↓\nOUTPUT: uinput injection\n```\n\n**Performance Requirements**:\n1. WHEN processing modal modifier event THEN Layer 2 overhead SHALL be <10μs\n2. IF hold detection suppresses event THEN no output SHALL be generated (zero injection cost)\n3. WHEN tap is detected THEN substitution lookup SHALL execute in <10μs\n\n**Edge Cases**:\n1. WHEN modifier is activated mid-sequence THEN in-flight key events SHALL complete with previous modifier state\n2. IF event processing encounters error THEN system SHALL fall back to passthrough (no remapping)\n3. WHEN multiple keyboards are active (Linux multi-device) THEN each device SHALL have independent modifier state\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n**Single Responsibility Principle**:\n- `modifier_key_handler.cpp`: Hold/tap detection logic ONLY (no substitution, no injection)\n- `engine_event_processor.cpp`: Event pipeline orchestration ONLY (delegates to handlers)\n- `engine_modifier.cpp`: Modifier state tracking ONLY (no keymap lookup)\n- `engine_setting.cpp`: Configuration → runtime data transformation ONLY (no event processing)\n\n**Modular Design**:\n- ModifierKeyHandler is reusable (unit testable in isolation)\n- Event processor is configurable (can be instantiated without Engine)\n- Modifier state is observable (can be queried/logged independently)\n\n**Dependency Management**:\n```\nengine_event_processor.cpp\n  ↓ depends on\nmodifier_key_handler.h (interface only)\n  ↓ implements\nmodifier_key_handler.cpp (zero external deps)\n```\n\n**Clear Interfaces**:\n```cpp\n// ModifierKeyHandler interface (example)\nclass ModifierKeyHandler {\npublic:\n    struct NumberKeyResult {\n        ProcessingAction action;  // ACTIVATE, DEACTIVATE, APPLY_SUBSTITUTION, WAITING\n        uint16_t output_yama_code;\n    };\n\n    // Register a key as number modifier\n    void registerNumberModifier(uint16_t numberKey, uint16_t modifierKey);\n\n    // Process key event (returns action to take)\n    NumberKeyResult processNumberKey(uint16_t yama_code, EventType type);\n\n    // Query methods\n    bool isNumberModifier(uint16_t yama_code) const;\n    bool isWaitingForThreshold(uint16_t yama_code) const;\n};\n```\n\n### Performance\n\n**Latency Requirements** (P99):\n- **Hold detection overhead**: <10μs per event\n- **Modifier state update**: <5μs\n- **Keymap lookup with modifiers**: <15μs\n- **Total pipeline (evdev in → uinput out)**: <1ms\n\n**Throughput Requirements**:\n- Support 1000 events/sec sustained input without queue buildup\n- Handle burst of 100 events in 10ms window without dropped events\n\n**Resource Usage**:\n- **Memory**: Modifier state tracking <1KB, handler state <10KB\n- **CPU**: Idle <0.1%, under load <2% (single core)\n\n**Measurement Method**:\n```cpp\n// Built-in timing instrumentation (example)\nauto start = std::chrono::high_resolution_clock::now();\nresult = modifierHandler->processNumberKey(yama_code, type);\nauto end = std::chrono::high_resolution_clock::now();\nauto duration_us = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();\n// Log if >100μs\n```\n\n### Security\n\n**Input Validation**:\n1. WHEN config defines modal modifier THEN validate modifier index is 0-19\n2. WHEN registering number modifier THEN validate target is valid hardware modifier VK code\n3. IF invalid configuration is detected THEN reject with error, do not partially apply\n\n**Resource Limits**:\n1. Maximum 20 modal modifiers (mod0-mod19) - enforced by parser\n2. Maximum 100 number modifier definitions - enforced by parser\n3. Hold threshold range: 50ms-5000ms - validated at config load\n\n**Safety Guarantees**:\n1. WHEN modifier detection fails THEN fall back to passthrough (no key loss)\n2. IF timer system is broken THEN disable hold detection, log error, continue with tap-only mode\n3. WHEN state becomes inconsistent THEN reset all modifier state on next keymap change\n\n### Reliability\n\n**Correctness** (CRITICAL):\n- **Baseline**: 0% of modal modifier configurations work (feature non-functional)\n- **Target**: 100% of valid modal modifier definitions work correctly (zero false positives/negatives)\n\n**Error Handling**:\n1. WHEN hold detection encounters OS timer error THEN log error, disable hold detection for that key, continue processing\n2. IF modifier state overflow occurs (>32 modifiers) THEN log critical error, reset state, continue\n3. WHEN config reload happens while modifiers are active THEN preserve active state if config still valid, else reset\n\n**Recovery**:\n- WHEN system detects stuck modifier (held >60s) THEN auto-release with warning\n- IF event stream is interrupted (suspend/resume) THEN clear all modifier state on resume\n\n### Usability\n\n**Configuration Syntax Clarity**:\n```mayu\n# Clear, self-documenting syntax\nmod mod9 = !!A              # Hold A → activates mod9 layer\ndef numbermod *_1 = *LShift # Hold 1 → acts as LShift\n\n# Modifier combinations\nkey m9-*X = Y               # While mod9 active: X outputs Y\nkey *C-m9-*X = Z            # While Ctrl+mod9 active: X outputs Z\n```\n\n**Error Messages**:\n```\nError: Invalid modal modifier index 'mod25' (valid range: mod0-mod19)\n  Line 42: mod mod25 = !!A\n           ^^^^^^^^^\n\nError: Cannot use hardware modifier as modal trigger\n  Line 15: mod mod9 = !!LShift\n                      ^^^^^^^^\n  Suggestion: Use a regular key like !!A or !!Space\n```\n\n**Logging** (Strategic, not verbose):\n```\n[ENGINE:INIT] Registered 5 modal modifiers, 3 number modifiers\n[MODIFIER:ACTIVATE] mod9 activated (key: A, threshold: 200ms, hold time: 215ms)\n[MODIFIER:TAP] _1 tapped (hold time: 45ms) → applying substitution\n[KEYMAP:MATCH] Matched: *C-m9-*X → Z (4 modifiers active)\n```\n\n## Testing Requirements\n\n### Unit Testing\n\n**Coverage Target**: >95% line coverage for modifier detection code\n\n**Test Distribution**:\n- **ModifierKeyHandler** (25 tests):\n  - Hold detection state machine (10 tests)\n  - Multiple modifiers independently (5 tests)\n  - Edge cases (tap→hold→tap rapid sequence) (5 tests)\n  - Timer accuracy (threshold ±5ms) (5 tests)\n\n- **Modifier State Tracking** (15 tests):\n  - Activate/deactivate single modifier (5 tests)\n  - Multiple modifiers concurrent (5 tests)\n  - Bitmask overflow protection (3 tests)\n  - State query methods (2 tests)\n\n- **Keymap Lookup with Modifiers** (20 tests):\n  - Standard + modal modifier combinations (10 tests)\n  - Priority/fallback logic (5 tests)\n  - Edge cases (duplicate entries, undefined modifiers) (5 tests)\n\n**Example Test**:\n```cpp\nTEST(ModifierKeyHandlerTest, TapDetectedWhenReleasedBefore200ms) {\n    ModifierKeyHandler handler;\n    handler.registerNumberModifier(0x001E, 0x002A);  // A → LShift\n\n    // Simulate key down\n    auto result1 = handler.processNumberKey(0x001E, EventType::DOWN);\n    EXPECT_EQ(ProcessingAction::WAITING_FOR_THRESHOLD, result1.action);\n\n    // Wait 50ms (below threshold)\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n\n    // Simulate key up\n    auto result2 = handler.processNumberKey(0x001E, EventType::UP);\n    EXPECT_EQ(ProcessingAction::APPLY_SUBSTITUTION_ON_DOWN, result2.action);\n}\n```\n\n### Integration Testing\n\n**Test Harness**:\n- Mock evdev device using `/dev/uinput` (Linux)\n- Inject test events, capture output\n- Validate timing using `clock_gettime(CLOCK_MONOTONIC)`\n\n**Critical Scenarios** (30 tests):\n1. **Hold Detection** (10 tests):\n   - Single key hold →activate →release →deactivate\n   - Tap vs hold threshold accuracy\n   - Multiple keys in rapid succession\n\n2. **Modifier Combinations** (10 tests):\n   - Mod9+X outputs Y (simple modal)\n   - Ctrl+Mod9+X outputs Z (standard+modal)\n   - Mod8+Mod9+X outputs W (multiple modal)\n\n3. **Real-World Workflows** (10 tests):\n   - Emacs-style C-x prefix (Mod9 = X, Mod9+F = find-file)\n   - Vim-style modal editing (Mod9 = Esc, Mod9+hjkl = arrow keys)\n   - Number row as modifiers (1-0 held = F1-F10)\n\n**Integration Test Example**:\n```cpp\nTEST(IntegrationTest, ModalModifierActivatesOnHold) {\n    // Load config: mod mod9 = !!A, key m9-*X = Y\n    Engine engine;\n    engine.loadConfig(\"test_modal.mayu\");\n\n    // Inject: A down, wait 250ms, X down, X up, A up\n    MockInputDevice device;\n    device.sendKeyDown(KEY_A);\n    std::this_thread::sleep_for(std::chrono::milliseconds(250));\n    device.sendKeyDown(KEY_X);\n    device.sendKeyUp(KEY_X);\n    device.sendKeyUp(KEY_A);\n\n    // Verify output\n    auto events = device.readOutputEvents();\n    ASSERT_EQ(1, events.size());\n    EXPECT_EQ(KEY_Y, events[0].code);  // X remapped to Y via mod9\n}\n```\n\n### End-to-End Testing\n\n**User Acceptance Tests** (15 scenarios):\n\n1. **UAT-1: Basic Modal Modifier**\n   - Config: `mod mod9 = !!A`, `key m9-*X = Y`\n   - Steps: Hold A for 300ms, press X, release X, release A\n   - Expected: Y key output\n\n2. **UAT-2: Tap vs Hold**\n   - Config: `mod mod9 = !!A`, `def subst *A = *Tab`\n   - Steps: Tap A (50ms), then hold A (300ms)\n   - Expected: First outputs Tab, second activates mod9 (no output)\n\n3. **UAT-3: Number Modifier**\n   - Config: `def numbermod *_1 = *LShift`, `key *S-A = *S-A` (no remap)\n   - Steps: Hold 1 for 300ms, press A, release A, release 1\n   - Expected: Capital A (Shift+A output)\n\n4. **UAT-4: Multi-Modal Combination**\n   - Config: `mod mod9 = !!A`, `mod mod8 = !!S`, `key m8-m9-*X = Z`\n   - Steps: Hold A, hold S, press X, release all\n   - Expected: Z output\n\n5. **UAT-5: Cross-Platform Config**\n   - Config: Load same .mayu file on Windows and Linux\n   - Steps: Perform UAT-1 through UAT-4 on both platforms\n   - Expected: Identical behavior on both systems\n\n**Performance Benchmarks** (Automated):\n```bash\n# Measure latency P50, P99, P99.9\n./yamy --benchmark --config test_modal.mayu --iterations 10000\n```\n\n**Expected Results**:\n- P50 latency: <500μs\n- P99 latency: <1ms\n- P99.9 latency: <5ms\n\n## Acceptance Criteria Summary (EARS Format)\n\n### AC-1: Configuration Parsing\n**Event**: WHEN user loads .mayu file with modal modifier definitions\n**Action**: System parses and validates all `mod modX = !!key` and `def numbermod` entries\n**Result**: Configuration loads successfully with all modifiers registered within 100ms, zero parsing errors for valid syntax\n\n### AC-2: Hold Detection Accuracy\n**Event**: WHEN user holds a modal/number modifier key\n**Action**: System measures hold time and activates modifier if ≥200ms threshold\n**Result**: Detection accuracy within ±5ms (±2.5%), no false activations/deactivations\n\n### AC-3: Tap Fallback\n**Event**: WHEN user taps a modal/number modifier key (<200ms)\n**Action**: System applies normal substitution from `def subst` mapping\n**Result**: Substitution executes within <1ms, correct output generated\n\n### AC-4: Modifier State Synchronization\n**Event**: WHEN modal modifier activates/deactivates\n**Action**: System updates modifier state bitmask and propagates to keymap lookup\n**Result**: Active modifiers reflected in real-time with <0.5ms latency\n\n### AC-5: Keymap Matching\n**Event**: WHEN user presses key while modal modifiers are active\n**Action**: System performs keymap lookup including modal modifier prefix (e.g., `m9-`)\n**Result**: Correct keymap entry matched with priority ordering, output generated within <1ms\n\n### AC-6: Cross-Platform Parity\n**Event**: WHEN same .mayu configuration is loaded on Windows and Linux\n**Action**: Both systems apply identical modal modifier behavior\n**Result**: 100% functional parity, zero platform-specific quirks or bugs\n\n### AC-7: Performance Under Load\n**Event**: WHEN system processes 1000 events/sec with modal modifiers active\n**Action**: System maintains hold detection, modifier tracking, and keymap lookup\n**Result**: P99 latency remains <1ms, zero dropped events, CPU usage <2%\n\n## Code Quality Gates\n\n**Max Lines Per File**: 500\n- `modifier_key_handler.cpp`: Target <300 lines\n- `engine_event_processor.cpp`: Target <400 lines (including existing code)\n- `engine_modifier.cpp`: Target <200 lines\n\n**Max Lines Per Function**: 50\n- `processNumberKey()`: <40 lines\n- `updateModifierState()`: <30 lines\n- `lookupKeymapWithModifiers()`: <50 lines\n\n**Test Coverage**:\n- Unit tests: >95% line coverage for new code\n- Integration tests: 100% of AC scenarios covered\n- E2E tests: 100% of UAT scenarios automated\n\n**Performance**:\n- Hold detection: <10μs per event (measured via benchmark)\n- Modifier state update: <5μs\n- Total pipeline: <1ms P99\n\n**No Special Cases**:\n- All modal modifiers use same code path (mod0 through mod19)\n- Hardware modifiers and modal modifiers share state tracking interface\n- Tap and hold use unified event processing (no separate branches)\n\n## Debugging/Instrumentation\n\n**Strategic Logging Points**:\n1. **Configuration Loading**: Log each modal modifier registration\n   ```\n   [MODIFIER:REGISTER] mod9 registered with trigger key A (YAMY: 0x001E)\n   ```\n\n2. **Hold Detection State Transitions**: Log activation/deactivation\n   ```\n   [MODIFIER:HOLD] Key A held for 215ms → mod9 ACTIVATED\n   [MODIFIER:TAP] Key A released at 45ms → TAP detected, applying substitution\n   ```\n\n3. **Keymap Matching**: Log modifier combination matching\n   ```\n   [KEYMAP:LOOKUP] Active modifiers: C(1), mod9(1), looking up key X\n   [KEYMAP:MATCH] Matched: *C-m9-*X → Y (2 modifiers)\n   ```\n\n4. **Performance Anomalies**: Log only if threshold exceeded\n   ```\n   [PERF:WARN] Hold detection took 150μs (threshold: 100μs)\n   ```\n\n**Test Utilities**:\n```cpp\n// MockTimer for unit testing hold detection\nclass MockTimer {\n    void advance(std::chrono::milliseconds ms);\n    std::chrono::milliseconds elapsed();\n};\n\n// ModifierStateObserver for testing\nclass ModifierStateObserver {\n    std::vector<ModifierStateChange> getHistory();\n    bool wasActivated(Modifier::Type type);\n};\n```\n\n**Benchmarking**:\n```bash\n# Built-in benchmark mode\n./yamy --benchmark --iterations 10000\n# Outputs: P50, P95, P99, P99.9 latencies + CSV for graphing\n```\n\n## Success Metrics\n\n### Functional Correctness\n**Baseline**: 0% of modal modifier configurations functional\n**Target**: 100% of valid configurations work correctly\n\n**Measurement**:\n- Run UAT-1 through UAT-5 (all must pass)\n- Integration test suite (100% pass rate)\n- Manual testing checklist (25/25 items pass)\n\n### Performance\n**Target**: <1ms P99 latency (entire pipeline)\n\n**Measurement**:\n```bash\n./yamy --benchmark --config production.mayu --iterations 100000\n```\n**Expected output**:\n```\nModal Modifier Performance Benchmark\n=====================================\nIterations: 100,000\nP50 latency: 0.42ms\nP95 latency: 0.78ms\nP99 latency: 0.95ms\nP99.9 latency: 2.1ms\nPASS: P99 < 1ms target ✓\n```\n\n### Cross-Platform Parity\n**Target**: 100% identical behavior on Windows and Linux\n\n**Measurement**:\n- Same .mayu file loaded on both platforms\n- Run identical test suite on both\n- Compare outputs byte-for-byte\n- Zero platform-specific failures\n\n### Code Quality\n**Target**: All quality gates met\n\n**Measurement**:\n```bash\n# Lines per file\nfind src/ -name \"*.cpp\" | xargs wc -l | awk '$1 > 500 {print \"FAIL: \" $2 \" has \" $1 \" lines\"}'\n\n# Test coverage\n./run_tests --coverage\n# Expected: >95% for new code\n\n# Performance benchmark\n./yamy --benchmark\n# Expected: P99 < 1ms\n```\n\n---\n\n**Document Version**: 1.0\n**Created**: 2025-12-14\n**Reviewed By**: (Pending approval)\n",
  "fileStats": {
    "size": 26265,
    "lines": 663,
    "lastModified": "2025-12-14T04:26:29.320Z"
  },
  "comments": []
}