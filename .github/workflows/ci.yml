name: CI

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]

jobs:
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Install clang tools
      run: |
        sudo apt-get update
        sudo apt-get install -y clang-format clang-tidy python3-pip

    - name: Install lizard for code metrics
      run: |
        pip3 install lizard

    - name: Check code formatting
      run: |
        echo "## Code Formatting Check" >> $GITHUB_STEP_SUMMARY
        # Find all C++ source files in src/ (excluding third-party/external code)
        FILES=$(find src -name '*.cpp' -o -name '*.h' | grep -v '/third_party/' | grep -v '/external/')

        # Check formatting and report differences
        UNFORMATTED=""
        for FILE in $FILES; do
          if ! clang-format --dry-run --Werror "$FILE" 2>/dev/null; then
            UNFORMATTED="$UNFORMATTED $FILE"
          fi
        done

        if [ -n "$UNFORMATTED" ]; then
          echo "The following files need formatting:" >> $GITHUB_STEP_SUMMARY
          for FILE in $UNFORMATTED; do
            echo "- $FILE" >> $GITHUB_STEP_SUMMARY
          done
          echo ""
          echo "Run 'clang-format -i <file>' or './scripts/linux/format-code.sh' to fix."
          # Report but don't fail initially (set exit 1 to enforce)
          echo "::warning::Code formatting issues found in $(echo $UNFORMATTED | wc -w) files"
        else
          echo "All files are properly formatted." >> $GITHUB_STEP_SUMMARY
        fi

    - name: Run clang-tidy on platform code
      run: |
        echo "## Clang-Tidy Analysis" >> $GITHUB_STEP_SUMMARY
        # Focus on platform/linux code for now (new code should be clean)
        PLATFORM_FILES=$(find src/platform/linux -name '*.cpp' -o -name '*.h' 2>/dev/null || true)

        if [ -n "$PLATFORM_FILES" ]; then
          echo "Analyzing platform/linux code..." >> $GITHUB_STEP_SUMMARY

          # Run clang-tidy and capture output
          TIDY_OUTPUT=""
          for FILE in $PLATFORM_FILES; do
            OUTPUT=$(clang-tidy "$FILE" -- -std=c++17 -I src 2>&1 || true)
            if echo "$OUTPUT" | grep -q "warning:"; then
              TIDY_OUTPUT="$TIDY_OUTPUT\n$OUTPUT"
            fi
          done

          if [ -n "$TIDY_OUTPUT" ]; then
            echo "Clang-tidy found some issues (informational):" >> $GITHUB_STEP_SUMMARY
            echo "::warning::Clang-tidy found potential issues in platform code"
          else
            echo "No issues found in platform/linux code." >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "No platform/linux files to analyze." >> $GITHUB_STEP_SUMMARY
        fi

    - name: Check code metrics
      run: |
        echo "## Code Metrics Check" >> $GITHUB_STEP_SUMMARY

        # Run lizard with configured limits: 500 lines/file, 50 lines/function, CCN ≤15
        # Exclude third-party and build directories
        LIZARD_OUTPUT=$(lizard src/ \
          --length 50 \
          --CCN 15 \
          --arguments 10 \
          --exclude "*/third_party/*" \
          --exclude "*/external/*" \
          --exclude "*/build/*" \
          --warnings_only 2>&1) || true

        # Check for violations
        if echo "$LIZARD_OUTPUT" | grep -q "NLOC.*CCN.*token"; then
          # Parse violations
          VIOLATIONS=$(echo "$LIZARD_OUTPUT" | grep -E "^  " | wc -l)

          if [ "$VIOLATIONS" -gt 0 ]; then
            echo "❌ **Code metrics violations found:** $VIOLATIONS" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Limits:** Max 50 lines/function, Max CCN 15" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details><summary>Violations</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$LIZARD_OUTPUT" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo ""
            echo "ERROR: Code metrics violations detected!"
            echo "$LIZARD_OUTPUT"
            echo ""
            echo "Functions exceeding limits must be refactored."
            echo "See docs/CODE_METRICS.md for guidelines."
            exit 1
          fi
        fi

        # Also check for files exceeding 500 lines (excluding comments/blanks)
        FILES_OVER_LIMIT=$(lizard src/ \
          --exclude "*/third_party/*" \
          --exclude "*/external/*" \
          --exclude "*/build/*" 2>&1 | \
          awk '/^[^[:space:]]/ {file=$1; nloc=$2} nloc > 500 {print file " (" nloc " lines)"}')

        if [ -n "$FILES_OVER_LIMIT" ]; then
          echo "❌ **Files exceeding 500 NLOC:**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$FILES_OVER_LIMIT" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo ""
          echo "ERROR: Files exceeding 500 NLOC limit!"
          echo "$FILES_OVER_LIMIT"
          echo ""
          echo "Large files must be split. See docs/CODE_METRICS.md for guidelines."
          exit 1
        fi

        echo "✅ **All code metrics checks passed**" >> $GITHUB_STEP_SUMMARY
        echo "- Functions ≤ 50 lines" >> $GITHUB_STEP_SUMMARY
        echo "- Cyclomatic complexity ≤ 15" >> $GITHUB_STEP_SUMMARY
        echo "- Files ≤ 500 NLOC" >> $GITHUB_STEP_SUMMARY

  build-linux-stub:
    name: Linux Stub Build & Verification
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake g++ make \
          libx11-dev libxrandr-dev qtbase5-dev \
          mold lld

    - name: Configure CMake
      run: cmake -B build -DBUILD_LINUX_STUB=ON -DBUILD_LINUX_TESTING=OFF

    - name: Build
      run: cmake --build build -j2

    - name: Run Static Analysis
      run: ./scripts/linux/ci_static_analysis.sh

    - name: Check for Win32 type leakage in core
      run: |
        # Count Win32 type usages (excluding template parameters and platform constants)
        # Baseline: 59 usages (includes MSG_* constants in message_constants.h). Goal: reduce over time.
        COUNT=$(grep -r "HWND\|DWORD\|MSG\|WPARAM\|LPARAM" src/core --include="*.cpp" --include="*.h" | grep -v "template.*WPARAM_T\|template.*LPARAM_T" | grep -v "message_constants.h" | wc -l)
        echo "Win32 type leakage count: $COUNT (excluding message_constants.h)"
        if [ "$COUNT" -gt 56 ]; then
          echo "ERROR: Win32 types leaked into src/core (Count: $COUNT, Limit: 56)"
          exit 1
        fi

    - name: Check legacy string usage
      run: |
        bash scripts/linux/track_legacy_strings.sh > metrics.txt
        LEGACY_COUNT=$(grep "TOTAL legacy string usages:" metrics.txt | awk '{print $5}')
        echo "Legacy string usages: $LEGACY_COUNT"
        # Fail if count increases (baseline: 971)
        if [ "$LEGACY_COUNT" -gt 971 ]; then
          echo "ERROR: Legacy string usage increased!"
          exit 1
        fi

    - name: Check #ifdef usage
      run: |
        bash scripts/linux/check_ifdef_usage.sh > /dev/null 2>&1
        IFDEF_COUNT=$(cat .github/metrics/ifdef_count.txt)
        BASELINE=28
        echo "#ifdef _WIN32 total count: $IFDEF_COUNT (baseline: $BASELINE)"
        # Fail if count increases - we want to reduce over time, not add more
        if [ "$IFDEF_COUNT" -gt "$BASELINE" ]; then
          echo "ERROR: #ifdef count increased from $BASELINE to $IFDEF_COUNT"
          echo "Goal: Reduce platform conditionals, not add more"
          echo "See docs/IFDEF_REDUCTION_STRATEGY.md for refactoring guidance"
          exit 1
        fi
        echo "✓ #ifdef count acceptable (reducing over time)"

  regression-tests:
    name: Linux Regression Tests
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake g++ make \
          libx11-dev libxrandr-dev libudev-dev \
          qtbase5-dev \
          xvfb mold lld

    - name: Configure CMake
      run: cmake -B build -DBUILD_LINUX_STUB=ON -DBUILD_REGRESSION_TESTS=ON

    - name: Build regression tests
      run: cmake --build build --target yamy_regression_test --parallel

    - name: Run regression tests with Xvfb
      run: |
        xvfb-run -a ./build/bin/yamy_regression_test --gtest_output=xml:test-results.xml
      env:
        DISPLAY: :99

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: test-results.xml

    - name: Report test summary
      if: always()
      run: |
        if [ -f test-results.xml ]; then
          echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
          # Extract test counts from gtest XML output
          TESTS=$(grep -o 'tests="[0-9]*"' test-results.xml | head -1 | grep -o '[0-9]*')
          FAILURES=$(grep -o 'failures="[0-9]*"' test-results.xml | head -1 | grep -o '[0-9]*')
          ERRORS=$(grep -o 'errors="[0-9]*"' test-results.xml | head -1 | grep -o '[0-9]*')
          echo "- Total tests: ${TESTS:-0}" >> $GITHUB_STEP_SUMMARY
          echo "- Failures: ${FAILURES:-0}" >> $GITHUB_STEP_SUMMARY
          echo "- Errors: ${ERRORS:-0}" >> $GITHUB_STEP_SUMMARY
        fi

  property-tests:
    name: Property-Based Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
    - uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake g++ make \
          libx11-dev libxrandr-dev libudev-dev \
          qtbase5-dev \
          xvfb mold lld python3-pip
        pip3 install conan

    - name: Setup Conan
      run: |
        conan profile detect --force
        conan install . --output-folder=build --build=missing -s build_type=Debug

    - name: Configure CMake
      run: cmake -B build -DBUILD_LINUX_STUB=ON -DBUILD_LINUX_TESTING=ON -DCMAKE_TOOLCHAIN_FILE=build/conan_toolchain.cmake -DCMAKE_BUILD_TYPE=Debug

    - name: Build property tests
      run: |
        cmake --build build --target yamy_property_keymap_test --parallel
        cmake --build build --target yamy_property_modifier_test --parallel
        cmake --build build --target yamy_property_layer_test --parallel

    - name: Run property tests (1000 iterations)
      run: |
        echo "## Property-Based Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        # Run keymap property tests
        echo "Running keymap invariant property tests..."
        if RC_PARAMS="max_success=1000" ./build/bin/yamy_property_keymap_test; then
          echo "✓ Keymap property tests passed (1000 iterations)" >> $GITHUB_STEP_SUMMARY
        else
          echo "✗ Keymap property tests FAILED" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Run modifier state property tests
        echo "Running modifier state property tests..."
        if RC_PARAMS="max_success=1000" ./build/bin/yamy_property_modifier_test; then
          echo "✓ Modifier state property tests passed (1000 iterations)" >> $GITHUB_STEP_SUMMARY
        else
          echo "✗ Modifier state property tests FAILED" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        # Run layer switching property tests
        echo "Running layer switching property tests..."
        if RC_PARAMS="max_success=1000" ./build/bin/yamy_property_layer_test; then
          echo "✓ Layer switching property tests passed (1000 iterations)" >> $GITHUB_STEP_SUMMARY
        else
          echo "✗ Layer switching property tests FAILED" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

        echo "" >> $GITHUB_STEP_SUMMARY
        echo "All property tests completed successfully with 1000 iterations per property." >> $GITHUB_STEP_SUMMARY
      timeout-minutes: 10
      env:
        DISPLAY: :99

  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    timeout-minutes: 20
    # Only run on PRs and main branch pushes (not every commit to feature branches)
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake g++ make \
          libx11-dev libxrandr-dev libudev-dev \
          qtbase5-dev \
          xvfb lcov bc mold lld

    - name: Configure CMake with coverage
      run: |
        cmake -B build \
          -DBUILD_LINUX_STUB=OFF \
          -DBUILD_LINUX_TESTING=OFF \
          -DBUILD_REGRESSION_TESTS=ON \
          -DBUILD_QT_GUI=OFF \
          -DENABLE_COVERAGE=ON \
          -DCMAKE_BUILD_TYPE=Debug

    - name: Build regression tests only
      run: cmake --build build --target yamy_regression_test -j2

    - name: Run tests with coverage (Xvfb)
      run: |
        xvfb-run -a cmake --build build --target coverage
      env:
        DISPLAY: :99

    - name: Extract coverage percentage
      id: coverage
      run: |
        COVERAGE=$(lcov --summary build/coverage/coverage.info 2>&1 | grep 'lines' | grep -oP '[0-9.]+(?=%)' | head -1)
        echo "coverage=${COVERAGE}" >> $GITHUB_OUTPUT
        echo "## Coverage Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Line Coverage: ${COVERAGE}%**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Full HTML report available in artifacts." >> $GITHUB_STEP_SUMMARY

    - name: Upload coverage report
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: build/coverage/
        retention-days: 30

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: build/coverage/coverage.info
        flags: unittests
        name: yamy-coverage
        fail_ci_if_error: false
        verbose: true
      continue-on-error: true  # Don't fail if Codecov is not configured

    - name: Check coverage threshold
      run: |
        COVERAGE=${{ steps.coverage.outputs.coverage }}
        THRESHOLD=80
        echo "Coverage: ${COVERAGE}%, Threshold: ${THRESHOLD}%"
        if [ $(echo "${COVERAGE} < ${THRESHOLD}" | bc -l) -eq 1 ]; then
          echo "::warning::Coverage ${COVERAGE}% is below threshold ${THRESHOLD}%"
          # Don't fail the build for now, just warn
          # exit 1
        else
          echo "Coverage meets threshold!"
        fi

  build-windows-mingw:
    name: Windows MinGW Build
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Install MinGW
      run: |
        sudo apt-get update
        sudo apt-get install -y mingw-w64 cmake

    - name: Configure CMake
      run: cmake -B build_mingw -DCMAKE_TOOLCHAIN_FILE=scripts/mingw_toolchain.cmake

    - name: Build
      run: cmake --build build_mingw -j2
