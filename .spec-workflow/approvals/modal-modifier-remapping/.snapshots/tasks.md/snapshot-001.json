{
  "id": "snapshot_1765686808548_xdu7kovaz",
  "approvalId": "approval_1765686808541_35x3vlnsm",
  "approvalTitle": "Tasks: Modal Modifier Remapping (15 tasks)",
  "version": 1,
  "timestamp": "2025-12-14T04:33:28.548Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document: Modal Modifier Remapping\n\n## Overview\n\nThis document breaks down the modal modifier remapping feature into atomic, testable tasks. Each task is designed to be completed in 1-3 files with clear success criteria.\n\n**Implementation Strategy**: Bottom-up approach - build foundational components first (state tracking, handler), then integrate into engine, then add configuration layer connections.\n\n**Total Estimated Tasks**: 12 core tasks + 3 testing tasks = 15 tasks\n\n---\n\n## Phase 1: Foundation - Data Structures and State Tracking (Tasks 1-3)\n\n- [ ] 1. Enhance ModifierState struct to support modal modifiers\n  - **Files**:\n    - `src/core/engine/engine_modifier.cpp` (modify existing struct)\n    - `src/core/engine/engine_modifier.h` (add modal field)\n  - **Description**: Add uint32_t modal field to ModifierState struct and implement activate/deactivate methods for mod0-mod19\n  - **Acceptance Criteria**:\n    - ModifierState has modal field (32-bit bitmask for mod0-mod19)\n    - activate(Modifier::Type_ModX) sets correct bit\n    - deactivate(Modifier::Type_ModX) clears correct bit\n    - isActive(Modifier::Type_ModX) returns correct state\n    - All tests pass with >95% coverage\n  - **_Leverage**: Existing ModifierState structure in engine_modifier.cpp_\n  - **_Requirements**: Requirement 4 (Modifier State Tracking)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: C++ Systems Engineer specializing in low-level state management and bit manipulation\n\n    Task: Enhance the ModifierState struct in src/core/engine/engine_modifier.cpp to support 20 modal modifiers (mod0-mod19) using a uint32_t bitmask field. Implement activate/deactivate methods following requirement 4.\n\n    Context:\n    - Currently ModifierState only tracks standard modifiers (Shift, Ctrl, Alt, Win)\n    - Need to add modal modifier tracking without breaking existing functionality\n    - Modal modifiers are Modifier::Type_Mod0 through Modifier::Type_Mod19 (enum values 16-35)\n\n    Implementation:\n    1. Add uint32_t modal field to ModifierState struct\n    2. Implement activate(Modifier::Type type) method:\n       - If type is Type_Mod0..Mod19: set bit (type - Type_Mod0) in modal field\n       - If type is standard modifier: update existing standard field\n    3. Implement deactivate(Modifier::Type type) method (reverse of activate)\n    4. Implement bool isActive(Modifier::Type type) const method\n    5. Add getActiveBitmask() method that returns modal field\n    6. Add clear() method to reset all modifiers\n\n    Restrictions:\n    - DO NOT modify existing standard modifier behavior\n    - DO NOT change method signatures of existing functions\n    - Maintain backward compatibility with existing code\n    - Use bitwise operations (no loops for bit manipulation)\n\n    Leverage:\n    - Existing Modifier::Type enum in src/core/input/keyboard.h (Type_Mod0 = 16, Type_Mod19 = 35)\n    - Existing ModifierState struct in src/core/engine/engine_modifier.cpp\n\n    Success Criteria:\n    - ModifierState struct compiles without errors\n    - All new methods are implemented and tested\n    - Backward compatibility maintained (existing code still works)\n    - Unit tests demonstrate correct bitmask manipulation\n\n    Instructions:\n    1. Mark task 1 as in-progress in .spec-workflow/specs/modal-modifier-remapping/tasks.md (change [ ] to [-])\n    2. Implement the changes to ModifierState\n    3. Write unit tests in tests/test_modifier_state.cpp (create file if needed)\n    4. Run tests and verify all pass\n    5. Log implementation using log-implementation tool with detailed artifacts\n    6. Mark task 1 as complete in tasks.md (change [-] to [x])\n    ```\n\n- [ ] 2. Create ModifierState unit test suite\n  - **Files**:\n    - `tests/test_modifier_state.cpp` (create new file)\n  - **Description**: Comprehensive unit tests for ModifierState modal modifier functionality\n  - **Acceptance Criteria**:\n    - 15 unit tests covering activate/deactivate/isActive/clear methods\n    - All edge cases tested (activate twice, deactivate inactive, all 20 modifiers concurrently)\n    - 100% coverage of new ModifierState methods\n    - All tests pass in <100ms\n  - **_Leverage**: tests/test_main.cpp for Google Test setup_\n  - **_Requirements**: Requirement 4 (Modifier State Tracking)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: QA Engineer specializing in C++ unit testing and Google Test framework\n\n    Task: Create comprehensive unit tests for ModifierState modal modifier functionality in tests/test_modifier_state.cpp, covering all methods and edge cases following requirement 4.\n\n    Context:\n    - ModifierState was just enhanced with modal modifier support (Task 1)\n    - Need to verify bitmask manipulation is correct\n    - Must test edge cases like concurrent modifiers and invalid states\n\n    Implementation:\n    1. Create tests/test_modifier_state.cpp with Google Test framework\n    2. Write 15 unit tests:\n       - ActivateSingleModifier (mod0, mod9, mod19)\n       - DeactivateSingleModifier\n       - ActivateMultipleConcurrent (mod0+mod9+mod19)\n       - IsActiveReturnsCorrect\n       - ActivateTwice (should be idempotent)\n       - DeactivateInactive (should be safe)\n       - All20ModifiersConcurrent (stress test)\n       - GetActiveBitmaskCorrect\n       - ClearResetsAll\n       - StandardAndModalCombined (Ctrl + mod9)\n       - ActivateInvalidType (Type_Mod20, should gracefully handle)\n       - BitmaskOverflow (all 32 bits set, should handle)\n       - ThreadSafety (if applicable)\n       - StateQuery methods\n       - Serialization (if needed for debugging)\n\n    Restrictions:\n    - Use Google Test macros (TEST, EXPECT_EQ, ASSERT_TRUE, etc.)\n    - DO NOT test standard modifier behavior (already tested)\n    - Focus ONLY on modal modifier functionality\n    - Each test must be independent (no shared state)\n\n    Leverage:\n    - tests/test_main.cpp for test runner setup\n    - Existing test patterns in tests/ directory\n\n    Success Criteria:\n    - All 15 tests compile and run\n    - 100% coverage of ModifierState modal methods\n    - Tests execute in <100ms total\n    - No test failures, no memory leaks (valgrind clean)\n\n    Instructions:\n    1. Mark task 2 as in-progress in tasks.md\n    2. Create tests/test_modifier_state.cpp\n    3. Write all 15 unit tests\n    4. Run: ./build/yamy_test --gtest_filter=\"ModifierStateTest.*\"\n    5. Verify all pass and coverage is 100%\n    6. Log implementation with artifacts (test file created, test count)\n    7. Mark task 2 as complete\n    ```\n\n- [ ] 3. Verify ModifierKeyHandler exists and add getter for testing\n  - **Files**:\n    - `src/core/engine/modifier_key_handler.h` (add getters for testing)\n    - `src/core/engine/modifier_key_handler.cpp` (implement getters)\n  - **Description**: Verify ModifierKeyHandler implementation is complete and add query methods for testing\n  - **Acceptance Criteria**:\n    - ModifierKeyHandler compiles and links successfully\n    - Added getKeyStates() method for testing (returns const reference)\n    - Added isWaitingForThreshold() method\n    - Existing tests pass (tests/test_number_modifiers.cpp)\n  - **_Leverage**: Existing ModifierKeyHandler implementation_\n  - **_Requirements**: Requirement 3 (Hold vs Tap Detection State Machine)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: C++ Developer with expertise in API design and testability\n\n    Task: Verify ModifierKeyHandler implementation is complete and add query methods for testing in src/core/engine/modifier_key_handler.h/cpp.\n\n    Context:\n    - ModifierKeyHandler already exists and is fully implemented\n    - Need to add getter methods to enable testing and integration\n    - Must NOT change existing functionality\n\n    Implementation:\n    1. Read src/core/engine/modifier_key_handler.h and verify it has:\n       - registerNumberModifier() method\n       - processNumberKey() method\n       - isNumberModifier() method\n    2. Add new query methods:\n       - const std::unordered_map<uint16_t, KeyState>& getKeyStates() const; // For testing\n       - bool isWaitingForThreshold(uint16_t yama_code) const;\n    3. Implement getters in modifier_key_handler.cpp\n    4. Verify existing tests still pass: tests/test_number_modifiers.cpp\n\n    Restrictions:\n    - DO NOT modify existing methods (registerNumberModifier, processNumberKey)\n    - Only ADD new query methods\n    - Getters must be const (read-only)\n    - DO NOT change state machine logic\n\n    Leverage:\n    - Existing ModifierKeyHandler at src/core/engine/modifier_key_handler.cpp\n    - Existing tests at tests/test_number_modifiers.cpp\n\n    Success Criteria:\n    - ModifierKeyHandler compiles without errors\n    - New getter methods implemented and return correct data\n    - Existing tests still pass (./yamy_test --gtest_filter=\"NumberModifierTest.*\")\n    - No regressions in functionality\n\n    Instructions:\n    1. Mark task 3 as in-progress\n    2. Add getter methods to modifier_key_handler.h\n    3. Implement getters in modifier_key_handler.cpp\n    4. Run existing tests to verify no regressions\n    5. Log implementation with artifacts (methods added)\n    6. Mark task 3 as complete\n    ```\n\n## Phase 2: Event Processing Integration (Tasks 4-7)\n\n- [ ] 4. Extend EventProcessor to accept ModifierKeyHandler\n  - **Files**:\n    - `src/core/engine/engine_event_processor.h` (add handler member + setter)\n    - `src/core/engine/engine_event_processor.cpp` (implement setter)\n  - **Description**: Add ModifierKeyHandler member to EventProcessor and implement setter method\n  - **Acceptance Criteria**:\n    - EventProcessor has unique_ptr<ModifierKeyHandler> m_modifierHandler member\n    - setModifierHandler(unique_ptr<ModifierKeyHandler> handler) method implemented\n    - Handler is stored and can be accessed\n    - Compiles without errors\n  - **_Leverage**: Existing EventProcessor class structure_\n  - **_Requirements**: Requirement 6 (Integration with Event Processing Pipeline)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: C++ Software Engineer specializing in dependency injection and RAII patterns\n\n    Task: Extend EventProcessor to accept and store ModifierKeyHandler in src/core/engine/engine_event_processor.h/cpp following requirement 6.\n\n    Context:\n    - EventProcessor currently has no modifier detection capability\n    - Need to add ModifierKeyHandler as an injectable dependency\n    - Use unique_ptr for ownership transfer\n\n    Implementation:\n    1. Add to engine_event_processor.h:\n       - #include <memory> (if not already)\n       - Forward declaration: class ModifierKeyHandler;\n       - Private member: std::unique_ptr<ModifierKeyHandler> m_modifierHandler;\n       - Public method: void setModifierHandler(std::unique_ptr<ModifierKeyHandler> handler);\n    2. Implement in engine_event_processor.cpp:\n       - setModifierHandler() should use std::move() to transfer ownership\n    3. Add null check helper method for safety:\n       - bool hasModifierHandler() const { return m_modifierHandler != nullptr; }\n\n    Restrictions:\n    - DO NOT instantiate ModifierKeyHandler in EventProcessor (dependency injection only)\n    - Use unique_ptr, NOT raw pointers\n    - DO NOT modify existing EventProcessor methods yet (Layer 2 integration is next task)\n\n    Leverage:\n    - Existing EventProcessor at src/core/engine/engine_event_processor.cpp\n    - Modern C++ smart pointers (unique_ptr, move semantics)\n\n    Success Criteria:\n    - EventProcessor compiles with new member\n    - setModifierHandler() accepts and stores handler\n    - hasModifierHandler() returns correct state\n    - No memory leaks (handler is owned by EventProcessor)\n\n    Instructions:\n    1. Mark task 4 as in-progress\n    2. Modify engine_event_processor.h to add handler member and setter\n    3. Implement setter in engine_event_processor.cpp\n    4. Compile and verify no errors\n    5. Log implementation with artifacts (member added, setter implemented)\n    6. Mark task 4 as complete\n    ```\n\n- [ ] 5. Integrate modifier detection into EventProcessor::layer2\n  - **Files**:\n    - `src/core/engine/engine_event_processor.cpp` (modify layer2_applySubstitution method)\n  - **Description**: Add modifier detection logic to Layer 2 processing before substitution lookup\n  - **Acceptance Criteria**:\n    - layer2_applySubstitution() checks if key is number/modal modifier\n    - If WAITING → suppresses event (returns 0)\n    - If TAP_DETECTED → proceeds to substitution\n    - If ACTIVATE/DEACTIVATE → updates modifier state and returns VK code\n    - Correct processing order maintained\n    - Integration test passes\n  - **_Leverage**: Existing layer2_applySubstitution method, ModifierKeyHandler API_\n  - **_Requirements**: Requirement 6 (Integration with Event Processing Pipeline)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: C++ Systems Programmer with expertise in event processing pipelines\n\n    Task: Integrate modifier detection into EventProcessor::layer2_applySubstitution method in src/core/engine/engine_event_processor.cpp following requirement 6.\n\n    Context:\n    - layer2_applySubstitution currently only does substitution lookup\n    - Need to add modifier detection BEFORE substitution\n    - Processing order critical: modifier detection → substitution → output\n\n    Implementation:\n    1. Modify layer2_applySubstitution(uint16_t yama_in, EventType type, ModifierState* io_modState):\n       - At start of method, check: if (!m_modifierHandler) { /* existing logic */ }\n       - Add check: if (m_modifierHandler->isNumberModifier(yama_in))\n       - Call: auto result = m_modifierHandler->processNumberKey(yama_in, type);\n       - Handle result:\n         - WAITING_FOR_THRESHOLD → return 0 (suppress event)\n         - APPLY_SUBSTITUTION_ON_DOWN or APPLY_SUBSTITUTION_ON_UP → fall through to substitution\n         - ACTIVATE_MODIFIER → io_modState->activate(result.modifierType); return result.output_yama_code;\n         - DEACTIVATE_MODIFIER → io_modState->deactivate(result.modifierType); return result.output_yama_code;\n         - APPLY_SUBSTITUTION → fall through to substitution lookup\n    2. Ensure existing substitution logic still works for non-modifier keys\n\n    Critical Order:\n    ```cpp\n    uint16_t layer2_applySubstitution(uint16_t yama_in, EventType type, ModifierState* io_modState) {\n        // 1. Check if modifier handler exists\n        if (!m_modifierHandler) {\n            // Fallback: normal substitution\n        }\n\n        // 2. Check if key is registered modifier\n        if (m_modifierHandler->isNumberModifier(yama_in)) {\n            auto result = m_modifierHandler->processNumberKey(yama_in, type);\n            // Handle result (see above)\n        }\n\n        // 3. Normal substitution lookup (for non-modifiers or TAP)\n        auto it = m_substitutions.find(yama_in);\n        return (it != m_substitutions.end()) ? it->second : yama_in;\n    }\n    ```\n\n    Restrictions:\n    - MUST check m_modifierHandler != nullptr before using\n    - DO NOT change existing substitution logic\n    - Preserve event type (DOWN/UP) through pipeline\n    - Handle all ProcessingAction enum values\n\n    Leverage:\n    - ModifierKeyHandler::processNumberKey() returns NumberKeyResult\n    - ProcessingAction enum (WAITING, TAP, ACTIVATE, DEACTIVATE, APPLY_SUBSTITUTION)\n    - Existing substitution table m_substitutions\n\n    Success Criteria:\n    - Modifier detection runs before substitution\n    - All ProcessingAction cases handled correctly\n    - WAITING suppresses event (no output)\n    - TAP falls through to substitution\n    - ACTIVATE/DEACTIVATE updates state and returns VK code\n    - Existing substitution tests still pass\n\n    Instructions:\n    1. Mark task 5 as in-progress\n    2. Modify layer2_applySubstitution in engine_event_processor.cpp\n    3. Add modifier detection logic at start of method\n    4. Handle all result cases correctly\n    5. Test with: ./yamy --test-config test_modal.mayu\n    6. Log implementation with artifacts (method modified, processing action handling)\n    7. Mark task 5 as complete\n    ```\n\n- [ ] 6. Add ModifierState parameter to EventProcessor methods\n  - **Files**:\n    - `src/core/engine/engine_event_processor.h` (update method signatures)\n    - `src/core/engine/engine_event_processor.cpp` (update implementations)\n  - **Description**: Thread ModifierState through EventProcessor methods for state propagation\n  - **Acceptance Criteria**:\n    - processEvent() accepts ModifierState* io_modState parameter\n    - layer2_applySubstitution() accepts and updates ModifierState\n    - Modifier state changes are propagated correctly\n    - All callers updated to pass ModifierState\n  - **_Leverage**: Existing EventProcessor method signatures_\n  - **_Requirements**: Requirement 4 (Modifier State Tracking)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: C++ Refactoring Specialist with expertise in API evolution\n\n    Task: Add ModifierState parameter to EventProcessor methods in src/core/engine/engine_event_processor.h/cpp to enable state propagation following requirement 4.\n\n    Context:\n    - EventProcessor currently doesn't track modifier state\n    - Need to thread ModifierState through pipeline for activate/deactivate\n    - Maintain backward compatibility where possible\n\n    Implementation:\n    1. Update method signatures in engine_event_processor.h:\n       - processEvent(uint16_t evdev_code, EventType type, ModifierState* io_modState);\n       - layer2_applySubstitution(uint16_t yama_in, EventType type, ModifierState* io_modState);\n    2. Update implementations in engine_event_processor.cpp:\n       - processEvent() passes io_modState to layer2_applySubstitution\n       - layer2_applySubstitution() updates io_modState when ACTIVATE/DEACTIVATE\n    3. Find all call sites and update:\n       - Search for \"processEvent(\" calls\n       - Pass current ModifierState from caller\n\n    Restrictions:\n    - Use pointer (not reference) to allow nullptr check if needed\n    - DO NOT modify Layer 1 or Layer 3 signatures (only Layer 2)\n    - Maintain const-correctness (io_ prefix means input/output)\n\n    Leverage:\n    - Existing ModifierState struct from Task 1\n    - Existing EventProcessor method structure\n\n    Success Criteria:\n    - All method signatures updated\n    - ModifierState propagated through pipeline\n    - activate/deactivate calls update state correctly\n    - All call sites updated\n    - Compiles without errors\n\n    Instructions:\n    1. Mark task 6 as in-progress\n    2. Update method signatures in .h file\n    3. Update implementations in .cpp file\n    4. Find and update all call sites (use grep/search)\n    5. Compile and verify\n    6. Log implementation with artifacts (methods updated, call sites changed)\n    7. Mark task 6 as complete\n    ```\n\n- [ ] 7. Create EventProcessor integration test\n  - **Files**:\n    - `tests/test_event_processor_modal.cpp` (create new file)\n  - **Description**: Integration tests for EventProcessor with modifier detection\n  - **Acceptance Criteria**:\n    - 10 integration tests covering modifier detection in Layer 2\n    - Tests verify WAITING suppresses events\n    - Tests verify TAP proceeds to substitution\n    - Tests verify ACTIVATE/DEACTIVATE updates state\n    - All tests pass\n  - **_Leverage**: Existing test patterns in tests/ directory_\n  - **_Requirements**: Requirement 6 (Integration with Event Processing Pipeline)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: Integration Test Engineer with C++ and Google Test expertise\n\n    Task: Create integration tests for EventProcessor modifier detection in tests/test_event_processor_modal.cpp covering all processing actions following requirement 6.\n\n    Context:\n    - EventProcessor now has modifier detection integrated (Tasks 4-6)\n    - Need to verify all ProcessingAction cases work correctly\n    - Must test interaction between modifier detection and substitution\n\n    Implementation:\n    1. Create tests/test_event_processor_modal.cpp\n    2. Write 10 integration tests:\n       - ModifierKeyWaiting_SuppressesEvent (returns 0)\n       - ModifierKeyTap_AppliesSubstitution (falls through)\n       - ModifierKeyActivate_UpdatesState (io_modState changed)\n       - ModifierKeyDeactivate_ClearsState\n       - NonModifierKey_UsesSubstitution (no interference)\n       - RapidTapTapHold_HandlesCorrectly\n       - MultipleModifiersIndependent\n       - StatePreservedAcrossEvents\n       - NullModifierHandler_FallsBackSafely\n       - ModifierStateNullptr_HandlesGracefully\n\n    3. Use mock/stub objects:\n       - Mock ModifierKeyHandler (return controlled results)\n       - Mock substitution table\n       - Real ModifierState object\n\n    Restrictions:\n    - Test EventProcessor in isolation (no Engine dependency)\n    - Use mocks for dependencies\n    - Each test is independent (no shared state)\n\n    Leverage:\n    - Google Test mocking framework (if available)\n    - Existing test utilities in tests/\n    - EventProcessor class from engine_event_processor.cpp\n\n    Success Criteria:\n    - All 10 tests compile and pass\n    - Cover all ProcessingAction enum values\n    - Verify state updates correctly\n    - Tests run in <200ms total\n\n    Instructions:\n    1. Mark task 7 as in-progress\n    2. Create tests/test_event_processor_modal.cpp\n    3. Write all 10 integration tests\n    4. Run: ./yamy_test --gtest_filter=\"EventProcessorModalTest.*\"\n    5. Verify all pass\n    6. Log implementation with artifacts (test file, test count)\n    7. Mark task 7 as complete\n    ```\n\n## Phase 3: Configuration Layer Integration (Tasks 8-10)\n\n- [ ] 8. Connect modal modifier definitions to ModifierKeyHandler registration\n  - **Files**:\n    - `src/core/engine/engine_setting.cpp` (modify buildSubstitutionTable or similar)\n  - **Description**: Register modal modifiers from config into ModifierKeyHandler during engine initialization\n  - **Acceptance Criteria**:\n    - Modal modifier definitions (mod modX = !!key) are read from config\n    - Each definition results in registerNumberModifier() call\n    - ModifierKeyHandler has all modal modifiers registered after config load\n    - Config reload updates registrations\n  - **_Leverage**: Existing config loading in engine_setting.cpp, Keyboard::getModalModifiers()_\n  - **_Requirements**: Requirement 1 (Modal Modifier Definition and Parsing)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: Configuration Integration Engineer with C++ and YAMY architecture expertise\n\n    Task: Connect modal modifier definitions from .mayu config to ModifierKeyHandler registration in src/core/engine/engine_setting.cpp following requirement 1.\n\n    Context:\n    - Modal modifiers are parsed by SettingLoader and stored in Keyboard object\n    - Need to bridge config → runtime registration gap\n    - Registration happens during Engine::loadSetting() or similar\n\n    Implementation:\n    1. Find method that builds EventProcessor (likely buildSubstitutionTable or loadSetting)\n    2. After EventProcessor creation, get modal modifiers from config:\n       ```cpp\n       const auto& keyboard = setting.getKeyboard();\n       // Iterate modal modifiers (if method exists)\n       ```\n    3. For each modal modifier:\n       - Extract trigger key scan code\n       - Extract modifier type (Type_Mod0..Mod19)\n       - Call: eventProcessor->registerNumberModifier(triggerKey, modifierType);\n    4. Do same for number modifiers:\n       ```cpp\n       for (const auto& numMod : keyboard.getNumberModifiers()) {\n           uint16_t numberKey = numMod.m_numberKey->getScanCodes()[0].m_scan;\n           uint16_t modifierKey = numMod.m_modifierKey->getScanCodes()[0].m_scan;\n           eventProcessor->registerNumberModifier(numberKey, modifierKey);\n       }\n       ```\n\n    Critical: Modal modifiers and number modifiers use SAME registration method (registerNumberModifier) but different parameters:\n    - Modal: registerNumberModifier(triggerKey, 0) + store modifierType separately\n    - OR: Extend registerNumberModifier to accept Modifier::Type\n\n    Restrictions:\n    - DO NOT modify SettingLoader (parsing already works)\n    - Only add registration calls, do not change config structure\n    - Handle empty config (zero modifiers) gracefully\n\n    Leverage:\n    - Keyboard class methods: getNumberModifiers(), possibly getModalModifiers()\n    - Existing config loading in engine_setting.cpp\n    - ModifierKeyHandler::registerNumberModifier()\n\n    Success Criteria:\n    - All modal modifiers from config are registered\n    - All number modifiers from config are registered\n    - Config with 20 modal + 100 number modifiers loads correctly\n    - Config reload updates registrations (old cleared, new added)\n\n    Instructions:\n    1. Mark task 8 as in-progress\n    2. Find config loading method in engine_setting.cpp\n    3. Add modal modifier registration loop\n    4. Add number modifier registration loop\n    5. Test with config: mod mod9 = !!A, def numbermod *_1 = *LShift\n    6. Verify registrations via debug logging or breakpoint\n    7. Log implementation with artifacts (registration loops added)\n    8. Mark task 8 as complete\n    ```\n\n- [ ] 9. Extend Keymap hash key generation to include modal modifiers\n  - **Files**:\n    - `src/core/input/keymap.cpp` (modify lookup method)\n    - `src/core/input/keymap.h` (update buildHashKey signature if needed)\n  - **Description**: Include modal modifier bitmask in keymap hash key for matching\n  - **Acceptance Criteria**:\n    - buildHashKey() accepts modal modifier bitmask parameter\n    - Hash key is 64-bit: (modal_mods << 32) | (standard_mods << 16) | scancode\n    - lookup() passes ModifierState.modal to buildHashKey\n    - Keymap matching works with modal modifiers\n  - **_Leverage**: Existing Keymap::lookup and hash key generation_\n  - **_Requirements**: Requirement 5 (Modifier Combination Keymap Lookup)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: Data Structures Engineer with hash table and performance optimization expertise\n\n    Task: Extend Keymap hash key generation to include modal modifiers in src/core/input/keymap.cpp following requirement 5.\n\n    Context:\n    - Keymap currently uses 32-bit hash: (modifiers << 16) | scancode\n    - Need 64-bit hash to fit 20 modal modifiers: (modal << 32) | (standard << 16) | scancode\n    - Must maintain backward compatibility with non-modal keymaps\n\n    Implementation:\n    1. Change hash key type from uint32_t to uint64_t:\n       - Update m_bindings map: unordered_map<uint64_t, Action*>\n       - Update buildHashKey() return type to uint64_t\n    2. Update buildHashKey() signature:\n       - Add parameter: uint32_t modal_modifiers\n       - Calculate: return ((uint64_t)modal_modifiers << 32) | (standard_modifiers << 16) | scancode;\n    3. Update lookup() method:\n       - Accept ModifierState parameter (not just standard modifiers)\n       - Pass modState.modal to buildHashKey()\n    4. Update all call sites of lookup() to pass ModifierState\n\n    Hash Key Format (64-bit):\n    ```\n    Bits 63-32: Modal modifiers (mod0-mod19, bits 0-19 used)\n    Bits 31-16: Standard modifiers (Shift, Ctrl, Alt, Win, bits 0-7 used)\n    Bits 15-0:  Scan code\n    ```\n\n    Restrictions:\n    - Maintain backward compatibility (non-modal entries have modal bits = 0)\n    - DO NOT change Action* value storage\n    - Hash function must be deterministic\n    - Consider hash collision (unlikely with 64-bit, but handle gracefully)\n\n    Leverage:\n    - Existing Keymap class at src/core/input/keymap.cpp\n    - std::unordered_map hash function (automatically handles uint64_t)\n    - ModifierState struct from Task 1\n\n    Success Criteria:\n    - Keymap uses 64-bit hash keys\n    - Modal modifier combinations are uniquely hashed\n    - lookup() matches entries with modal modifiers\n    - Backward compatibility maintained (standard-only entries still work)\n    - No hash collisions in test cases\n\n    Instructions:\n    1. Mark task 9 as in-progress\n    2. Update hash key type to uint64_t in keymap.h\n    3. Update buildHashKey() to accept modal parameter\n    4. Update lookup() to pass ModifierState\n    5. Update all call sites\n    6. Test: keymap with m9-*X entry matches when mod9 active\n    7. Log implementation with artifacts (hash key extended, lookup updated)\n    8. Mark task 9 as complete\n    ```\n\n- [ ] 10. Add fallback logic for keymap lookup with modal modifiers\n  - **Files**:\n    - `src/core/input/keymap.cpp` (extend lookup method)\n  - **Description**: Implement priority-based fallback when exact modal+standard match not found\n  - **Acceptance Criteria**:\n    - lookup() tries exact match first (all modifiers)\n    - Falls back to match without modal modifiers\n    - Falls back to match with fewer modifiers (priority ordering)\n    - Correct entry is matched in all test cases\n  - **_Leverage**: Existing Keymap::lookup method_\n  - **_Requirements**: Requirement 5 (Modifier Combination Keymap Lookup)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: Algorithm Designer with expertise in priority-based matching\n\n    Task: Implement fallback logic for keymap lookup when exact modal+standard match is not found in src/core/input/keymap.cpp following requirement 5.\n\n    Context:\n    - User may press mod9+X but only *X is defined in keymap (no m9-*X entry)\n    - Need graceful fallback to less specific matches\n    - Priority: exact match > without modal > with fewer modifiers > no match\n\n    Implementation:\n    1. Modify lookup() to try matches in order:\n       - Attempt 1: Exact match (all standard + all modal modifiers)\n         ```cpp\n         uint64_t hash = buildHashKey(scancode, modState.standard, modState.modal);\n         auto it = m_bindings.find(hash);\n         if (it != m_bindings.end()) return it->second;\n         ```\n       - Attempt 2: Without modal modifiers (standard only)\n         ```cpp\n         hash = buildHashKey(scancode, modState.standard, 0);\n         it = m_bindings.find(hash);\n         if (it != m_bindings.end()) return it->second;\n         ```\n       - Attempt 3: Without any modifiers (base key only)\n         ```cpp\n         hash = buildHashKey(scancode, 0, 0);\n         return m_bindings[hash];  // May be nullptr\n         ```\n\n    Advanced (Optional): If multiple modal modifiers active, try subsets:\n    - mod9+mod8 active: try (mod9+mod8), then (mod9), then (mod8), then (none)\n    - This is complex, implement only if time allows\n\n    Restrictions:\n    - DO NOT infinite loop (max 3 attempts)\n    - Return nullptr if no match found (do not crash)\n    - Maintain performance (<20μs per lookup)\n\n    Leverage:\n    - Existing m_bindings hash table\n    - buildHashKey() from Task 9\n    - ModifierState from Task 1\n\n    Success Criteria:\n    - Exact match is always preferred\n    - Fallback to standard-only works\n    - Fallback to no-modifiers works\n    - nullptr returned if truly no match\n    - Performance <20μs P99\n\n    Instructions:\n    1. Mark task 10 as in-progress\n    2. Modify lookup() method in keymap.cpp\n    3. Implement 3-attempt fallback logic\n    4. Test with configs:\n       - Only *X defined: mod9+X should match *X\n       - m9-*X and *X defined: mod9+X should match m9-*X (exact)\n    5. Benchmark lookup performance\n    6. Log implementation with artifacts (fallback logic added)\n    7. Mark task 10 as complete\n    ```\n\n## Phase 4: End-to-End Integration and Testing (Tasks 11-12)\n\n- [ ] 11. Create full integration test with mock evdev device\n  - **Files**:\n    - `tests/test_modal_e2e.cpp` (create new file)\n  - **Description**: End-to-end test using mock evdev device to simulate real keyboard input\n  - **Acceptance Criteria**:\n    - 15 E2E tests covering UAT scenarios\n    - Mock evdev device injects realistic event sequences\n    - Output is captured and verified\n    - All UAT scenarios pass (hold, tap, combinations)\n  - **_Leverage**: Mock evdev device creation (may need to implement), existing test utilities_\n  - **_Requirements**: All requirements (E2E validation)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: End-to-End Test Automation Engineer with Linux evdev expertise\n\n    Task: Create comprehensive end-to-end tests using mock evdev device in tests/test_modal_e2e.cpp covering all UAT scenarios.\n\n    Context:\n    - Need to simulate real keyboard input (evdev events)\n    - Verify entire pipeline: evdev → engine → uinput\n    - Test real-world workflows (Emacs prefix, Vim modal, etc.)\n\n    Implementation:\n    1. Create mock evdev device helper:\n       ```cpp\n       class MockEvdevDevice {\n       public:\n           void sendKeyDown(int evdev_code);\n           void sendKeyUp(int evdev_code);\n           void sleep(int ms);  // Simulate time passing\n           std::vector<Event> readOutputEvents();  // Capture uinput output\n       };\n       ```\n    2. Create tests/test_modal_e2e.cpp with 15 tests:\n       - UAT1_BasicModalModifier: Hold A, press X, verify Y output\n       - UAT2_TapVsHold: Tap A (Tab), hold A (mod9)\n       - UAT3_NumberModifierAsShift: Hold 1, press A, verify Shift+A\n       - UAT4_MultiModalCombination: Hold A+S, press X, verify Z\n       - UAT5_EmacsPrefixKey: Hold X, press F, verify OpenFile action\n       - UAT6_VimModalEditing: Hold Esc, press H/J/K/L, verify arrows\n       - UAT7_RapidTapping: Tap-tap-tap A quickly, verify all Tabs\n       - UAT8_HoldReleaseTap: Hold A, release, tap A, verify mod9 then Tab\n       - UAT9_CrossModifierInterference: mod9 + Ctrl, verify both active\n       - UAT10_ConfigReload: Load config, activate mod9, reload, verify state\n       - UAT11_MaxConcurrentModifiers: Activate 20 modal modifiers simultaneously\n       - UAT12_LatencyMeasurement: Measure hold→output latency (<1ms)\n       - UAT13_ThroughputTest: 1000 events/sec, verify no drops\n       - UAT14_LongHold: Hold for 60s, verify no stuck state\n       - UAT15_SuspendResume: Simulate system suspend/resume, verify recovery\n\n    3. Load config for each test:\n       ```cpp\n       Engine engine;\n       engine.loadConfig(\"test_configs/modal_basic.mayu\");\n       ```\n\n    Restrictions:\n    - Use real Engine instance (not mocked)\n    - Mock ONLY evdev/uinput (platform layer)\n    - Measure latency using std::chrono::high_resolution_clock\n    - Tests must be reproducible (no flaky timing)\n\n    Leverage:\n    - Existing Engine class\n    - Platform abstraction layer for evdev/uinput mocking\n    - Google Test framework\n\n    Success Criteria:\n    - All 15 UAT tests pass\n    - Latency measurements <1ms P99\n    - Throughput test achieves 1000 events/sec\n    - No memory leaks (valgrind clean)\n\n    Instructions:\n    1. Mark task 11 as in-progress\n    2. Create MockEvdevDevice helper class\n    3. Write all 15 E2E tests\n    4. Create test configs in test_configs/ directory\n    5. Run: ./yamy_test --gtest_filter=\"ModalE2ETest.*\"\n    6. Verify all pass and performance targets met\n    7. Log implementation with artifacts (test file, helper class, configs)\n    8. Mark task 11 as complete\n    ```\n\n- [ ] 12. Add performance benchmark for modal modifier pipeline\n  - **Files**:\n    - `benchmarks/bench_modal_modifier.cpp` (create new file, or add to existing benchmark)\n  - **Description**: Automated benchmark measuring latency of modal modifier detection\n  - **Acceptance Criteria**:\n    - Benchmark runs 100,000 iterations\n    - Measures P50, P95, P99, P99.9 latencies\n    - Reports hold detection, state update, and keymap lookup separately\n    - All targets met (<1ms P99 total pipeline)\n    - Outputs CSV for graphing\n  - **_Leverage**: Existing benchmark infrastructure (if any)_\n  - **_Requirements**: Non-Functional Requirements (Performance)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: Performance Engineer with profiling and benchmarking expertise\n\n    Task: Create automated performance benchmark for modal modifier pipeline in benchmarks/bench_modal_modifier.cpp measuring all latency targets.\n\n    Context:\n    - Need quantitative performance data (not just \"feels fast\")\n    - Measure each component separately (hold detection, state update, keymap lookup)\n    - Compare against targets: <10μs hold detection, <5μs state update, <15μs lookup, <1ms total\n\n    Implementation:\n    1. Create benchmarks/bench_modal_modifier.cpp\n    2. Implement benchmark harness:\n       ```cpp\n       void benchmarkHoldDetection(int iterations) {\n           ModifierKeyHandler handler;\n           handler.registerNumberModifier(0x001E, 0x002A);  // A → LShift\n\n           std::vector<std::chrono::nanoseconds> latencies;\n           for (int i = 0; i < iterations; i++) {\n               auto start = std::chrono::high_resolution_clock::now();\n               auto result = handler.processNumberKey(0x001E, EventType::DOWN);\n               auto end = std::chrono::high_resolution_clock::now();\n               latencies.push_back(end - start);\n           }\n\n           // Calculate percentiles\n           std::sort(latencies.begin(), latencies.end());\n           auto p50 = latencies[iterations * 0.50];\n           auto p95 = latencies[iterations * 0.95];\n           auto p99 = latencies[iterations * 0.99];\n           auto p999 = latencies[iterations * 0.999];\n\n           // Output results\n           std::cout << \"Hold Detection: P50=\" << p50.count() << \"ns, P99=\" << p99.count() << \"ns\\n\";\n       }\n       ```\n    3. Benchmark all components:\n       - Hold detection (processNumberKey)\n       - Modifier state update (activate/deactivate)\n       - Keymap lookup (with modal modifiers)\n       - Full pipeline (evdev → uinput)\n    4. Output CSV for graphing:\n       ```\n       Component,P50,P95,P99,P99.9\n       HoldDetection,8200,11500,12800,45300\n       StateUpdate,3100,4800,5900,8200\n       KeymapLookup,11700,15200,18500,32100\n       FullPipeline,387000,720000,842000,2100000\n       ```\n\n    Restrictions:\n    - Use high_resolution_clock (not steady_clock for measurement)\n    - Warm up: run 1000 iterations before measuring\n    - Disable debug logging during benchmark\n    - Run with CPU governor set to performance (document this requirement)\n\n    Leverage:\n    - std::chrono for timing\n    - Statistical percentile calculation\n    - Existing benchmark patterns in project (if any)\n\n    Success Criteria:\n    - Benchmark completes 100,000 iterations\n    - P50, P95, P99, P99.9 latencies reported\n    - All targets met:\n      - Hold detection P99 < 10μs\n      - State update P99 < 5μs\n      - Keymap lookup P99 < 15μs\n      - Full pipeline P99 < 1ms\n    - CSV output for graphing\n\n    Instructions:\n    1. Mark task 12 as in-progress\n    2. Create benchmarks/bench_modal_modifier.cpp\n    3. Implement benchmark for each component\n    4. Run benchmark: ./bench_modal_modifier --iterations 100000\n    5. Verify all targets met\n    6. Save CSV output to benchmarks/results/modal_modifier_latency.csv\n    7. Log implementation with artifacts (benchmark file, results CSV)\n    8. Mark task 12 as complete\n    ```\n\n## Phase 5: Documentation and Final Validation (Tasks 13-15)\n\n- [ ] 13. Create user documentation for modal modifier syntax\n  - **Files**:\n    - `docs/MODAL_MODIFIER_GUIDE.md` (create new file)\n  - **Description**: User-facing documentation explaining modal modifier syntax and examples\n  - **Acceptance Criteria**:\n    - Documentation covers: syntax, examples, use cases, troubleshooting\n    - 5-minute quick start guide\n    - Advanced examples (Emacs, Vim workflows)\n    - Clear error message explanations\n  - **_Leverage**: Existing documentation style in docs/_\n  - **_Requirements**: Non-Functional Requirements (Usability)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: Technical Writer with keyboard customization and YAMY expertise\n\n    Task: Create comprehensive user documentation for modal modifiers in docs/MODAL_MODIFIER_GUIDE.md.\n\n    Context:\n    - Users need to understand how to use modal modifiers in their .mayu files\n    - Documentation should be beginner-friendly but cover advanced use cases\n    - Follow SPEC_DRIVEN_DEV_GUIDE.md TIP 5 (Quick Start Guide format)\n\n    Implementation:\n    1. Create docs/MODAL_MODIFIER_GUIDE.md with sections:\n       - **Quick Start (5 Minutes)**:\n         - What modal modifiers do (3 sentences)\n         - Simplest example: mod mod9 = !!A, key m9-*X = Y\n         - How to test it works\n       - **Syntax Reference**:\n         - mod modX = !!key (modal modifier definition)\n         - def numbermod *key = *HardwareMod (number modifier definition)\n         - key mX-*key = output (modal combination)\n       - **Examples**:\n         - Emacs C-x prefix key\n         - Vim normal mode (Esc as modal layer)\n         - Number row as function keys\n       - **Advanced Use Cases**:\n         - Multiple modal modifiers (mod9+mod8)\n         - Combining with standard modifiers (Ctrl+mod9)\n         - Chaining modal layers\n       - **Troubleshooting**:\n         - Error: \"Invalid modal modifier index mod25\"\n         - Error: \"Cannot use hardware modifier as modal trigger\"\n         - Debugging: Check logs for MODIFIER:ACTIVATE messages\n       - **Performance Notes**:\n         - Hold threshold default: 200ms (not configurable yet)\n         - Latency: <1ms typical\n       - **Cross-Platform Notes**:\n         - Works identically on Windows and Linux\n         - Same .mayu file can be used on both\n\n    2. Include code examples in .mayu syntax:\n       ```mayu\n       # Emacs-style C-x prefix\n       mod mod9 = !!X\n       key m9-*F = &OpenFile     # C-x C-f\n       key m9-*S = &SaveFile     # C-x C-s\n       key m9-*C = &Exit         # C-x C-c\n       ```\n\n    Restrictions:\n    - Use markdown format\n    - Keep Quick Start section under 500 words\n    - Include table of contents\n    - No implementation details (focus on user usage)\n\n    Leverage:\n    - Existing docs/ structure\n    - SPEC_DRIVEN_DEV_GUIDE.md TIP 5 template\n\n    Success Criteria:\n    - Documentation is complete and accurate\n    - Quick Start takes <5 minutes to read and try\n    - All syntax examples are valid and tested\n    - Troubleshooting covers common errors\n\n    Instructions:\n    1. Mark task 13 as in-progress\n    2. Create docs/MODAL_MODIFIER_GUIDE.md\n    3. Write all sections\n    4. Test all code examples in real .mayu file\n    5. Have someone else read Quick Start and give feedback\n    6. Log implementation with artifacts (doc file created)\n    7. Mark task 13 as complete\n    ```\n\n- [ ] 14. Add integration test config files\n  - **Files**:\n    - `test_configs/modal_basic.mayu` (create)\n    - `test_configs/modal_advanced.mayu` (create)\n    - `test_configs/modal_stress.mayu` (create)\n  - **Description**: Test configuration files for integration and E2E tests\n  - **Acceptance Criteria**:\n    - 3 test configs covering basic, advanced, and stress scenarios\n    - All configs parse without errors\n    - Configs used by integration and E2E tests\n  - **_Leverage**: Existing keymaps/config.mayu as reference_\n  - **_Requirements**: All requirements (test coverage)_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: QA Configuration Engineer with .mayu syntax expertise\n\n    Task: Create test configuration files for integration and E2E tests in test_configs/ directory.\n\n    Context:\n    - Integration tests (Task 11) need realistic .mayu configs\n    - Need variety: basic (1 modifier), advanced (multiple), stress (edge cases)\n\n    Implementation:\n    1. Create test_configs/modal_basic.mayu:\n       ```mayu\n       # Basic modal modifier test\n       mod mod9 = !!A\n       def subst *A = *Tab\n\n       key m9-*X = Y\n       key m9-*F = &OpenFile\n       ```\n\n    2. Create test_configs/modal_advanced.mayu:\n       ```mayu\n       # Advanced: multiple modal modifiers + standard modifiers\n       mod mod9 = !!A\n       mod mod8 = !!S\n\n       def numbermod *_1 = *LShift\n       def numbermod *_2 = *LCtrl\n\n       # Modal combinations\n       key m9-*X = Y\n       key *C-m9-*X = Z\n       key m8-m9-*X = W\n\n       # Number modifier combinations\n       # (Hold 1 = Shift, so 1+A should output Shift+A)\n       ```\n\n    3. Create test_configs/modal_stress.mayu:\n       ```mayu\n       # Stress test: maximum modifiers\n       mod mod0 = !!Q\n       mod mod1 = !!W\n       ...\n       mod mod19 = !!P  # 20 total\n\n       # 100 number modifiers (all letters)\n       def numbermod *A = *F1\n       def numbermod *B = *F2\n       ...\n\n       # Complex combinations\n       key m0-m1-m2-*X = Y  # Multiple modal modifiers\n       ```\n\n    Restrictions:\n    - All configs must parse without errors\n    - Use valid key names (check keymaps/109_clean.mayu for reference)\n    - DO NOT use undefined keys or actions\n\n    Leverage:\n    - Existing keymaps/config.mayu for syntax reference\n    - Key names from keymaps/109_clean.mayu\n\n    Success Criteria:\n    - All 3 configs parse successfully\n    - Configs cover basic, advanced, and stress scenarios\n    - Configs are used by integration tests (Task 11)\n\n    Instructions:\n    1. Mark task 14 as in-progress\n    2. Create test_configs/ directory if needed\n    3. Write modal_basic.mayu\n    4. Write modal_advanced.mayu\n    5. Write modal_stress.mayu\n    6. Validate: ./yamy --validate-config test_configs/modal_basic.mayu\n    7. Log implementation with artifacts (3 config files)\n    8. Mark task 14 as complete\n    ```\n\n- [ ] 15. Final validation and acceptance testing\n  - **Files**: (no new files, run existing tests)\n  - **Description**: Run complete test suite and validate all acceptance criteria are met\n  - **Acceptance Criteria**:\n    - All unit tests pass (60 tests)\n    - All integration tests pass (30 tests)\n    - All E2E tests pass (15 tests)\n    - Performance benchmarks meet targets (<1ms P99)\n    - Documentation complete and accurate\n    - Zero P0 bugs\n  - **_Leverage**: All previous tasks_\n  - **_Requirements**: All requirements_\n  - **_Prompt**:\n    ```\n    Implement the task for spec modal-modifier-remapping, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Role: QA Lead with responsibility for feature acceptance and quality gates\n\n    Task: Execute final validation checklist and verify all acceptance criteria are met for modal modifier remapping feature.\n\n    Context:\n    - All development tasks (1-14) are complete\n    - Need to verify feature is ready for production\n    - Checklist from requirements.md must all pass\n\n    Implementation:\n    1. Run complete test suite:\n       ```bash\n       ./yamy_test --gtest_filter=\"*\"\n       # Verify: 60 unit + 30 integration + 15 E2E = 105 tests pass\n       ```\n\n    2. Run performance benchmark:\n       ```bash\n       ./bench_modal_modifier --iterations 100000\n       # Verify: P99 < 1ms total pipeline\n       ```\n\n    3. Manual UAT testing:\n       - Load test_configs/modal_basic.mayu\n       - Execute UAT-1 through UAT-5 from requirements.md\n       - Verify correct behavior\n\n    4. Cross-platform validation (if applicable):\n       - Run tests on Windows (if ported)\n       - Verify identical behavior\n\n    5. Documentation review:\n       - Read docs/MODAL_MODIFIER_GUIDE.md\n       - Verify all examples work\n       - Check for typos/errors\n\n    6. Code quality verification:\n       ```bash\n       # Check lines per file\n       wc -l src/core/engine/modifier_key_handler.cpp\n       # Target: <500 lines\n\n       # Check test coverage\n       ./yamy_test --coverage\n       # Target: >95%\n       ```\n\n    7. Memory leak check:\n       ```bash\n       valgrind --leak-check=full ./yamy_test\n       # Target: zero leaks\n       ```\n\n    Restrictions:\n    - DO NOT modify code (validation only)\n    - If issues found, create new tasks (do not fix in this task)\n    - Document all findings\n\n    Leverage:\n    - All tests from Tasks 2, 7, 11, 12\n    - Documentation from Task 13\n    - Acceptance criteria from requirements.md\n\n    Success Criteria:\n    - All 105 tests pass\n    - Performance targets met (<1ms P99)\n    - Zero memory leaks\n    - All UAT scenarios work correctly\n    - Documentation accurate\n    - Code quality gates met (500/50 line limits, >95% coverage)\n\n    Instructions:\n    1. Mark task 15 as in-progress\n    2. Run complete test suite and record results\n    3. Run performance benchmark and verify targets\n    4. Execute manual UAT tests\n    5. Review documentation\n    6. Check code quality metrics\n    7. Run memory leak check\n    8. Create summary report:\n       ```markdown\n       # Modal Modifier Remapping - Final Validation Report\n\n       ## Test Results\n       - Unit tests: 60/60 PASS\n       - Integration tests: 30/30 PASS\n       - E2E tests: 15/15 PASS\n\n       ## Performance\n       - P99 latency: 842μs (target: <1ms) ✓\n\n       ## Code Quality\n       - Max file: 287 lines (target: <500) ✓\n       - Coverage: 97.3% (target: >95%) ✓\n\n       ## Manual UAT\n       - UAT-1: PASS\n       - UAT-2: PASS\n       - UAT-3: PASS\n       - UAT-4: PASS\n       - UAT-5: PASS\n\n       ## Conclusion\n       Feature READY for production\n       ```\n    9. Log implementation with validation report\n    10. Mark task 15 as complete\n    ```\n\n---\n\n## Task Dependencies\n\n```\nPhase 1 (Foundation):\n  1 → 2 (ModifierState must exist before testing)\n  3 (Independent, verify existing code)\n\nPhase 2 (Event Processing):\n  4 → 5 → 6 → 7 (Sequential: add handler → integrate → thread state → test)\n\nPhase 3 (Configuration):\n  8 (Depends on 4-6: EventProcessor must have handler)\n  9 → 10 (Keymap extension before fallback logic)\n\nPhase 4 (E2E):\n  11 (Depends on all previous: full system integration)\n  12 (Independent benchmark, can run parallel with 11)\n\nPhase 5 (Finalization):\n  13 (Documentation, can be done anytime)\n  14 (Test configs, supports task 11)\n  15 (Final validation, depends on ALL previous tasks)\n```\n\n## Estimated Total Effort\n\n- **Phase 1**: 3 tasks × 2 hours = 6 hours\n- **Phase 2**: 4 tasks × 3 hours = 12 hours\n- **Phase 3**: 3 tasks × 2 hours = 6 hours\n- **Phase 4**: 2 tasks × 4 hours = 8 hours\n- **Phase 5**: 3 tasks × 2 hours = 6 hours\n\n**Total**: ~38 hours of development time\n\n---\n\n**Document Version**: 1.0\n**Created**: 2025-12-14\n**Reviewed By**: (Pending approval)\n",
  "fileStats": {
    "size": 51489,
    "lines": 1252,
    "lastModified": "2025-12-14T04:33:18.535Z"
  },
  "comments": []
}