{
  "id": "snapshot_1765698785306_fnj2r6aow",
  "approvalId": "approval_1765681183157_g04gywp2h",
  "approvalTitle": "Tasks Document - Investigate Window Feature",
  "version": 2,
  "timestamp": "2025-12-14T07:53:05.306Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Tasks Document: Investigate Window Feature\n\n## Task Breakdown\n\n### Phase 1: IPC Infrastructure (Critical Path)\n\n- [x] 1.1 Create IPCChannelQt implementation for QLocalSocket communication\n  - Files:\n    - src/core/platform/linux/ipc_channel_qt.h (new)\n    - src/core/platform/linux/ipc_channel_qt.cpp (new)\n  - Description:\n    - Implement `IIPCChannel` interface using `QLocalSocket` (client) and `QLocalServer` (server)\n    - Add message framing (4-byte length prefix + data) to prevent partial reads\n    - Implement serialization/deserialization using `QDataStream`\n    - Emit `messageReceived()` signal when complete messages arrive\n    - Handle connection states (disconnected, connecting, connected)\n  - _Leverage:\n    - src/core/platform/ipc_channel_interface.h\n    - Qt5 QLocalSocket, QLocalServer, QDataStream\n  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5\n  - _Prompt:\n    ```\n    Role: Qt/IPC Developer specializing in inter-process communication and Qt network programming\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Create a Qt-based IPC channel implementation (`IPCChannelQt`) that enables communication between the YAMY Qt GUI and the core engine process using Unix domain sockets.\n\n    Requirements:\n    - Implement `IIPCChannel` interface from src/core/platform/ipc_channel_interface.h\n    - Use `QLocalSocket` for client mode (dialog connecting to engine)\n    - Use `QLocalServer` for server mode (engine listening for connections)\n    - Socket path: /tmp/yamy-{name}-{UID} (user-specific to avoid collisions)\n    - Message framing: 4-byte length prefix (big-endian) + serialized data\n    - Serialization: Use QDataStream to write/read ipc::Message structs\n    - Error handling: Emit disconnected() signal on socket errors, reconnect logic in client\n    - Thread safety: All operations should be thread-safe via Qt's queued connections\n\n    Implementation Details:\n    1. Header file (ipc_channel_qt.h):\n       - Inherit from IIPCChannel (Qt QObject base)\n       - Add private slots: onReadyRead(), onConnected(), onDisconnected()\n       - Add private members: QLocalSocket* m_clientSocket, QLocalServer* m_server, QByteArray m_receiveBuffer\n    2. Implementation file (ipc_channel_qt.cpp):\n       - connect(): Create QLocalSocket, call connectToServer(socketPath)\n       - listen(): Create QLocalServer, call QLocalServer::listen(socketPath)\n       - send(): Serialize message to QByteArray (4-byte length + data), write to socket\n       - onReadyRead(): Read from socket into buffer, parse length prefix, deserialize messages, emit messageReceived()\n       - Handle partial reads (buffer accumulation until full message available)\n\n    Restrictions:\n    - Do not use blocking socket operations (no waitForReadyRead, waitForConnected)\n    - Do not bypass Qt event loop (all I/O must be asynchronous via signals/slots)\n    - Do not hardcode socket paths (use constructor parameter)\n    - Do not leak memory (use smart pointers, Qt parent-child ownership)\n\n    Success Criteria:\n    - IPCChannelQt compiles without errors\n    - Client can connect to server within <100ms\n    - Messages sent via send() are received via messageReceived() signal\n    - Round-trip latency <5ms (measured with QElapsedTimer)\n    - No memory leaks after 1000 connect/disconnect cycles (validated with Valgrind)\n    - Unit tests pass (send/receive, connection failure, large messages)\n\n    Instructions:\n    1. Before starting, search implementation logs:\n       - grep -r \"IPC.*Channel\" .spec-workflow/specs/*/Implementation\\ Logs/\n       - grep -r \"QLocalSocket\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark task as in progress: Edit tasks.md, change [ ] to [-]\n    3. Implement the code following the technical design\n    4. Write unit tests in tests/platform/ipc_channel_qt_test.cpp\n    5. Run tests and verify all pass\n    6. Log implementation using log-implementation tool with detailed artifacts:\n       - apiEndpoints: N/A (not HTTP API)\n       - components: N/A (backend only)\n       - functions: List all public methods (connect, disconnect, listen, send, etc.)\n       - classes: IPCChannelQt with full method list\n       - integrations: Describe how dialog connects to engine via QLocalSocket\n    7. Mark task as complete: Edit tasks.md, change [-] to [x]\n    ```\n\n- [x] 1.2 Update IPC channel factory to return IPCChannelQt on Linux\n  - Files:\n    - src/core/platform/ipc_channel_factory.h (modify)\n  - Description:\n    - Replace `IPCChannelNull` with `IPCChannelQt` when `QT_CORE_LIB` is defined\n    - Add conditional compilation for Qt dependency\n  - _Leverage:\n    - Existing factory pattern\n    - ipc_channel_qt.h from task 1.1\n  - _Requirements: 3.1\n  - _Prompt:\n    ```\n    Role: Build System Engineer specializing in CMake and cross-platform compilation\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Update the IPC channel factory to return a real Qt-based IPC implementation instead of the null stub on Linux.\n\n    Context:\n    - Currently, createIPCChannel() always returns IPCChannelNull (stub, no-op)\n    - Task 1.1 created IPCChannelQt with real QLocalSocket implementation\n    - Need to conditionally compile: Linux+Qt → IPCChannelQt, otherwise → IPCChannelNull\n\n    Implementation:\n    1. Open src/core/platform/ipc_channel_factory.h\n    2. Add #include \"linux/ipc_channel_qt.h\" at top (guarded by #if defined(__linux__) && defined(QT_CORE_LIB))\n    3. Modify createIPCChannel() function:\n       ```cpp\n       inline std::unique_ptr<IIPCChannel> createIPCChannel(const std::string& name) {\n           #if defined(__linux__) && defined(QT_CORE_LIB)\n               return std::make_unique<IPCChannelQt>(name);\n           #else\n               return std::make_unique<IPCChannelNull>();\n           #endif\n       }\n       ```\n\n    Restrictions:\n    - Do not break headless builds (when QT_CORE_LIB not defined)\n    - Do not add Windows-specific code here (keep platform-neutral)\n    - Ensure factory function remains inline (header-only, no .cpp file)\n\n    Success Criteria:\n    - Factory compiles on Linux with Qt (returns IPCChannelQt)\n    - Factory compiles on Linux without Qt (returns IPCChannelNull)\n    - Factory compiles on Windows (returns IPCChannelNull for now)\n    - No linker errors (IPCChannelQt properly linked with Qt5::Network)\n\n    Instructions:\n    1. Search implementation logs: grep -r \"factory.*IPC\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark task in progress: Edit tasks.md\n    3. Modify ipc_channel_factory.h with conditional compilation\n    4. Test compilation: mkdir build && cd build && cmake .. && make\n    5. Verify with: nm yamy_stub | grep IPCChannelQt (should show symbols)\n    6. Log implementation with artifacts (classes: createIPCChannel factory function)\n    7. Mark task complete\n    ```\n\n- [x] 1.3 Connect engine IPC messageReceived signal to handleIpcMessage\n  - Files:\n    - src/core/engine/engine_lifecycle.cpp (modify)\n    - src/core/engine/engine.h (modify if needed)\n  - Description:\n    - In Engine constructor, connect `m_ipcChannel->messageReceived` signal to `Engine::handleIpcMessage` slot\n    - Ensure Qt signals/slots work (Engine may need Q_OBJECT macro if not already present)\n  - _Leverage:\n    - Existing m_ipcChannel member\n    - Existing handleIpcMessage() method\n    - Qt signal/slot system\n  - _Requirements: 3.2\n  - _Prompt:\n    ```\n    Role: Qt Backend Developer with expertise in signal/slot connections and engine integration\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Wire up the engine's IPC channel so that incoming messages trigger the existing handleIpcMessage() handler.\n\n    Context:\n    - Engine creates IPC channel in constructor (engine_lifecycle.cpp:79)\n    - Engine has handleIpcMessage() method that processes requests (engine.cpp:499)\n    - Currently: Channel created but messageReceived signal never connected (messages ignored)\n    - Goal: Connect signal so RspInvestigateWindow responses are actually sent\n\n    Implementation:\n    1. Open src/core/engine/engine_lifecycle.cpp\n    2. Find Engine::Engine() constructor (~line 37)\n    3. Locate existing IPC channel creation (~line 79-84):\n       ```cpp\n       m_ipcChannel = yamy::platform::createIPCChannel(\"yamy-engine\");\n       if (m_ipcChannel) {\n           m_ipcChannel->listen();\n       }\n       ```\n    4. Add Qt signal/slot connection (only when Qt is available):\n       ```cpp\n       m_ipcChannel = yamy::platform::createIPCChannel(\"yamy-engine\");\n       if (m_ipcChannel) {\n           #if defined(QT_CORE_LIB)\n           // Connect IPC signal to handler\n           QObject::connect(m_ipcChannel.get(), &yamy::platform::IIPCChannel::messageReceived,\n                            [this](const yamy::ipc::Message& msg) {\n                                this->handleIpcMessage(msg);\n                            });\n           #endif\n           m_ipcChannel->listen();\n       }\n       ```\n    5. Note: Engine class doesn't inherit QObject, so use lambda to capture 'this'\n\n    Restrictions:\n    - Do not modify Engine to inherit QObject (breaks existing architecture)\n    - Do not connect signal if QT_CORE_LIB not defined (headless builds)\n    - Do not block on IPC reads (connection is asynchronous)\n\n    Success Criteria:\n    - Code compiles with and without Qt\n    - When dialog sends CmdInvestigateWindow, engine responds with RspInvestigateWindow\n    - Integration test passes: dialog receives keymap status within 5ms\n    - No deadlocks or blocking behavior\n\n    Instructions:\n    1. Search logs: grep -r \"handleIpcMessage.*connect\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Modify engine_lifecycle.cpp with signal connection\n    4. Test: Launch engine + dialog, select window, verify keymap panel updates\n    5. Log with artifacts (integrations: \"Engine IPC handler receives messages from IPCChannelQt\")\n    6. Mark complete\n    ```\n\n- [x] 1.4 Uncomment and fix IPC response sending in handleIpcMessage\n  - Files:\n    - src/core/engine/engine.cpp (modify)\n  - Description:\n    - Find commented-out `m_ipcChannel->send(responseMessage)` line (~line 533)\n    - Uncomment and wrap with null check: `if (m_ipcChannel && m_ipcChannel->isConnected())`\n  - _Leverage:\n    - Existing handleIpcMessage() implementation\n    - Existing queryKeymapForWindow() method\n  - _Requirements: 3.2, 4.1, 4.2, 4.3, 4.4\n  - _Prompt:\n    ```\n    Role: Backend Developer with expertise in IPC protocols and engine internals\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Enable the engine to actually send IPC responses back to the dialog when it queries keymap status.\n\n    Context:\n    - Engine::handleIpcMessage() processes CmdInvestigateWindow requests (engine.cpp:499-540)\n    - Code builds InvestigateWindowResponse struct but never sends it (line 533 commented out)\n    - Comment says: \"This is a simplification. A real implementation would need a way to send...\"\n    - Now we have real IPC (IPCChannelQt), so uncomment and fix the send\n\n    Implementation:\n    1. Open src/core/engine/engine.cpp\n    2. Navigate to handleIpcMessage() method (~line 499)\n    3. Find CmdInvestigateWindow case (~line 508-536)\n    4. Locate commented line: // m_ipcChannel->send(responseMessage);\n    5. Replace with:\n       ```cpp\n       // Send response back to dialog\n       if (m_ipcChannel && m_ipcChannel->isConnected()) {\n           m_ipcChannel->send(responseMessage);\n       }\n       ```\n    6. Ensure responseMessage is still in scope (should be, it's right before this line)\n\n    Restrictions:\n    - Do not send if channel is null or disconnected (prevents crashes)\n    - Do not block waiting for send to complete (IPC is asynchronous)\n    - Do not modify queryKeymapForWindow() (already works correctly)\n\n    Success Criteria:\n    - Dialog sends CmdInvestigateWindow request → engine responds within 5ms\n    - Keymap panel shows correct keymap name, matched regex, modifiers\n    - No crashes when dialog disconnects mid-request\n    - Integration test passes: round-trip request-response verified\n\n    Instructions:\n    1. Search logs: grep -r \"RspInvestigateWindow\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Uncomment and fix send() line in engine.cpp\n    4. Test: Use dialog to select window, verify panels populate (not \"-\" or \"(IPC not connected)\")\n    5. Log with artifacts (integrations: \"Engine sends RspInvestigateWindow to dialog via IPC\")\n    6. Mark complete\n    ```\n\n### Phase 2: Window System Implementation (X11/XCB)\n\n- [x] 2.1 Implement X11 connection management in WindowSystemLinux\n  - Files:\n    - src/platform/linux/window_system_linux.cpp (modify)\n  - Description:\n    - Open X11 display in constructor: `m_display = XOpenDisplay(NULL)`\n    - Store root window: `m_rootWindow = DefaultRootWindow(m_display)`\n    - Install X11 error handler to catch BadWindow errors gracefully\n    - Close display in destructor\n  - _Leverage:\n    - Existing WindowSystemLinux skeleton\n    - X11 Xlib API\n  - _Requirements: 1.1, 1.2, 1.3, 1.4\n  - _Prompt:\n    ```\n    Role: X11/Linux Systems Programmer with expertise in Xlib and window managers\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Set up X11 connection management so WindowSystemLinux can query window properties without crashing on errors.\n\n    Context:\n    - WindowSystemLinux is stubbed (all methods return hardcoded values)\n    - Need to establish persistent X11 connection for property queries\n    - Must handle errors gracefully (windows can close, disappear, etc.)\n\n    Implementation:\n    1. Open src/platform/linux/window_system_linux.cpp\n    2. Add X11 includes at top:\n       ```cpp\n       #include <X11/Xlib.h>\n       #include <X11/Xutil.h>\n       #include <X11/Xatom.h>\n       ```\n    3. Add private members to WindowSystemLinux class (in .cpp or .h):\n       ```cpp\n       Display* m_display;\n       Window m_rootWindow;\n       std::map<Atom, std::string> m_atomCache;  // For caching atom lookups\n       ```\n    4. Implement constructor initialization:\n       ```cpp\n       WindowSystemLinux::WindowSystemLinux() {\n           m_display = XOpenDisplay(NULL);\n           if (!m_display) {\n               std::cerr << \"[WindowSystemLinux] ERROR: Cannot open X11 display\" << std::endl;\n               // Continue anyway, methods will handle null display\n           } else {\n               m_rootWindow = DefaultRootWindow(m_display);\n               // Install error handler\n               XSetErrorHandler(windowSystemErrorHandler);\n           }\n       }\n       ```\n    5. Implement error handler (static function):\n       ```cpp\n       static int windowSystemErrorHandler(Display* display, XErrorEvent* error) {\n           char errorText[256];\n           XGetErrorText(display, error->error_code, errorText, sizeof(errorText));\n           std::cerr << \"[WindowSystemLinux] X11 Error: \" << errorText << std::endl;\n           return 0;  // Don't abort, just log\n       }\n       ```\n    6. Implement destructor:\n       ```cpp\n       WindowSystemLinux::~WindowSystemLinux() {\n           if (m_display) {\n               XCloseDisplay(m_display);\n           }\n       }\n       ```\n    7. Add helper method for atom caching:\n       ```cpp\n       Atom WindowSystemLinux::getAtom(const char* name) {\n           auto it = m_atomCache.find(name);\n           if (it != m_atomCache.end()) {\n               return it->second;\n           }\n           Atom atom = XInternAtom(m_display, name, False);\n           m_atomCache[name] = atom;\n           return atom;\n       }\n       ```\n\n    Restrictions:\n    - Do not call XOpenDisplay in every method (expensive, connection pooling needed)\n    - Do not crash on XOpenDisplay failure (graceful degradation)\n    - Do not ignore X11 errors (log them for debugging)\n\n    Success Criteria:\n    - WindowSystemLinux constructor opens X11 display successfully\n    - No crashes when DISPLAY env var is unset (error logged instead)\n    - X11 error handler catches BadWindow, BadAtom, etc. without aborting\n    - Destructor closes display without leaks (validated with Valgrind)\n\n    Instructions:\n    1. Search logs: grep -r \"X11.*Display.*Open\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Implement X11 connection setup in constructor/destructor\n    4. Test: DISPLAY=:0 ./yamy_stub (should not crash)\n    5. Test: DISPLAY=invalid ./yamy_stub (should log error, continue)\n    6. Log with artifacts (classes: WindowSystemLinux, functions: getAtom, windowSystemErrorHandler)\n    7. Mark complete\n    ```\n\n- [x] 2.2 Implement window property queries (title, class, PID)\n  - Files:\n    - src/platform/linux/window_system_linux_queries.cpp (modify)\n  - Description:\n    - Implement `getWindowText()`: Query `_NET_WM_NAME` (UTF-8), fallback to `WM_NAME`\n    - Implement `getClassName()`: Parse `WM_CLASS` property (format: \"instance\\0class\\0\")\n    - Implement `getWindowProcessId()`: Read `_NET_WM_PID` property, return uint32_t\n    - Handle errors (null properties, BadWindow, etc.)\n  - _Leverage:\n    - X11 Xlib XGetWindowProperty API\n    - Atom caching from task 2.1\n  - _Requirements: 1.3, 2.1, 2.2\n  - _Prompt:\n    ```\n    Role: X11 Developer specializing in EWMH (Extended Window Manager Hints) and ICCCM protocols\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Implement real X11 property queries to extract window title, class name, and process ID.\n\n    Context:\n    - Task 2.1 set up X11 connection (m_display, m_rootWindow, error handler)\n    - Currently: getWindowText() returns \"Stub Window\", getClassName() returns \"StubClass\", getWindowProcessId() returns 0\n    - Need to query X11 properties using XGetWindowProperty\n\n    Implementation:\n    1. Open src/platform/linux/window_system_linux_queries.cpp\n    2. Implement getWindowText() (~line 26-29):\n       ```cpp\n       std::string WindowSystemLinux::getWindowText(WindowHandle hwnd) {\n           if (!m_display || !hwnd) return \"\";\n\n           // Try _NET_WM_NAME first (UTF-8)\n           Atom utf8String = getAtom(\"UTF8_STRING\");\n           Atom netWmName = getAtom(\"_NET_WM_NAME\");\n           Atom actualType;\n           int actualFormat;\n           unsigned long nItems, bytesAfter;\n           unsigned char* prop = nullptr;\n\n           if (XGetWindowProperty(m_display, hwnd, netWmName, 0, 1024, False,\n                                  utf8String, &actualType, &actualFormat,\n                                  &nItems, &bytesAfter, &prop) == Success && prop) {\n               std::string result(reinterpret_cast<char*>(prop));\n               XFree(prop);\n               return result;\n           }\n\n           // Fallback to WM_NAME (legacy, may not be UTF-8)\n           if (XFetchName(m_display, hwnd, reinterpret_cast<char**>(&prop)) && prop) {\n               std::string result(reinterpret_cast<char*>(prop));\n               XFree(prop);\n               return result;\n           }\n\n           return \"\";  // No title\n       }\n       ```\n    3. Implement getClassName() (~line 36-39):\n       ```cpp\n       std::string WindowSystemLinux::getClassName(WindowHandle hwnd) {\n           if (!m_display || !hwnd) return \"\";\n\n           XClassHint classHint;\n           if (XGetClassHint(m_display, hwnd, &classHint) == 0) {\n               return \"\";  // Failed\n           }\n\n           // WM_CLASS format: \"instance\\0class\\0\"\n           // We want the class part (second string)\n           std::string result = classHint.res_class ? classHint.res_class : \"\";\n           if (classHint.res_name) XFree(classHint.res_name);\n           if (classHint.res_class) XFree(classHint.res_class);\n           return result;\n       }\n       ```\n    4. Implement getWindowProcessId() (~line 46-49):\n       ```cpp\n       uint32_t WindowSystemLinux::getWindowProcessId(WindowHandle hwnd) {\n           if (!m_display || !hwnd) return 0;\n\n           Atom netWmPid = getAtom(\"_NET_WM_PID\");\n           Atom actualType;\n           int actualFormat;\n           unsigned long nItems, bytesAfter;\n           unsigned char* prop = nullptr;\n\n           if (XGetWindowProperty(m_display, hwnd, netWmPid, 0, 1, False,\n                                  XA_CARDINAL, &actualType, &actualFormat,\n                                  &nItems, &bytesAfter, &prop) == Success && prop) {\n               uint32_t pid = *reinterpret_cast<uint32_t*>(prop);\n               XFree(prop);\n               return pid;\n           }\n\n           return 0;  // No PID\n       }\n       ```\n\n    Restrictions:\n    - Do not assume properties exist (check return values)\n    - Do not leak memory (XFree all XGetWindowProperty results)\n    - Do not crash on BadWindow (error handler catches it)\n\n    Success Criteria:\n    - getWindowText() returns actual window titles (tested with xterm, firefox)\n    - getClassName() returns \"XTerm\", \"Navigator\", etc. (correct class, not instance)\n    - getWindowProcessId() returns valid PIDs (verified via ps aux)\n    - No memory leaks after 1000 queries (Valgrind clean)\n    - Unit tests pass (mock X11 server)\n\n    Instructions:\n    1. Search logs: grep -r \"XGetWindowProperty\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Implement property query methods\n    4. Test: Select windows in dialog, verify title/class/PID show real values (not stubs)\n    5. Log with artifacts (functions: getWindowText, getClassName, getWindowProcessId with X11 API details)\n    6. Mark complete\n    ```\n\n- [x] 2.3 Implement window geometry and state queries\n  - Files:\n    - src/platform/linux/window_system_linux_queries.cpp (modify)\n  - Description:\n    - Implement `getWindowRect()`: Use `XGetGeometry()` + `XTranslateCoordinates()` for screen-absolute position\n    - Implement `getShowCommand()`: Check `_NET_WM_STATE` for `_NET_WM_STATE_HIDDEN`, `_NET_WM_STATE_MAXIMIZED_*`\n    - Map X11 states to `WindowShowCmd` enum (Normal, Minimized, Maximized)\n  - _Leverage:\n    - X11 Xlib geometry API\n    - EWMH _NET_WM_STATE property\n  - _Requirements: 1.3, 1.6\n  - _Prompt:\n    ```\n    Role: X11 Window Manager Expert with knowledge of EWMH state management\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Implement geometry and window state queries to support the investigate dialog's window info panel.\n\n    Context:\n    - Dialog needs to show window position (x,y) and size (width, height)\n    - Dialog needs to show window state (Normal, Minimized, Maximized)\n    - X11 coordinates are tricky: XGetGeometry returns parent-relative, need screen-absolute\n\n    Implementation:\n    1. Open src/platform/linux/window_system_linux_queries.cpp\n    2. Implement getWindowRect() (~line 18-24):\n       ```cpp\n       bool WindowSystemLinux::getWindowRect(WindowHandle hwnd, Rect* rect) {\n           if (!m_display || !hwnd || !rect) return false;\n\n           Window root, parent, *children = nullptr;\n           unsigned int nChildren;\n           XWindowAttributes attrs;\n\n           // Get window attributes (size)\n           if (XGetWindowAttributes(m_display, hwnd, &attrs) == 0) {\n               return false;\n           }\n\n           // Get absolute screen position\n           int x, y;\n           Window child;\n           XTranslateCoordinates(m_display, hwnd, m_rootWindow, 0, 0, &x, &y, &child);\n\n           rect->left = x;\n           rect->top = y;\n           rect->right = x + attrs.width;\n           rect->bottom = y + attrs.height;\n\n           return true;\n       }\n       ```\n    3. Implement getShowCommand() (~line 87-90):\n       ```cpp\n       WindowShowCmd WindowSystemLinux::getShowCommand(WindowHandle window) {\n           if (!m_display || !window) return WindowShowCmd::Normal;\n\n           Atom netWmState = getAtom(\"_NET_WM_STATE\");\n           Atom actualType;\n           int actualFormat;\n           unsigned long nItems, bytesAfter;\n           unsigned char* prop = nullptr;\n\n           if (XGetWindowProperty(m_display, window, netWmState, 0, 1024, False,\n                                  XA_ATOM, &actualType, &actualFormat,\n                                  &nItems, &bytesAfter, &prop) != Success || !prop) {\n               return WindowShowCmd::Normal;\n           }\n\n           Atom* states = reinterpret_cast<Atom*>(prop);\n           Atom hiddenAtom = getAtom(\"_NET_WM_STATE_HIDDEN\");\n           Atom maxVert = getAtom(\"_NET_WM_STATE_MAXIMIZED_VERT\");\n           Atom maxHorz = getAtom(\"_NET_WM_STATE_MAXIMIZED_HORZ\");\n\n           bool isHidden = false;\n           bool isMaximized = false;\n\n           for (unsigned long i = 0; i < nItems; i++) {\n               if (states[i] == hiddenAtom) isHidden = true;\n               if (states[i] == maxVert || states[i] == maxHorz) isMaximized = true;\n           }\n\n           XFree(prop);\n\n           if (isHidden) return WindowShowCmd::Minimized;\n           if (isMaximized) return WindowShowCmd::Maximized;\n           return WindowShowCmd::Normal;\n       }\n       ```\n\n    Restrictions:\n    - Do not use relative coordinates (must be screen-absolute for multi-monitor)\n    - Do not assume all windows have _NET_WM_STATE (legacy windows may not)\n    - Handle maximized windows correctly (both vert and horz atoms set)\n\n    Success Criteria:\n    - getWindowRect() returns correct screen-absolute coordinates (tested on multi-monitor setup)\n    - getShowCommand() correctly identifies minimized, maximized, normal states\n    - Minimized windows return Minimized (even if not visible)\n    - Fullscreen windows return Maximized (X11 doesn't distinguish fullscreen state)\n\n    Instructions:\n    1. Search logs: grep -r \"getWindowRect\\|getShowCommand\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Implement geometry and state query methods\n    4. Test: Select windows in different states (normal, minimized, maximized), verify dialog shows correct values\n    5. Log with artifacts (functions: getWindowRect, getShowCommand, X11 coordinate translation)\n    6. Mark complete\n    ```\n\n- [x] 2.4 Implement windowFromPoint for crosshair selection\n  - Files:\n    - src/platform/linux/window_system_linux_hierarchy.cpp (modify)\n  - Description:\n    - Implement `windowFromPoint()`: Use `XQueryPointer()` to get window at cursor position\n    - Handle nested windows (return deepest child window)\n    - Handle unmapped windows, desktops, etc.\n  - _Leverage:\n    - X11 XQueryPointer API\n    - Existing crosshair widget (calls this method)\n  - _Requirements: 1.1, 1.2\n  - _Prompt:\n    ```\n    Role: X11 Windowing Expert with deep knowledge of window hierarchies and pointer queries\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Implement windowFromPoint to support the crosshair window selection feature.\n\n    Context:\n    - CrosshairWidget calls windowFromPoint(cursor position) when user drags cursor\n    - Currently returns nullptr (stub)\n    - Need to query X11 for window at specific screen coordinates\n    - Must return the deepest visible window (not root, not decorations)\n\n    Implementation:\n    1. Open src/platform/linux/window_system_linux_hierarchy.cpp\n    2. Implement windowFromPoint() (~line 14-16):\n       ```cpp\n       WindowHandle WindowSystemLinux::windowFromPoint(const Point& pt) {\n           if (!m_display) return nullptr;\n\n           Window root, child;\n           int rootX, rootY, winX, winY;\n           unsigned int mask;\n\n           // Query pointer to get window at cursor\n           if (!XQueryPointer(m_display, m_rootWindow, &root, &child,\n                              &rootX, &rootY, &winX, &winY, &mask)) {\n               return nullptr;  // Pointer not on this screen\n           }\n\n           // If child is None, pointer is on root window\n           if (child == None) {\n               return m_rootWindow;\n           }\n\n           // Descend to deepest child window\n           Window target = child;\n           while (true) {\n               Window nextRoot, nextChild;\n               int nextX, nextY;\n               unsigned int nextMask;\n\n               if (!XQueryPointer(m_display, target, &nextRoot, &nextChild,\n                                  &rootX, &rootY, &nextX, &nextY, &nextMask)) {\n                   break;  // Can't query further\n               }\n\n               if (nextChild == None) {\n                   break;  // Reached leaf window\n               }\n\n               target = nextChild;\n           }\n\n           return target;\n       }\n       ```\n\n    Restrictions:\n    - Do not return root window (user wants application window, not desktop)\n    - Do not infinite loop if window hierarchy is circular (add max depth limit)\n    - Handle unmapped/invisible windows gracefully\n\n    Success Criteria:\n    - windowFromPoint() returns correct window when cursor over app window\n    - Returns deepest child (e.g., Firefox canvas, not Firefox frame)\n    - Handles multi-monitor setups (cursor on monitor 2 returns windows on monitor 2)\n    - No crashes when cursor over desktop, panel, or invalid windows\n\n    Instructions:\n    1. Search logs: grep -r \"windowFromPoint\\|XQueryPointer\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Implement windowFromPoint with deep traversal\n    4. Test: Use crosshair to select windows, verify correct window highlighted\n    5. Log with artifacts (functions: windowFromPoint, X11 pointer query logic)\n    6. Mark complete\n    ```\n\n### Phase 3: Live Key Event Logging\n\n- [x] 3.1 Add live key event notifications in engine keyboard handler\n  - Files:\n    - src/core/engine/engine.cpp (modify)\n    - src/core/engine/engine.h (modify, add helper method)\n  - Description:\n    - In `keyboardHandler()` method, add check for `m_isInvestigateMode` flag\n    - If enabled, format key event string and send `NtfKeyEvent` via IPC\n    - Format: \"[HH:MM:SS.zzz] KeyName ↓↑\"\n  - _Leverage:\n    - Existing keyboardHandler() in engine.cpp\n    - Existing Key::getName() method\n    - IPC channel from task 1.3\n  - _Requirements: 5.1, 5.2, 5.4, 5.5, 5.6\n  - _Prompt:\n    ```\n    Role: Engine Developer with expertise in input event processing and performance optimization\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Add live key event logging to the engine so the investigate dialog can display a real-time stream of keystrokes.\n\n    Context:\n    - Engine processes key events in keyboardHandler() (engine.cpp, Windows: ~line 25, Linux: similar)\n    - Investigate mode flag `m_isInvestigateMode` is set/cleared by IPC commands (task 1.4)\n    - Need to send IPC notification for every keystroke when investigate mode is active\n    - Must not impact normal remapping latency (<1ms overhead target)\n\n    Implementation:\n    1. Open src/core/engine/engine.h\n    2. Add private helper method declaration:\n       ```cpp\n       private:\n           void sendKeyEventNotification(const Key* key, bool isKeyDown);\n       ```\n    3. Open src/core/engine/engine.cpp\n    4. Find keyboardHandler() method (Windows: ~line 25, Linux: check #ifdef guards)\n    5. Locate input processing loop (where `Key` object is created/processed)\n    6. Add investigate mode check after key is identified but before remapping:\n       ```cpp\n       // Existing code: Key identified, state known\n       bool isPhysicallyPressed = event.isKeyDown;  // Or similar\n\n       // NEW: Send investigate notification if mode enabled\n       if (m_isInvestigateMode && m_ipcChannel && m_ipcChannel->isConnected()) {\n           sendKeyEventNotification(&key, isPhysicallyPressed);\n       }\n\n       // Existing code: Continue with remapping logic...\n       ```\n    7. Implement sendKeyEventNotification() method:\n       ```cpp\n       void Engine::sendKeyEventNotification(const Key* key, bool isKeyDown) {\n           ipc::KeyEventNotification notification;\n\n           // Format timestamp\n           auto now = std::chrono::system_clock::now();\n           auto time_t_now = std::chrono::system_clock::to_time_t(now);\n           auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(\n               now.time_since_epoch()) % 1000;\n           struct tm* t = localtime(&time_t_now);\n\n           char timestamp[16];\n           snprintf(timestamp, sizeof(timestamp), \"%02d:%02d:%02d.%03d\",\n                    t->tm_hour, t->tm_min, t->tm_sec, static_cast<int>(ms.count()));\n\n           // Get key name\n           std::string keyName = key->getName();  // Existing method\n\n           // Format log entry\n           const char* arrow = isKeyDown ? \"↓\" : \"↑\";\n           snprintf(notification.keyEvent, sizeof(notification.keyEvent),\n                    \"[%s] %s %s\", timestamp, keyName.c_str(), arrow);\n\n           // Send IPC notification\n           ipc::Message msg;\n           msg.type = ipc::NtfKeyEvent;\n           msg.data = &notification;\n           msg.size = sizeof(notification);\n           m_ipcChannel->send(msg);\n       }\n       ```\n\n    Restrictions:\n    - Do not send events when m_isInvestigateMode is false (overhead should be zero when dialog closed)\n    - Do not block or wait for IPC send to complete (asynchronous send only)\n    - Do not exceed 256 bytes for event string (notification.keyEvent buffer size)\n    - Keep overhead <1ms (measure with QElapsedTimer if needed)\n\n    Success Criteria:\n    - Key events appear in dialog's live log panel within <10ms of keystroke\n    - No noticeable input lag when investigate mode is active\n    - Zero IPC traffic when dialog is closed (verified via strace)\n    - Log format matches spec: \"[HH:MM:SS.zzz] KeyName ↓↑\"\n    - Rapid typing (50 keys/sec) doesn't drop events or freeze UI\n\n    Instructions:\n    1. Search logs: grep -r \"NtfKeyEvent\\|sendKeyEventNotification\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Implement key event notification in engine.cpp\n    4. Test: Open dialog, press keys, verify live log updates in real-time\n    5. Log with artifacts (functions: sendKeyEventNotification, integrations: \"Engine sends NtfKeyEvent to dialog for each keystroke\")\n    6. Mark complete\n    ```\n\n### Phase 4: Testing and Validation\n\n- [x] 4.1 Write unit tests for WindowSystemLinux property queries\n  - Files:\n    - tests/platform/window_system_linux_test.cpp (new)\n  - Description:\n    - Create mock X11 server for testing\n    - Test getWindowText(), getClassName(), getWindowProcessId(), getWindowRect(), getShowCommand()\n    - Test edge cases: null handles, missing properties, BadWindow errors\n  - _Leverage:\n    - Google Test framework\n    - Mock X11 display (or real Xvfb)\n  - _Requirements: All window query requirements (1.1-1.6, 2.1-2.5)\n  - _Prompt:\n    ```\n    Role: QA Engineer specializing in unit testing and X11 system testing\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Create comprehensive unit tests for all WindowSystemLinux property query methods to ensure correctness and edge case handling.\n\n    Context:\n    - WindowSystemLinux methods query X11 for window properties (implemented in phase 2)\n    - Need to verify correct behavior with various window states and error conditions\n    - Tests should be deterministic and fast (no manual window creation)\n\n    Implementation:\n    1. Create tests/platform/window_system_linux_test.cpp\n    2. Set up test fixture with Xvfb or mock X11 display:\n       ```cpp\n       #include <gtest/gtest.h>\n       #include \"platform/linux/window_system_linux.cpp\"\n       #include <X11/Xlib.h>\n\n       class WindowSystemLinuxTest : public ::testing::Test {\n       protected:\n           Display* display;\n           Window testWindow;\n           WindowSystemLinux* windowSystem;\n\n           void SetUp() override {\n               display = XOpenDisplay(nullptr);\n               ASSERT_NE(nullptr, display);\n\n               // Create test window\n               testWindow = XCreateSimpleWindow(display, DefaultRootWindow(display),\n                                                0, 0, 100, 100, 0, 0, 0);\n\n               windowSystem = new WindowSystemLinux();\n           }\n\n           void TearDown() override {\n               XDestroyWindow(display, testWindow);\n               delete windowSystem;\n               XCloseDisplay(display);\n           }\n\n           void setWindowProperty(Window w, const char* propName, const char* value) {\n               Atom prop = XInternAtom(display, propName, False);\n               Atom type = XInternAtom(display, \"UTF8_STRING\", False);\n               XChangeProperty(display, w, prop, type, 8, PropModeReplace,\n                               reinterpret_cast<const unsigned char*>(value),\n                               strlen(value));\n           }\n       };\n\n       TEST_F(WindowSystemLinuxTest, GetWindowTextReturnsUTF8Title) {\n           setWindowProperty(testWindow, \"_NET_WM_NAME\", \"Test Window\");\n           EXPECT_EQ(\"Test Window\", windowSystem->getWindowText(testWindow));\n       }\n\n       TEST_F(WindowSystemLinuxTest, GetWindowTextHandlesUnicode) {\n           setWindowProperty(testWindow, \"_NET_WM_NAME\", u8\"日本語タイトル\");\n           EXPECT_EQ(u8\"日本語タイトル\", windowSystem->getWindowText(testWindow));\n       }\n\n       TEST_F(WindowSystemLinuxTest, GetClassNameReturnsCorrectClass) {\n           XClassHint classHint;\n           classHint.res_name = const_cast<char*>(\"firefox\");\n           classHint.res_class = const_cast<char*>(\"Navigator\");\n           XSetClassHint(display, testWindow, &classHint);\n\n           EXPECT_EQ(\"Navigator\", windowSystem->getClassName(testWindow));\n       }\n\n       TEST_F(WindowSystemLinuxTest, GetWindowProcessIdReturnsValidPID) {\n           uint32_t myPid = getpid();\n           Atom netWmPid = XInternAtom(display, \"_NET_WM_PID\", False);\n           XChangeProperty(display, testWindow, netWmPid, XA_CARDINAL, 32,\n                           PropModeReplace, reinterpret_cast<unsigned char*>(&myPid), 1);\n\n           EXPECT_EQ(myPid, windowSystem->getWindowProcessId(testWindow));\n       }\n\n       TEST_F(WindowSystemLinuxTest, GetWindowRectReturnsCorrectGeometry) {\n           XMoveResizeWindow(display, testWindow, 100, 200, 300, 400);\n           XMapWindow(display, testWindow);\n           XFlush(display);\n\n           yamy::platform::Rect rect;\n           ASSERT_TRUE(windowSystem->getWindowRect(testWindow, &rect));\n           EXPECT_EQ(300, rect.width());\n           EXPECT_EQ(400, rect.height());\n           // Note: Exact x,y depends on window manager decorations\n       }\n\n       TEST_F(WindowSystemLinuxTest, BadWindowHandlesGracefully) {\n           Window invalidWindow = 0x99999999;\n           EXPECT_EQ(\"\", windowSystem->getWindowText(invalidWindow));\n           EXPECT_EQ(\"\", windowSystem->getClassName(invalidWindow));\n           EXPECT_EQ(0u, windowSystem->getWindowProcessId(invalidWindow));\n       }\n       ```\n    3. Add more tests: null handles, missing properties, maximized/minimized states\n\n    Restrictions:\n    - Tests must run in CI (use Xvfb, not real X server)\n    - Tests must be deterministic (no race conditions)\n    - Do not assume specific window manager behavior\n\n    Success Criteria:\n    - All tests pass on Ubuntu 22.04 + Fedora 39\n    - Code coverage >90% for window_system_linux_queries.cpp\n    - Tests run in <5 seconds total\n    - No X11 resource leaks (Valgrind clean)\n\n    Instructions:\n    1. Search logs: grep -r \"window_system.*test\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Create test file and implement test cases\n    4. Run: ctest --verbose\n    5. Log with artifacts (functions: List all TEST_F cases)\n    6. Mark complete\n    ```\n\n- [x] 4.2 Write unit tests for IPCChannelQt message serialization\n  - Files:\n    - tests/platform/ipc_channel_qt_test.cpp (new)\n  - Description:\n    - Test send/receive round-trip for all message types\n    - Test connection/disconnection handling\n    - Test partial message buffering (message framing)\n    - Test large messages, connection refused, timeout\n  - _Leverage:\n    - Qt Test framework (QTest)\n    - Google Test framework\n  - _Requirements: All IPC requirements (3.1-3.5)\n  - _Prompt:\n    ```\n    Role: Qt Testing Specialist with expertise in IPC and network testing\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Create comprehensive unit tests for IPCChannelQt to verify message serialization, connection handling, and error scenarios.\n\n    Context:\n    - IPCChannelQt uses QLocalSocket/QLocalServer (implemented in task 1.1)\n    - Need to test both client and server modes\n    - Need to verify message framing (4-byte length + data) works correctly\n\n    Implementation:\n    1. Create tests/platform/ipc_channel_qt_test.cpp\n    2. Set up test fixture:\n       ```cpp\n       #include <gtest/gtest.h>\n       #include <QCoreApplication>\n       #include <QLocalServer>\n       #include <QLocalSocket>\n       #include \"core/platform/linux/ipc_channel_qt.h\"\n       #include \"core/ipc_messages.h\"\n\n       class IPCChannelQtTest : public ::testing::Test {\n       protected:\n           QCoreApplication* app;\n           IPCChannelQt* server;\n           IPCChannelQt* client;\n\n           void SetUp() override {\n               int argc = 0;\n               char* argv[] = {nullptr};\n               app = new QCoreApplication(argc, argv);\n\n               server = new IPCChannelQt(\"test-server\");\n               client = new IPCChannelQt(\"test-client\");\n\n               server->listen();\n               client->connect(\"test-server\");\n\n               // Wait for connection\n               QTest::qWait(100);\n           }\n\n           void TearDown() override {\n               delete client;\n               delete server;\n               delete app;\n           }\n       };\n\n       TEST_F(IPCChannelQtTest, ClientConnectsToServer) {\n           ASSERT_TRUE(client->isConnected());\n       }\n\n       TEST_F(IPCChannelQtTest, MessageRoundTrip_InvestigateWindowRequest) {\n           yamy::ipc::InvestigateWindowRequest request;\n           request.hwnd = reinterpret_cast<void*>(0x12345);\n\n           yamy::ipc::Message msg;\n           msg.type = yamy::ipc::CmdInvestigateWindow;\n           msg.data = &request;\n           msg.size = sizeof(request);\n\n           bool received = false;\n           QObject::connect(server, &IPCChannelQt::messageReceived,\n                            [&](const yamy::ipc::Message& receivedMsg) {\n               EXPECT_EQ(yamy::ipc::CmdInvestigateWindow, receivedMsg.type);\n               EXPECT_EQ(sizeof(request), receivedMsg.size);\n               auto* req = static_cast<const yamy::ipc::InvestigateWindowRequest*>(receivedMsg.data);\n               EXPECT_EQ(request.hwnd, req->hwnd);\n               received = true;\n           });\n\n           client->send(msg);\n           QTest::qWait(50);  // Process event loop\n\n           EXPECT_TRUE(received);\n       }\n\n       TEST_F(IPCChannelQtTest, LargeMessageHandling) {\n           // Test message larger than typical socket buffer\n           char largeData[65536] = {0};\n           yamy::ipc::Message msg;\n           msg.type = yamy::ipc::NtfKeyEvent;\n           msg.data = largeData;\n           msg.size = sizeof(largeData);\n\n           bool received = false;\n           QObject::connect(server, &IPCChannelQt::messageReceived,\n                            [&](const yamy::ipc::Message& receivedMsg) {\n               EXPECT_EQ(sizeof(largeData), receivedMsg.size);\n               received = true;\n           });\n\n           client->send(msg);\n           QTest::qWait(100);\n\n           EXPECT_TRUE(received);\n       }\n\n       TEST_F(IPCChannelQtTest, ConnectionRefusedHandling) {\n           IPCChannelQt* failClient = new IPCChannelQt(\"fail-client\");\n           failClient->connect(\"nonexistent-server\");\n\n           QTest::qWait(100);\n           EXPECT_FALSE(failClient->isConnected());\n\n           delete failClient;\n       }\n       ```\n\n    Restrictions:\n    - Tests must use QTest::qWait() to process Qt event loop\n    - Do not use blocking waits (no QEventLoop::exec())\n    - Clean up all QObjects to avoid leaks\n\n    Success Criteria:\n    - All tests pass on Qt 5.12+\n    - Message framing correctly handles partial reads (tested with fragmented sends)\n    - No memory leaks (Valgrind clean)\n    - Tests run in <3 seconds\n\n    Instructions:\n    1. Search logs: grep -r \"IPCChannelQt.*test\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Create test file and implement test cases\n    4. Run: ctest -R ipc_channel_qt_test -V\n    5. Log with artifacts (functions: List all TEST_F cases)\n    6. Mark complete\n    ```\n\n- [x] 4.3 Write integration test for full investigate workflow\n  - Files:\n    - tests/integration/investigate_workflow_test.cpp (new)\n  - Description:\n    - Launch real engine + dialog processes\n    - Simulate window selection via crosshair\n    - Verify all panels populated with correct data\n    - Simulate key presses, verify live log updates\n    - Test IPC disconnection/reconnection\n  - _Leverage:\n    - Xvfb for headless X server\n    - xdotool for simulating input\n    - QTest for Qt event processing\n  - _Requirements: All requirements (end-to-end validation)\n  - _Prompt:\n    ```\n    Role: Integration Test Engineer with expertise in end-to-end system testing and automation\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Create an integration test that validates the complete investigate workflow from window selection to live event logging.\n\n    Context:\n    - Need to test full stack: CrosshairWidget → WindowSystem → IPC → Engine → IPC → Dialog\n    - Test should be automated (no manual intervention)\n    - Should run in CI with Xvfb (headless X server)\n\n    Implementation:\n    1. Create tests/integration/investigate_workflow_test.cpp\n    2. Set up test environment:\n       ```cpp\n       #include <gtest/gtest.h>\n       #include <QApplication>\n       #include <QProcess>\n       #include \"ui/qt/dialog_investigate_qt.h\"\n       #include \"core/engine/engine.h\"\n\n       class InvestigateWorkflowTest : public ::testing::Test {\n       protected:\n           QApplication* app;\n           Engine* engine;\n           DialogInvestigateQt* dialog;\n           Window testWindow;\n\n           void SetUp() override {\n               // Set up Xvfb environment (CI)\n               qputenv(\"DISPLAY\", \":99\");\n\n               int argc = 1;\n               char* argv[] = {const_cast<char*>(\"test\"), nullptr};\n               app = new QApplication(argc, argv);\n\n               // Create test window with known properties\n               Display* display = XOpenDisplay(nullptr);\n               testWindow = XCreateSimpleWindow(display, DefaultRootWindow(display),\n                                                100, 100, 200, 200, 1, 0, 0);\n               Atom netWmName = XInternAtom(display, \"_NET_WM_NAME\", False);\n               const char* title = \"Test Integration Window\";\n               XChangeProperty(display, testWindow, netWmName,\n                               XInternAtom(display, \"UTF8_STRING\", False),\n                               8, PropModeReplace,\n                               reinterpret_cast<const unsigned char*>(title),\n                               strlen(title));\n               XMapWindow(display, testWindow);\n               XFlush(display);\n\n               // Start engine\n               engine = new Engine(...);  // Initialize with test config\n               engine->start();\n\n               // Create dialog\n               dialog = new DialogInvestigateQt(engine);\n               dialog->show();\n\n               QTest::qWait(500);  // Wait for IPC connection\n           }\n\n           void TearDown() override {\n               delete dialog;\n               engine->stop();\n               delete engine;\n               delete app;\n           }\n       };\n\n       TEST_F(InvestigateWorkflowTest, WindowSelectionPopulatesAllPanels) {\n           // Simulate window selection\n           dialog->onWindowSelected(testWindow);\n           QTest::qWait(100);  // Wait for IPC round-trip\n\n           // Verify window info panel\n           EXPECT_EQ(\"Test Integration Window\", dialog->m_labelTitle->text().toStdString());\n           EXPECT_NE(\"(unavailable)\", dialog->m_labelClass->text().toStdString());\n           EXPECT_NE(\"0\", dialog->m_labelProcessPath->text().toStdString());\n\n           // Verify keymap status panel\n           EXPECT_NE(\"(IPC not connected)\", dialog->m_labelKeymapName->text().toStdString());\n           EXPECT_NE(\"-\", dialog->m_labelMatchedRegex->text().toStdString());\n       }\n\n       TEST_F(InvestigateWorkflowTest, LiveKeyEventsAppearInLog) {\n           dialog->onWindowSelected(testWindow);\n           QTest::qWait(100);\n\n           int initialLogLines = dialog->m_liveLog->document()->lineCount();\n\n           // Simulate key press (via xdotool or direct engine injection)\n           // For simplicity, directly inject event into engine\n           yamy::platform::KeyEvent event{65, true, false, 0};  // 'A' key down\n           engine->pushInputEvent(event);\n\n           QTest::qWait(50);  // Wait for IPC notification\n\n           int newLogLines = dialog->m_liveLog->document()->lineCount();\n           EXPECT_GT(newLogLines, initialLogLines);\n\n           QString logText = dialog->m_liveLog->toPlainText();\n           EXPECT_TRUE(logText.contains(\"↓\") || logText.contains(\"↑\"));\n       }\n\n       TEST_F(InvestigateWorkflowTest, IPCReconnectionAfterEngineCrash) {\n           dialog->onWindowSelected(testWindow);\n           QTest::qWait(100);\n\n           EXPECT_TRUE(dialog->m_ipcChannel->isConnected());\n\n           // Simulate engine crash\n           engine->stop();\n           delete engine;\n           engine = nullptr;\n\n           QTest::qWait(600);  // Wait for disconnection detection\n\n           EXPECT_FALSE(dialog->m_ipcChannel->isConnected());\n           EXPECT_EQ(\"(IPC not connected)\", dialog->m_labelKeymapName->text().toStdString());\n\n           // Restart engine\n           engine = new Engine(...);\n           engine->start();\n\n           QTest::qWait(2500);  // Wait for auto-reconnect (2s timer)\n\n           EXPECT_TRUE(dialog->m_ipcChannel->isConnected());\n       }\n       ```\n\n    Restrictions:\n    - Test must run in CI (use Xvfb, not real X server)\n    - Do not rely on specific window manager behavior\n    - Test must be deterministic (no random failures)\n\n    Success Criteria:\n    - Test passes on Ubuntu 22.04 + Fedora 39 (CI)\n    - All assertions pass consistently (10 consecutive runs)\n    - Test completes in <10 seconds\n    - No resource leaks (windows, processes, sockets)\n\n    Instructions:\n    1. Search logs: grep -r \"integration.*test.*investigate\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Create integration test with full workflow\n    4. Run: ctest -R investigate_workflow_test -V\n    5. Log with artifacts (integrations: \"Full E2E workflow from crosshair to live logging\")\n    6. Mark complete\n    ```\n\n- [x] 4.4 Performance benchmarking and optimization\n  - Files:\n    - tests/benchmarks/investigate_performance_test.cpp (new)\n    - tests/benchmarks/README.md (new)\n  - Description:\n    - Measure window property query latency (<10ms target)\n    - Measure IPC round-trip latency (<5ms target)\n    - Measure live event notification latency (<10ms target)\n    - Stress test: 50 keys/sec, verify no dropped events and <5% CPU\n  - _Leverage:\n    - QElapsedTimer for precise timing\n    - perf/ftrace for profiling\n  - _Requirements: All performance requirements (NFR section)\n  - _Prompt:\n    ```\n    Role: Performance Engineer specializing in latency optimization and profiling\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Create performance benchmarks to validate all latency and throughput requirements are met.\n\n    Context:\n    - Requirements specify strict latency targets (<10ms window query, <5ms IPC, <10ms E2E)\n    - Need to measure actual performance and identify bottlenecks\n    - Benchmarks should fail if performance degrades below targets\n\n    Implementation:\n    1. Create tests/benchmarks/investigate_performance_test.cpp\n    2. Implement latency benchmarks:\n       ```cpp\n       #include <gtest/gtest.h>\n       #include <QElapsedTimer>\n       #include \"platform/linux/window_system_linux.cpp\"\n       #include \"core/platform/linux/ipc_channel_qt.h\"\n\n       class InvestigatePerformanceTest : public ::testing::Test {\n       protected:\n           WindowSystemLinux* windowSystem;\n           Display* display;\n           Window testWindow;\n\n           void SetUp() override {\n               display = XOpenDisplay(nullptr);\n               testWindow = XCreateSimpleWindow(display, DefaultRootWindow(display),\n                                                0, 0, 100, 100, 0, 0, 0);\n               XMapWindow(display, testWindow);\n               XFlush(display);\n\n               windowSystem = new WindowSystemLinux();\n           }\n       };\n\n       TEST_F(InvestigatePerformanceTest, WindowPropertyQueryLatency) {\n           QElapsedTimer timer;\n           const int iterations = 100;\n           qint64 totalNs = 0;\n\n           for (int i = 0; i < iterations; i++) {\n               timer.start();\n               std::string title = windowSystem->getWindowText(testWindow);\n               std::string className = windowSystem->getClassName(testWindow);\n               uint32_t pid = windowSystem->getWindowProcessId(testWindow);\n               yamy::platform::Rect rect;\n               windowSystem->getWindowRect(testWindow, &rect);\n               auto state = windowSystem->getShowCommand(testWindow);\n               totalNs += timer.nsecsElapsed();\n           }\n\n           qint64 avgNs = totalNs / iterations;\n           double avgMs = avgNs / 1000000.0;\n\n           std::cout << \"Average window query latency: \" << avgMs << \" ms\" << std::endl;\n           EXPECT_LT(avgMs, 10.0);  // Must be <10ms\n       }\n\n       TEST_F(InvestigatePerformanceTest, IPCRoundTripLatency) {\n           IPCChannelQt server(\"perf-server\");\n           IPCChannelQt client(\"perf-client\");\n\n           server.listen();\n           client.connect(\"perf-server\");\n           QTest::qWait(100);\n\n           QElapsedTimer timer;\n           const int iterations = 100;\n           qint64 totalNs = 0;\n\n           for (int i = 0; i < iterations; i++) {\n               timer.start();\n\n               yamy::ipc::InvestigateWindowRequest request{testWindow};\n               yamy::ipc::Message msg{yamy::ipc::CmdInvestigateWindow, &request, sizeof(request)};\n               client.send(msg);\n\n               // Simulate server response\n               yamy::ipc::InvestigateWindowResponse response;\n               yamy::ipc::Message responsMsg{yamy::ipc::RspInvestigateWindow, &response, sizeof(response)};\n               server.send(responsMsg);\n\n               // Wait for round-trip\n               QTest::qWait(1);\n               totalNs += timer.nsecsElapsed();\n           }\n\n           qint64 avgNs = totalNs / iterations;\n           double avgMs = avgNs / 1000000.0;\n\n           std::cout << \"Average IPC round-trip latency: \" << avgMs << \" ms\" << std::endl;\n           EXPECT_LT(avgMs, 5.0);  // Must be <5ms\n       }\n\n       TEST_F(InvestigatePerformanceTest, StressTest_50KeysPerSecond) {\n           // Simulate rapid key presses\n           // Measure CPU usage and event drop rate\n           // EXPECT <5% CPU, 0 dropped events\n           GTEST_SKIP() << \"Stress test requires real engine process\";\n       }\n       ```\n\n    Restrictions:\n    - Benchmarks must be repeatable (run 100+ iterations)\n    - Do not use sleeps to simulate latency (measure actual operations)\n    - Report P99 latency, not just average\n\n    Success Criteria:\n    - Window query latency <10ms (P99)\n    - IPC round-trip <5ms (P99)\n    - All benchmarks pass consistently\n    - Results logged to build artifacts for tracking\n\n    Instructions:\n    1. Search logs: grep -r \"benchmark.*performance\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Create benchmark tests\n    4. Run: ctest -R investigate_performance_test -V\n    5. Log with artifacts (functions: List benchmark test cases, include performance results)\n    6. Mark complete\n    ```\n\n### Phase 5: Documentation and Cleanup\n\n- [x] 5.1 Update code documentation (Doxygen comments)\n  - Files:\n    - All new/modified files (add /** */ comments to public APIs)\n  - Description:\n    - Add Doxygen comments to all public methods (IPCChannelQt, WindowSystemLinux)\n    - Document parameters, return values, error conditions\n    - Update class-level documentation\n  - _Leverage:\n    - Existing Doxygen comment style\n  - _Requirements: Code quality gates (documentation requirement)\n  - _Prompt:\n    ```\n    Role: Documentation Specialist with C++ and Doxygen expertise\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Add comprehensive Doxygen documentation to all public APIs created/modified in this spec.\n\n    Context:\n    - New classes: IPCChannelQt, expanded WindowSystemLinux methods\n    - Modified classes: Engine (IPC connection, key event logging)\n    - Need to document parameters, return values, error handling, thread safety\n\n    Implementation:\n    1. For each public method, add Doxygen comment:\n       ```cpp\n       /**\n        * @brief Connects to a named IPC server using Unix domain socket\n        *\n        * Initiates asynchronous connection to the specified IPC server.\n        * The connection is non-blocking; use isConnected() or wait for\n        * the connected() signal to verify successful connection.\n        *\n        * @param name Server name (e.g., \"yamy-engine\")\n        *             Socket path will be /tmp/yamy-{name}-{UID}\n        *\n        * @note This method does not block. Connection happens asynchronously.\n        * @note If already connected, this method disconnects first.\n        *\n        * @see isConnected(), disconnected() signal\n        */\n       void IPCChannelQt::connect(const std::string& name);\n       ```\n    2. Document all new classes:\n       ```cpp\n       /**\n        * @class IPCChannelQt\n        * @brief Qt-based IPC channel using Unix domain sockets\n        *\n        * Implements IIPCChannel interface for Linux using QLocalSocket (client)\n        * and QLocalServer (server) for inter-process communication between\n        * the Qt GUI and the engine process.\n        *\n        * Thread Safety: All operations are thread-safe via Qt's queued connections.\n        *\n        * Example Usage:\n        * @code\n        * IPCChannelQt channel(\"my-client\");\n        * connect(&channel, &IPCChannelQt::messageReceived, this, &MyClass::onMessage);\n        * channel.connect(\"yamy-engine\");\n        * @endcode\n        */\n       class IPCChannelQt : public IIPCChannel { ... };\n       ```\n    3. Update modified methods with @note for behavior changes\n\n    Restrictions:\n    - Follow existing Doxygen style (see window_system_interface.h)\n    - Document error conditions (what happens if display is null, etc.)\n    - Do not document private methods (internal implementation)\n\n    Success Criteria:\n    - Doxygen generates HTML without warnings\n    - All public APIs have /** */ comments\n    - Examples included for complex APIs (IPC, window queries)\n    - Thread safety documented where relevant\n\n    Instructions:\n    1. Search logs: grep -r \"Doxygen\\|documentation\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Add Doxygen comments to all modified files\n    4. Run: doxygen Doxyfile (check for warnings)\n    5. Log with artifacts (files: List all files with updated documentation)\n    6. Mark complete\n    ```\n\n- [x] 5.2 Update CHANGELOG.md and user documentation\n  - Files:\n    - CHANGELOG.md (add entry for investigate window feature)\n    - docs/LINUX-QT-GUI-MANUAL.md (update with investigate dialog usage)\n  - Description:\n    - Document new functionality in CHANGELOG\n    - Add user guide section on how to use investigate window feature\n    - Include screenshots (optional, describe UI panels)\n  - _Leverage:\n    - Existing CHANGELOG format\n    - Existing user guide structure\n  - _Requirements: Usability (documentation for users)\n  - _Prompt:\n    ```\n    Role: Technical Writer specializing in user documentation and release notes\n\n    Task: Implement the task for spec investigate-window, first run spec-workflow-guide to get the workflow guide then implement the task:\n\n    Update user-facing documentation to describe the investigate window feature and how to use it for debugging.\n\n    Context:\n    - CHANGELOG.md tracks all user-visible changes\n    - docs/LINUX-QT-GUI-MANUAL.md is the main user guide for Qt GUI\n    - Need to explain what the feature does and how to use it\n\n    Implementation:\n    1. Update CHANGELOG.md:\n       ```markdown\n       ## [Unreleased]\n\n       ### Added\n       - **Investigate Window Feature (Linux Qt GUI)**: Real-time debugging tool for inspecting window properties and keymap status\n         - Crosshair window selection tool (click \"Investigate Window\" in tray menu)\n         - Window info panel: displays title, class, process name/path, geometry, state\n         - Keymap status panel: shows active keymap, matched regex patterns, modifier state\n         - Live key event log: real-time stream of key presses/releases with timestamps\n         - IPC communication between GUI and engine for real-time status updates\n         - Useful for debugging .mayu configurations (e.g., \"why isn't my C-x binding working in Emacs?\")\n\n       ### Fixed\n       - Window property queries now return real data (not stubs) on Linux\n       - IPC channel now functional (was stub returning \"not connected\")\n       - Engine now sends keymap status responses to investigate dialog\n       ```\n    2. Update docs/LINUX-QT-GUI-MANUAL.md:\n       ```markdown\n       ## Investigate Window (Debug Tool)\n\n       The Investigate Window feature helps you debug your .mayu configuration by showing:\n       - Which window YAMY sees when you select it\n       - Which keymap is active for that window\n       - Why a particular regex matched (or didn't match)\n       - Real-time stream of key events as you type\n\n       ### How to Use\n\n       1. **Open the Investigate Dialog**:\n          - Right-click the YAMY tray icon\n          - Select \"Investigate Window\" from menu\n          - Dialog window opens\n\n       2. **Select a Window**:\n          - Click \"Select Window\" button\n          - Crosshair cursor appears\n          - Drag crosshair over target window\n          - Release mouse button to select\n\n       3. **View Window Information**:\n          - **Window Information Panel** (left):\n            - Handle: Unique window ID (hex)\n            - Title: Window title as seen by YAMY\n            - Class: Window class name (for .mayu window rules)\n            - Process: Application process name\n            - Path: Full path to executable\n            - Geometry: Screen position and size\n            - State: Normal, Minimized, or Maximized\n\n       4. **View Keymap Status** (right):\n          - **Keymap**: Name of active keymap (or \"(global keymap)\")\n          - **Matched Regex**: Class/title patterns that matched\n          - **Modifiers**: Current modifier state (Shift, Ctrl, Alt, etc.)\n\n       5. **Monitor Live Key Events**:\n          - Press keys while window is selected\n          - Events appear in log panel: `[HH:MM:SS.zzz] KeyName ↓↑`\n          - Verify your bindings are being captured correctly\n\n       ### Troubleshooting\n\n       - **\"(IPC not connected)\"**: Engine is not running. Start `yamy_stub`.\n       - **Panels show \"-\"**: No window selected yet. Click \"Select Window\".\n       - **No live events**: Make sure dialog is still open (closing disables logging).\n\n       ### Example: Debug Emacs Binding\n\n       Problem: \"My C-x doesn't work in Emacs, why?\"\n\n       1. Open investigate dialog\n       2. Select Emacs window\n       3. Check \"Keymap\" field: Should show \"Emacs\" (not \"Global\")\n          - If shows \"Global\", your window rule didn't match\n          - Check \"Matched Regex\" to see what YAMY sees\n       4. Press C-x\n       5. Check live log: Should show \"[HH:MM:SS] C-x ↓\"\n          - If shows different key, your binding has a typo in .mayu\n       ```\n\n    Restrictions:\n    - Use clear, non-technical language (user guide, not developer docs)\n    - Include examples (debugging scenarios)\n    - Do not document internal implementation details\n\n    Success Criteria:\n    - CHANGELOG entry describes user-visible features\n    - User guide explains how to use all panels\n    - Troubleshooting section addresses common issues\n    - No technical jargon (class names, IPC, etc.)\n\n    Instructions:\n    1. Search logs: grep -r \"CHANGELOG\\|user.*doc\" .spec-workflow/specs/*/Implementation\\ Logs/\n    2. Mark in progress\n    3. Update CHANGELOG.md and user guide\n    4. Review: Have another developer read for clarity\n    5. Log with artifacts (files: CHANGELOG.md, docs/LINUX-QT-GUI-MANUAL.md)\n    6. Mark complete\n    ```\n\n---\n\n**Document Version**: 1.0\n**Created**: 2025-12-14\n**Status**: Pending Approval\n**Total Tasks**: 18 (5 phases)\n**Estimated Effort**: 40-60 hours\n",
  "fileStats": {
    "size": 66021,
    "lines": 1610,
    "lastModified": "2025-12-14T04:12:51.238Z"
  },
  "comments": []
}