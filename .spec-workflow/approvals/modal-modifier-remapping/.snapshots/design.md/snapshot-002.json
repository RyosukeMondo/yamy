{
  "id": "snapshot_1765698781826_qoxa8trhk",
  "approvalId": "approval_1765686808486_5oahc8q2p",
  "approvalTitle": "Design: Modal Modifier Remapping",
  "version": 2,
  "timestamp": "2025-12-14T07:53:01.826Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Modal Modifier Remapping\n\n## Overview\n\nThis design implements modal modifier remapping for the YAMY keyboard remapper on Linux, enabling hold-vs-tap detection and modal layer activation. The system allows any key to function as both a regular key (when tapped) and a modifier layer trigger (when held), providing QMK-like functionality in software.\n\n**Core Innovation**: Unified event processing pipeline that seamlessly integrates hold detection, modifier state tracking, and keymap matching without special-casing or performance degradation.\n\n**Place in System**: This feature bridges the configuration layer (parsed .may u files) and the runtime engine (event processing pipeline), transforming static modal modifier definitions into dynamic hold-detection state machines.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Architecture Layers** (tech.md Section: Architecture Layers):\n- **Layer 1: Platform Abstraction** - No changes (evdev/uinput already abstract)\n- **Layer 2: Core Engine** - PRIMARY FOCUS\n  - Extend `engine_event_processor.cpp` with modifier detection\n  - New component: `modifier_key_handler.cpp` (hold/tap state machine)\n  - Extend `engine_modifier.cpp` with modal modifier state tracking\n- **Layer 3: UI Layer** - Minimal changes (config loading feedback only)\n\n**Threading Model** (tech.md Section: Threading Model):\n- Linux: Single-threaded (Qt event loop + engine)\n- Hold detection uses monotonic clock, not separate thread\n- Timer-based events handled via Qt timer (QTimer for threshold checks)\n\n**Performance Targets** (tech.md Section: Performance Considerations):\n```\nCritical Path: evdev read (100μs) + Hold Detection (10μs) + Lookup (10μs) + Execute (100μs) = 220μs\nTarget: <1ms P99 (2200μs total budget, 220μs average)\n```\n\n**Dependency Management**:\n```\nModifierKeyHandler (zero deps)\n  ↑\nEventProcessor (depends on handler interface only)\n  ↑\nEngine (orchestrates both)\n```\n\n### Project Structure (structure.md)\n\n**File Placement** (structure.md Section: Directory Layout):\n```\nsrc/core/engine/\n├── modifier_key_handler.h/.cpp      # NEW: Hold/tap state machine\n├── engine_event_processor.cpp       # MODIFIED: Integration point\n├── engine_modifier.cpp               # MODIFIED: Modal modifier state\n├── engine_setting.cpp                # MODIFIED: Config → runtime setup\n\nsrc/core/settings/\n└── setting_loader.cpp                # MODIFIED: Connect mod definitions to handlers\n\ntests/\n├── test_modifier_key_handler.cpp    # NEW: Unit tests (25 tests)\n└── test_modal_integration.cpp       # NEW: Integration tests (30 tests)\n```\n\n**Naming Conventions** (structure.md Section: Coding Conventions):\n- Files: `modifier_key_handler.cpp` (snake_case)\n- Classes: `ModifierKeyHandler` (PascalCase)\n- Functions: `processNumberKey()` (camelCase)\n- Member variables: `m_modifierStates` (m_ prefix)\n- Parameters: `i_yamaCode`, `o_result` (i_/o_ prefix)\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**1. ModifierKeyHandler Class** (`src/core/engine/modifier_key_handler.cpp`)\n- **Status**: Fully implemented but NEVER INSTANTIATED\n- **Reuse**: Use as-is, only add integration hooks\n- **API**:\n  ```cpp\n  class ModifierKeyHandler {\n  public:\n      void registerNumberModifier(uint16_t numberKey, uint16_t modifierKey);\n      NumberKeyResult processNumberKey(uint16_t yama_code, EventType type);\n      bool isNumberModifier(uint16_t yama_code) const;\n  };\n  ```\n- **Value**: 100% of hold/tap logic already tested and working\n\n**2. EventProcessor Class** (`src/core/engine/engine_event_processor.cpp`)\n- **Status**: Implements Layer 2 substitution, no modifier detection\n- **Extend**: Add modifier detection before substitution lookup\n- **Current flow**:\n  ```cpp\n  uint16_t layer2_applySubstitution(uint16_t yama_in) {\n      auto it = m_substitutions.find(yama_in);\n      return (it != end) ? it->second : yama_in;\n  }\n  ```\n- **Enhanced flow**:\n  ```cpp\n  uint16_t layer2_applySubstitution(uint16_t yama_in, EventType type) {\n      // NEW: Check modifier detection first\n      if (m_modifierHandler && m_modifierHandler->isNumberModifier(yama_in)) {\n          auto result = m_modifierHandler->processNumberKey(yama_in, type);\n          if (result.action == WAITING) return 0;  // Suppress\n          if (result.action == ACTIVATE) {\n              updateModifierState(result.modifierType, true);\n              return result.output_yama_code;\n          }\n          // Else TAP -> fall through to substitution\n      }\n      // Existing substitution logic\n  }\n  ```\n\n**3. Modifier State Tracking** (`src/core/engine/engine_modifier.cpp`)\n- **Status**: Tracks standard modifiers (Shift, Ctrl, Alt, Win)\n- **Extend**: Add modal modifier bitmask (mod0-mod19)\n- **Current structure**:\n  ```cpp\n  struct ModifierState {\n      bool shift, ctrl, alt, win;  // Standard modifiers\n  };\n  ```\n- **Enhanced structure**:\n  ```cpp\n  struct ModifierState {\n      uint8_t standard;     // Bit flags: Shift(1), Ctrl(2), Alt(4), Win(8)\n      uint32_t modal;       // Bit flags: mod0(1), mod1(2), ..., mod19(1<<19)\n\n      bool isActive(Modifier::Type type) const {\n          if (type >= Type_Mod0 && type <= Type_Mod19) {\n              return modal & (1 << (type - Type_Mod0));\n          }\n          // Standard modifier check\n      }\n  };\n  ```\n\n**4. Keymap Lookup** (`src/core/input/keymap.cpp`)\n- **Status**: Supports modifier prefixes in keymap entries\n- **Reuse**: Modify hash key generation to include modal modifiers\n- **Current hash**:\n  ```cpp\n  uint32_t hash = (modifiers << 16) | scancode;\n  // modifiers = Shift(1) | Ctrl(2) | Alt(4) | Win(8)\n  ```\n- **Enhanced hash**:\n  ```cpp\n  uint64_t hash = ((uint64_t)modal_modifiers << 32) | (standard_modifiers << 16) | scancode;\n  // Supports 20 modal + 8 standard modifiers + 16-bit scancode\n  ```\n\n**5. Setting Loader** (`src/core/settings/setting_loader.cpp`)\n- **Status**: Parses `mod modX = !!key` and `def numbermod` but doesn't register handlers\n- **Extend**: Add registration calls after parsing\n- **Current**:\n  ```cpp\n  void load_DEFINE_NUMBER_MODIFIER() {\n      // Parse: def numbermod *_1 = *LShift\n      uint16_t numberKey = parseKey();\n      uint16_t modifierKey = parseKey();\n      m_setting->m_keyboard.addNumberModifier(numberKey, modifierKey);\n      // STOPS HERE - never reaches engine\n  }\n  ```\n- **Enhanced**:\n  ```cpp\n  void load_DEFINE_NUMBER_MODIFIER() {\n      // ... existing parsing ...\n      m_setting->m_keyboard.addNumberModifier(numberKey, modifierKey);\n\n      // NEW: Also notify engine for runtime registration\n      if (m_engine) {\n          m_engine->getEventProcessor()->registerNumberModifier(numberKey, modifierKey);\n      }\n  }\n  ```\n\n### Integration Points\n\n**1. Engine Initialization** (`src/core/engine/engine.cpp`)\n- **Hook**: `Engine::loadSetting()`\n- **Action**: Create ModifierKeyHandler and pass to EventProcessor\n- **Code**:\n  ```cpp\n  void Engine::loadSetting(const Setting& setting) {\n      // Existing code...\n\n      // NEW: Create modifier handler\n      auto modifierHandler = std::make_unique<ModifierKeyHandler>();\n\n      // NEW: Register all modal modifiers from config\n      for (const auto& modalMod : setting.m_keyboard.getModalModifiers()) {\n          modifierHandler->registerNumberModifier(\n              modalMod.triggerKey,\n              modalMod.modifierType\n          );\n      }\n\n      // NEW: Register all number modifiers from config\n      for (const auto& numMod : setting.m_keyboard.getNumberModifiers()) {\n          modifierHandler->registerNumberModifier(\n              numMod.m_numberKey->getScanCodes()[0].m_scan,\n              numMod.m_modifierKey->getScanCodes()[0].m_scan\n          );\n      }\n\n      // NEW: Pass handler to event processor\n      m_eventProcessor->setModifierHandler(std::move(modifierHandler));\n  }\n  ```\n\n**2. Event Processing** (`src/core/engine/engine_event_processor.cpp`)\n- **Hook**: `EventProcessor::layer2_applySubstitution()`\n- **Action**: Check modifier detection before substitution\n- **Flow**: See \"Existing Components to Leverage\" section above\n\n**3. Keymap Matching** (`src/core/input/keymap.cpp`)\n- **Hook**: `Keymap::lookup()`\n- **Action**: Include modal modifiers in hash key\n- **Code**:\n  ```cpp\n  Action* Keymap::lookup(const ModifiedKey& mkey, const ModifierState& modState) {\n      uint64_t hash = buildHashKey(mkey.m_key, mkey.m_modifiers, modState.modal);\n      auto it = m_bindings.find(hash);\n      if (it != m_bindings.end()) return it->second;\n\n      // Fallback: Try without modal modifiers\n      uint64_t fallback_hash = buildHashKey(mkey.m_key, mkey.m_modifiers, 0);\n      return m_bindings[fallback_hash];  // May be nullptr\n  }\n  ```\n\n## Architecture\n\n### Design Principles\n\n**1. Single Responsibility**\n- ModifierKeyHandler: Hold/tap detection ONLY (no event injection, no keymap lookup)\n- EventProcessor: Pipeline orchestration ONLY (delegates to handlers)\n- ModifierState: State storage ONLY (no logic, pure data)\n\n**2. Dependency Inversion**\n- Engine depends on `IModifierHandler` interface (not concrete class)\n- EventProcessor depends on interface, not implementation\n- Allows mocking for unit tests\n\n**3. Open/Closed Principle**\n- EventProcessor is open for extension (add handlers) but closed for modification (core logic unchanged)\n- Adding new modifier types doesn't require changing existing code\n\n**4. Zero Special Cases**\n- mod0 through mod19 use identical code paths (loop with index)\n- Hardware modifiers and modal modifiers share state tracking interface\n- Tap and hold both processed via `processNumberKey()` (unified entry point)\n\n### Component Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Configuration Layer\"\n        MAYU[.mayu File]\n        Parser[SettingLoader]\n        Setting[Setting Object]\n    end\n\n    subgraph \"Runtime Layer\"\n        Engine[Engine]\n        EventProc[EventProcessor]\n        ModHandler[ModifierKeyHandler]\n        ModState[ModifierState]\n        Keymap[Keymap]\n    end\n\n    subgraph \"Platform Layer\"\n        evdev[evdev Input]\n        uinput[uinput Output]\n    end\n\n    MAYU -->|parse| Parser\n    Parser -->|creates| Setting\n    Setting -->|loads| Engine\n\n    Engine -->|creates| EventProc\n    Engine -->|creates| ModHandler\n    Engine -->|initializes| ModState\n\n    evdev -->|input events| Engine\n    Engine -->|layer 1| EventProc\n    EventProc -->|check| ModHandler\n    ModHandler -->|TAP/HOLD| EventProc\n    EventProc -->|update| ModState\n    EventProc -->|lookup| Keymap\n    Keymap -->|action| Engine\n    Engine -->|output| uinput\n```\n\n### State Machine: Hold vs Tap Detection\n\n```mermaid\nstateDiagram-v2\n    [*] --> IDLE\n    IDLE --> PRESS : Key Down\n    PRESS --> WAITING : Start Timer\n    WAITING --> TAP_DETECTED : Key Up (< 200ms)\n    WAITING --> MODIFIER_ACTIVE : Threshold Reached (≥ 200ms)\n    TAP_DETECTED --> IDLE : Apply Substitution\n    MODIFIER_ACTIVE --> WAITING_RELEASE : Continue Holding\n    WAITING_RELEASE --> DEACTIVATE : Key Up\n    DEACTIVATE --> IDLE : Clear Modifier State\n```\n\n**State Descriptions**:\n- **IDLE**: No modifier key is pressed\n- **PRESS**: Modifier key just went down, timer not yet started\n- **WAITING**: Timer running, waiting to reach 200ms threshold\n- **TAP_DETECTED**: Key released before threshold → treat as normal key\n- **MODIFIER_ACTIVE**: Threshold reached → modifier activated\n- **WAITING_RELEASE**: Modifier active, waiting for key up\n- **DEACTIVATE**: Key released, deactivating modifier\n\n**Timing Diagram**:\n```\nTime (ms):    0    50   100  150  200  250  300\n              |    |    |    |    |    |    |\nTap Case:     DOWN------UP   |    |    |    |\nState:        PRESS→WAIT→TAP  |    |    |    |\nOutput:       (wait) → Apply Substitution\n\nHold Case:    DOWN----------------------UP   |\nState:        PRESS→WAIT→ACTIVE→WAIT_REL→IDLE\nOutput:       (suppress)→Activate Mod9→Deactivate\n```\n\n## Components and Interfaces\n\n### Component 1: ModifierKeyHandler\n\n**Purpose**: Manage hold/tap detection state machine for modal and number modifier keys\n\n**Interfaces**:\n```cpp\nclass ModifierKeyHandler {\npublic:\n    struct NumberKeyResult {\n        ProcessingAction action;     // WAITING, TAP, ACTIVATE, DEACTIVATE\n        uint16_t output_yama_code;  // VK code for hardware modifier\n        Modifier::Type modifierType; // Type_Mod0..Mod19 or Type_Shift, etc.\n    };\n\n    // Register a key as modal or number modifier\n    void registerNumberModifier(uint16_t numberKey, uint16_t modifierKey);\n\n    // Process incoming key event (DOWN/UP)\n    NumberKeyResult processNumberKey(uint16_t yama_code, EventType type);\n\n    // Query methods\n    bool isNumberModifier(uint16_t yama_code) const;\n    bool isWaitingForThreshold(uint16_t yama_code) const;\n\nprivate:\n    struct KeyState {\n        std::chrono::steady_clock::time_point pressTime;\n        uint16_t modifierKey;  // Target hardware modifier VK code\n        bool isWaiting;\n    };\n\n    std::unordered_map<uint16_t, KeyState> m_keyStates;  // Tracked keys\n    static constexpr int THRESHOLD_MS = 200;\n};\n```\n\n**Dependencies**: None (zero external deps)\n\n**Reuses**: Existing implementation at `src/core/engine/modifier_key_handler.cpp` (100% complete)\n\n### Component 2: EventProcessor (Enhanced)\n\n**Purpose**: Orchestrate 3-layer event processing pipeline with modifier detection\n\n**Interfaces**:\n```cpp\nclass EventProcessor {\npublic:\n    // Constructor\n    EventProcessor(const SubstitutionTable& substitutions);\n\n    // Set modifier handler (ownership transfer)\n    void setModifierHandler(std::unique_ptr<IModifierHandler> handler);\n\n    // Register number modifier (called during config load)\n    void registerNumberModifier(uint16_t numberKey, uint16_t modifierKey);\n\n    // Process event through 3 layers\n    uint16_t process Event(uint16_t evdev_code, EventType type, ModifierState* io_modState);\n\nprivate:\n    // Layer implementations\n    uint16_t layer1_evdevToYamy(uint16_t evdev_code);\n    uint16_t layer2_applyModifierAndSubstitution(uint16_t yama_code, EventType type, ModifierState* io_modState);\n    uint16_t layer3_yamyToEvdev(uint16_t yama_code);\n\n    // Helper\n    void updateModifierState(Modifier::Type type, bool activate, ModifierState* io_state);\n\n    std::unique_ptr<IModifierHandler> m_modifierHandler;\n    const SubstitutionTable& m_substitutions;\n};\n```\n\n**Dependencies**:\n- `IModifierHandler` interface (abstract, mockable)\n- `ModifierState` struct (data only)\n- `SubstitutionTable` (existing)\n\n**Reuses**: Existing EventProcessor at `src/core/engine/engine_event_processor.cpp` (extend `layer2` method)\n\n### Component 3: ModifierState (Enhanced)\n\n**Purpose**: Track active state of all modifiers (standard + modal)\n\n**Interfaces**:\n```cpp\nstruct ModifierState {\n    uint8_t standard;   // Shift(1), Ctrl(2), Alt(4), Win(8)\n    uint32_t modal;     // mod0(1), mod1(2), ..., mod19(1<<19)\n\n    // Query methods\n    bool isActive(Modifier::Type type) const;\n    uint32_t getActiveBitmask() const;  // For keymap hash\n\n    // Mutators (called by EventProcessor only)\n    void activate(Modifier::Type type);\n    void deactivate(Modifier::Type type);\n    void clear();  // Reset all modifiers\n};\n```\n\n**Dependencies**: `Modifier::Type` enum (existing)\n\n**Reuses**: Existing modifier tracking in `src/core/engine/engine_modifier.cpp` (extend with modal field)\n\n### Component 4: Keymap (Enhanced)\n\n**Purpose**: Match key combinations including modal modifiers\n\n**Interfaces**:\n```cpp\nclass Keymap {\npublic:\n    // Existing method signature enhanced\n    Action* lookup(const ModifiedKey& mkey, const ModifierState& modState);\n\nprivate:\n    // Enhanced hash key generation (64-bit)\n    uint64_t buildHashKey(Key* key, uint8_t standard_mods, uint32_t modal_mods);\n\n    std::unordered_map<uint64_t, Action*> m_bindings;\n};\n```\n\n**Dependencies**:\n- `ModifierState` struct\n- `ModifiedKey` class (existing)\n\n**Reuses**: Existing Keymap at `src/core/input/keymap.cpp` (extend hash key generation)\n\n## Data Models\n\n### Model 1: KeyState (Internal to ModifierKeyHandler)\n\n```cpp\nstruct KeyState {\n    std::chrono::steady_clock::time_point pressTime;  // When key went down\n    uint16_t modifierKey;                             // Target VK code (e.g., VK_LSHIFT)\n    Modifier::Type modifierType;                      // Type_Mod9, Type_Shift, etc.\n    bool isWaiting;                                   // Waiting for threshold?\n    bool isActive;                                    // Modifier currently active?\n};\n```\n\n**Lifecycle**:\n1. Created when key down event received\n2. Updated when threshold reached or key released\n3. Destroyed when key up processed and state cleared\n\n### Model 2: NumberModifierDefinition (Config Layer)\n\n```cpp\nstruct NumberModifierDefinition {\n    Key* m_numberKey;      // Trigger key (e.g., A, _1)\n    Key* m_modifierKey;    // Target modifier (e.g., LShift, for hardware mods)\n    Modifier::Type m_type; // Type_Mod9 (for modal mods) or Type_Shift (for hardware)\n};\n```\n\n**Storage**: `Keyboard::m_numberModifiers` (list)\n\n**Transformation**:\n```\nConfig Parse → NumberModifierDefinition → Engine Registration → ModifierKeyHandler\n```\n\n### Model 3: ModifierState (Runtime State)\n\n```cpp\nstruct ModifierState {\n    uint8_t standard;   // Bits: Shift(1), Ctrl(2), Alt(4), Win(8)\n    uint32_t modal;     // Bits: mod0(1), mod1(2), ..., mod19(1<<19)\n\n    // Derived properties\n    bool hasStandardModifiers() const { return standard != 0; }\n    bool hasModalModifiers() const { return modal != 0; }\n    int countActiveModifiers() const {\n        return __builtin_popcount(standard) + __builtin_popcount(modal);\n    }\n};\n```\n\n**Lifecycle**:\n- Initialized to all zeros on engine start\n- Updated on every modifier activation/deactivation\n- Copied/passed to keymap lookup (read-only)\n- Cleared on keymap change or explicit reset\n\n## Error Handling\n\n### Error Scenarios\n\n**1. Invalid Modal Modifier Index**\n- **Trigger**: User defines `mod mod25 = !!A` (exceeds mod19)\n- **Detection**: Parser validates index during `load_MODIFIER_ASSIGNMENT()`\n- **Handling**: Reject with error message, do not load configuration\n- **User Impact**: Clear error message with line number and valid range\n\n**2. Hardware Modifier as Modal Trigger**\n- **Trigger**: User defines `mod mod9 = !!LShift`\n- **Detection**: Parser checks if key is hardware modifier (VK_SHIFT, VK_CONTROL, etc.)\n- **Handling**: Warn and skip (non-fatal), log warning\n- **User Impact**: Modal modifier ignored, warning in log\n\n**3. Timer System Failure**\n- **Trigger**: `std::chrono::steady_clock::now()` throws or returns invalid time\n- **Detection**: Exception handler in `ModifierKeyHandler::processNumberKey()`\n- **Handling**: Disable hold detection for that key, log error, fallback to tap-only mode\n- **User Impact**: Key works as normal (substitution), no hold detection\n\n**4. Modifier State Overflow**\n- **Trigger**: More than 20 modal modifiers somehow activated (bug or attack)\n- **Detection**: Check bitmask size before activation\n- **Handling**: Log critical error, refuse activation, cap at 20\n- **User Impact**: Extra modifiers beyond mod19 are ignored\n\n**5. Config Reload While Modifiers Active**\n- **Trigger**: User reloads .mayu file while holding modal modifier keys\n- **Detection**: Engine checks if modifiers are active during `loadSetting()`\n- **Handling**: Preserve state if new config still defines same modifiers, else reset all\n- **User Impact**: Modifiers remain active if config valid, else released gracefully\n\n## Testing Strategy\n\n### Unit Testing\n\n**ModifierKeyHandler Tests** (25 tests):\n\n**Test Suite 1: Hold Detection State Machine** (10 tests)\n```cpp\nTEST(ModifierKeyHandlerTest, IdleToPress) {\n    // Verify state transition on key down\n}\n\nTEST(ModifierKeyHandlerTest, TapDetectedWhenReleasedBeforeThreshold) {\n    // Key released at 50ms → TAP_DETECTED\n}\n\nTEST(ModifierKeyHandlerTest, ModifierActiveWhenThresholdReached) {\n    // Key held for 250ms → MODIFIER_ACTIVE\n}\n\nTEST(ModifierKeyHandlerTest, ThresholdAccuracyWithinTolerance) {\n    // Verify ±5ms accuracy\n}\n\nTEST(ModifierKeyHandlerTest, MultipleKeysIndependent) {\n    // A and B tracked independently\n}\n```\n\n**Test Suite 2: Edge Cases** (10 tests)\n```cpp\nTEST(ModifierKeyHandlerTest, RapidTapTapHold) {\n    // Tap, tap, hold sequence handled correctly\n}\n\nTEST(ModifierKeyHandlerTest, HoldReleaseHold) {\n    // Hold, release, hold again\n}\n\nTEST(ModifierKeyHandlerTest, SimultaneousKeyPress) {\n    // A and B pressed at same instant\n}\n\nTEST(ModifierKeyHandlerTest, TimerWrapAround) {\n    // Handle steady_clock wrapping (unlikely but possible)\n}\n\nTEST(ModifierKeyHandlerTest, UnregisteredKeyPassthrough) {\n    // Non-modifier key returns APPLY_SUBSTITUTION\n}\n```\n\n**Test Suite 3: Configuration** (5 tests)\n```cpp\nTEST(ModifierKeyHandlerTest, RegisterNumberModifier) {\n    // Successfully register number modifier\n}\n\nTEST(ModifierKeyHandlerTest, IsNumberModifierQuery) {\n    // Query returns correct result\n}\n\nTEST(ModifierKeyHandlerTest, DuplicateRegistration) {\n    // Re-registering same key updates mapping\n}\n\nTEST(ModifierKeyHandlerTest, MaxModifiersLimit) {\n    // 100 number modifiers (stress test)\n}\n```\n\n**ModifierState Tests** (15 tests):\n\n```cpp\nTEST(ModifierStateTest, ActivateSingleModifier) {\n    ModifierState state;\n    state.activate(Modifier::Type_Mod9);\n    EXPECT_TRUE(state.isActive(Modifier::Type_Mod9));\n}\n\nTEST(ModifierStateTest, DeactivateModifier) {\n    // activate → deactivate → verify inactive\n}\n\nTEST(ModifierStateTest, MultipleConcurrentModifiers) {\n    // Activate mod9, mod8, mod5 → all active\n}\n\nTEST(ModifierStateTest, BitmaskCorrect) {\n    // Verify bitmask matches activated modifiers\n}\n\nTEST(ModifierStateTest, StandardAndModalCombined) {\n    // Ctrl + mod9 both active\n}\n```\n\n**Keymap Lookup Tests** (20 tests):\n\n```cpp\nTEST(KeymapTest, LookupWithModalModifier) {\n    // m9-*X matches correctly\n}\n\nTEST(KeymapTest, LookupWithStandardAndModal) {\n    // *C-m9-*X matches\n}\n\nTEST(KeymapTest, FallbackToNonModal) {\n    // m9 active but no m9- entry → fallback to standard\n}\n\nTEST(KeymapTest, PriorityOrdering) {\n    // More specific match wins: *C-m9-*X > m9-*X > *X\n}\n```\n\n### Integration Testing\n\n**Integration Test Harness**:\n```cpp\nclass ModalModifierIntegrationTest : public ::testing::Test {\nprotected:\n    void SetUp() override {\n        // Create mock evdev device using uinput\n        mockDevice = std::make_unique<MockEvdevDevice>();\n\n        // Create engine with test config\n        engine = std::make_unique<Engine>();\n        engine->loadConfig(\"test_modal.mayu\");\n\n        // Start event processing\n        engine->start();\n    }\n\n    void TearDown() override {\n        engine->stop();\n    }\n\n    std::unique_ptr<MockEvdevDevice> mockDevice;\n    std::unique_ptr<Engine> engine;\n};\n```\n\n**Critical Scenarios** (30 tests):\n\n**Scenario 1: Basic Modal Modifier** (10 tests)\n```cpp\nTEST_F(ModalModifierIntegrationTest, HoldActivatesModifier) {\n    // Config: mod mod9 = !!A\n    // Input: A down, wait 250ms, A up\n    // Expected: mod9 activated, then deactivated\n\n    mockDevice->sendKeyDown(KEY_A);\n    std::this_thread::sleep_for(std::chrono::milliseconds(250));\n    mockDevice->sendKeyUp(KEY_A);\n\n    auto events = mockDevice->readOutputEvents();\n    EXPECT_EQ(0, events.size());  // No output (modifier only)\n}\n\nTEST_F(ModalModifierIntegrationTest, ModalCombinationWorks) {\n    // Config: mod mod9 = !!A, key m9-*X = Y\n    // Input: A down, wait 250ms, X down, X up, A up\n    // Expected: Y output\n\n    mockDevice->sendKeyDown(KEY_A);\n    std::this_thread::sleep_for(std::chrono::milliseconds(250));\n    mockDevice->sendKeyDown(KEY_X);\n    mockDevice->sendKeyUp(KEY_X);\n    mockDevice->sendKeyUp(KEY_A);\n\n    auto events = mockDevice->readOutputEvents();\n    ASSERT_EQ(2, events.size());  // Y down, Y up\n    EXPECT_EQ(KEY_Y, events[0].code);\n    EXPECT_EQ(1, events[0].value);  // Key down\n    EXPECT_EQ(KEY_Y, events[1].code);\n    EXPECT_EQ(0, events[1].value);  // Key up\n}\n```\n\n**Scenario 2: Tap vs Hold** (10 tests)\n```cpp\nTEST_F(ModalModifierIntegrationTest, TapAppliesSubstitution) {\n    // Config: mod mod9 = !!A, def subst *A = *Tab\n    // Input: A down, wait 50ms, A up\n    // Expected: Tab output (tapped)\n\n    mockDevice->sendKeyDown(KEY_A);\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    mockDevice->sendKeyUp(KEY_A);\n\n    auto events = mockDevice->readOutputEvents();\n    ASSERT_EQ(2, events.size());\n    EXPECT_EQ(KEY_TAB, events[0].code);  // Substitution applied\n}\n```\n\n**Scenario 3: Number Modifiers** (10 tests)\n```cpp\nTEST_F(ModalModifierIntegrationTest, NumberModifierAsShift) {\n    // Config: def numbermod *_1 = *LShift\n    // Input: _1 down, wait 250ms, A down, A up, _1 up\n    // Expected: Shift+A (capital A)\n\n    mockDevice->sendKeyDown(KEY_1);\n    std::this_thread::sleep_for(std::chrono::milliseconds(250));\n    mockDevice->sendKeyDown(KEY_A);\n    mockDevice->sendKeyUp(KEY_A);\n    mockDevice->sendKeyUp(KEY_1);\n\n    auto events = mockDevice->readOutputEvents();\n    // Verify Shift down, A down, A up, Shift up sequence\n    EXPECT_EQ(KEY_LEFTSHIFT, events[0].code);\n    EXPECT_EQ(1, events[0].value);  // Shift down\n    EXPECT_EQ(KEY_A, events[1].code);\n    // ... verify full sequence\n}\n```\n\n### End-to-End Testing\n\n**E2E Test Environment**:\n- Real evdev device (keyboard input)\n- Real uinput device (output verification)\n- Qt GUI running (full system integration)\n- Latency measurement via `clock_gettime()`\n\n**UAT Scenarios** (15 tests):\n\n**UAT-1: Emacs-Style Prefix Key**\n```\nConfig:\n  mod mod9 = !!X         # X becomes prefix\n  key m9-*F = &OpenFile  # C-x C-f\n\nSteps:\n  1. Hold X for 250ms\n  2. Press F\n  3. Release F\n  4. Release X\n\nExpected:\n  - File open dialog appears\n  - Latency <1ms from F press to action trigger\n```\n\n**UAT-2: Vim-Style Modal Editing**\n```\nConfig:\n  mod mod9 = !!Esc       # Esc activates normal mode\n  key m9-*H = *Left      # h → left\n  key m9-*J = *Down      # j → down\n  key m9-*K = *Up        # k → up\n  key m9-*L = *Right     # l → right\n\nSteps:\n  1. Hold Esc for 250ms (activate normal mode)\n  2. Press H (move left)\n  3. Press J (move down)\n  4. Release Esc (deactivate normal mode)\n\nExpected:\n  - Cursor moves left, then down\n  - Total latency <1ms per keypress\n```\n\n**UAT-3: Number Row as Function Keys**\n```\nConfig:\n  def numbermod *_1 = *F1\n  def numbermod *_2 = *F2\n  ...\n  def numbermod *_0 = *F10\n\nSteps:\n  1. Hold 1 for 250ms\n  2. Release 1\n\nExpected:\n  - F1 key output\n  - Latency <1ms\n```\n\n## Performance Benchmarks\n\n**Benchmark Suite**:\n```bash\n# Automated benchmark (100,000 iterations)\n./yamy --benchmark --config modal_stress.mayu --iterations 100000\n\n# Sample config (stress test):\n# - 20 modal modifiers (mod0-mod19)\n# - 100 number modifiers (all letter keys)\n# - 500 keymap entries with modal combinations\n```\n\n**Expected Results**:\n```\nModal Modifier Performance Benchmark\n=====================================\nConfiguration: 20 modal mods, 100 number mods, 500 keymap entries\nIterations: 100,000\n\nHold Detection:\n  P50: 8.2μs\n  P99: 12.5μs\n  P99.9: 45.3μs\n\nModifier State Update:\n  P50: 3.1μs\n  P99: 5.8μs\n\nKeymap Lookup (with 4 modifiers):\n  P50: 11.7μs\n  P99: 18.2μs\n\nTotal Pipeline (evdev → uinput):\n  P50: 387μs\n  P99: 842μs ✓ (< 1ms target)\n  P99.9: 2.1ms\n\nMemory Usage:\n  Handler state: 8.2 KB\n  Modifier state: 36 bytes\n  Total overhead: <10 KB ✓\n\nCPU Usage (1000 events/sec sustained):\n  Mean: 1.2%\n  Peak: 3.4%\n\nPASS: All targets met ✓\n```\n\n---\n\n**Document Version**: 1.0\n**Created**: 2025-12-14\n**Reviewed By**: (Pending approval)\n",
  "fileStats": {
    "size": 27583,
    "lines": 897,
    "lastModified": "2025-12-14T04:29:04.492Z"
  },
  "comments": []
}