{
  "id": "snapshot_1765380715450_gz3flhbqu",
  "approvalId": "approval_1765379658575_dm4lcb4ai",
  "approvalTitle": "Steering: Codebase Structure",
  "version": 2,
  "timestamp": "2025-12-10T15:31:55.450Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# YAMY Codebase Structure\n\n## Directory Layout\n\n```\nyamy/\n├── src/                      # Source code\n│   ├── app/                  # Application entry points\n│   │   ├── yamy.cpp         # Windows launcher (32/64-bit selector)\n│   │   ├── mayu.cpp         # Windows main (engine + Win32 GUI)\n│   │   ├── yamyd.cpp        # Windows 32-bit helper\n│   │   ├── main_linux.cpp   # Linux headless entry point\n│   │   └── main_qt.cpp      # Linux Qt GUI entry point\n│   │\n│   ├── core/                 # Platform-agnostic core logic\n│   │   ├── engine/           # Keyboard remapping engine\n│   │   │   ├── engine.h/.cpp           # Main orchestrator\n│   │   │   ├── engine_lifecycle.cpp    # Start/stop/pause\n│   │   │   ├── engine_input.cpp        # Input event processing\n│   │   │   ├── engine_modifier.cpp     # Modifier state tracking\n│   │   │   ├── engine_generator.cpp    # Event generation\n│   │   │   ├── engine_focus.cpp        # Focus tracking\n│   │   │   ├── engine_window.cpp       # Window manipulation\n│   │   │   ├── engine_setting.cpp      # Configuration loading\n│   │   │   └── engine_log.cpp          # Logging\n│   │   │\n│   │   ├── settings/         # Configuration management\n│   │   │   ├── setting.h/.cpp          # Configuration representation\n│   │   │   ├── setting_loader.h/.cpp   # .mayu file parser\n│   │   │   └── parser.cpp              # Parsing utilities\n│   │   │\n│   │   ├── input/            # Input abstractions\n│   │   │   ├── keyboard.h/.cpp         # Keyboard state\n│   │   │   ├── keymap.h/.cpp           # Key binding registry\n│   │   │   ├── vkeytable.h/.cpp        # Virtual key table\n│   │   │   └── input_event.h           # Event data structures\n│   │   │\n│   │   ├── window/           # Window system abstractions\n│   │   │   ├── target.h/.cpp           # Target window selector\n│   │   │   ├── focus.h/.cpp            # Focus management\n│   │   │   └── layoutmanager.h/.cpp    # Window layout\n│   │   │\n│   │   ├── functions/        # Action system\n│   │   │   ├── function.h/.cpp         # Action base classes\n│   │   │   ├── function_creator.cpp    # Action factory\n│   │   │   └── strexpr.h/.cpp          # String expressions\n│   │   │\n│   │   ├── commands/         # Command implementations\n│   │   │   ├── cmd_keymap_*.cpp        # Keymap commands\n│   │   │   ├── cmd_window_*.cpp        # Window commands\n│   │   │   ├── cmd_clipboard_*.cpp     # Clipboard commands\n│   │   │   ├── cmd_mouse_*.cpp         # Mouse commands\n│   │   │   └── cmd_*.cpp               # Other commands (60+ files)\n│   │   │\n│   │   └── platform/         # Platform interface definitions\n│   │       ├── window_system_interface.h\n│   │       ├── input_injector_interface.h\n│   │       ├── input_hook_interface.h\n│   │       ├── input_driver_interface.h\n│   │       └── message_constants.h\n│   │\n│   ├── platform/             # Platform-specific implementations\n│   │   ├── windows/          # Windows implementations\n│   │   │   ├── window_system_win32.h/.cpp\n│   │   │   ├── input_injector_win32.h/.cpp\n│   │   │   ├── input_hook_win32.h/.cpp\n│   │   │   ├── input_driver_win32.h/.cpp\n│   │   │   ├── windowstool.h/.cpp      # Win32 utilities\n│   │   │   ├── registry.h/.cpp         # Registry access\n│   │   │   ├── utf_conversion.h/.cpp   # UTF-8/UTF-16 conversion\n│   │   │   ├── hook.h/.cpp             # DLL hook implementation\n│   │   │   ├── thread_win32.cpp        # Threading\n│   │   │   ├── sync.cpp                # Synchronization\n│   │   │   └── hook_data.cpp           # Hook data structures\n│   │   │\n│   │   └── linux/            # Linux implementations\n│   │       ├── window_system_linux.cpp\n│   │       ├── window_system_linux_queries.cpp\n│   │       ├── window_system_linux_manipulation.cpp\n│   │       ├── window_system_linux_hierarchy.cpp\n│   │       ├── window_system_linux_mouse.cpp\n│   │       ├── window_system_linux_monitor.cpp\n│   │       ├── input_injector_linux.cpp\n│   │       ├── input_hook_linux.cpp\n│   │       ├── input_driver_linux.cpp\n│   │       ├── device_manager_linux.cpp\n│   │       ├── keycode_mapping.cpp\n│   │       ├── sync_linux.cpp\n│   │       ├── thread_linux.cpp\n│   │       ├── hook_data_linux.cpp\n│   │       └── ipc_linux.cpp\n│   │\n│   ├── ui/                   # User interface\n│   │   ├── dlgsetting.cpp/h          # Windows settings dialog\n│   │   ├── dlgeditsetting.cpp/h      # Windows edit dialog\n│   │   ├── dlginvestigate.cpp/h      # Windows debug dialog\n│   │   ├── dlglog.cpp/h              # Windows log viewer\n│   │   ├── dlgversion.cpp/h          # Windows about dialog\n│   │   ├── mayu.rc                   # Windows resources\n│   │   │\n│   │   └── qt/               # Qt GUI for Linux\n│   │       ├── tray_icon_qt.h/.cpp         # System tray\n│   │       ├── dialog_settings_qt.h/.cpp   # Settings dialog\n│   │       ├── dialog_log_qt.h/.cpp        # Log viewer\n│   │       ├── dialog_about_qt.h/.cpp      # About dialog\n│   │       ├── resources.qrc                # Qt resources\n│   │       └── CMakeLists.txt               # Qt build config\n│   │\n│   ├── utils/                # Utilities\n│   │   ├── stringtool.h/.cpp         # String manipulation\n│   │   ├── compiler_specific.h       # Compiler macros\n│   │   ├── compiler_specific_func.h/.cpp\n│   │   ├── misc.h                    # Miscellaneous utilities\n│   │   ├── msgstream.h               # Message stream logging\n│   │   ├── config_store.h            # Configuration storage interface\n│   │   └── errormessage.h            # Error handling\n│   │\n│   ├── resources/            # Resource files\n│   │   └── icons/            # Application icons\n│   │       ├── yamy_enabled.png\n│   │       └── yamy_disabled.png\n│   │\n│   └── tests/                # Test suite\n│       ├── googletest/       # Google Test framework\n│       ├── test_main.cpp     # Test runner\n│       └── test_*.cpp        # Unit tests\n│\n├── docs/                     # Documentation\n│   ├── GUI-ARCHITECTURE.md\n│   ├── LINUX-GUI-IMPLEMENTATION-PLAN.md\n│   ├── LINUX-QT-GUI-MANUAL.md\n│   ├── LINUX-QT-REMAINING-WORK.md\n│   ├── TRACK1-JULES-TASKS.md\n│   └── adr/                  # Architecture Decision Records\n│\n├── scripts/                  # Build and QA scripts\n│   ├── check_missing_sources.ps1\n│   ├── check_missing_sources.sh\n│   ├── check_header_guards.ps1\n│   └── check_encoding.ps1\n│\n├── CMakeLists.txt            # Root build configuration\n├── linux_qt_setup.sh         # Linux setup automation\n└── README.md                 # Project overview\n```\n\n---\n\n## Coding Conventions\n\n### Naming Conventions\n\n**Files**:\n```\nsnake_case.cpp         # Implementation files\nsnake_case.h           # Header files\nPascalCase.cpp         # Legacy Windows files (gradually migrating)\n```\n\n**Classes**:\n```cpp\nclass MyClass { };     # PascalCase for classes\n```\n\n**Functions**:\n```cpp\nvoid myFunction();     # camelCase for functions\nvoid my_function();    # snake_case acceptable for platform layer\n```\n\n**Variables**:\n```cpp\nint myVariable;        # camelCase for local variables\nint m_memberVariable;  # m_ prefix for member variables\nint g_globalVariable;  # g_ prefix for globals (avoid)\nconst int MAX_SIZE = 100;  # UPPER_CASE for constants\n```\n\n**Prefixes**:\n```cpp\nclass Interface { };   # I prefix for interfaces (Windows style)\nIWindowSystem          # Platform interface\nbool i_input;          # i_ prefix for input parameters\nint o_output;          # o_ prefix for output parameters\nint io_both;           # io_ prefix for input/output parameters\n```\n\n### File Organization\n\n**Header File Pattern**:\n```cpp\n#pragma once           // Prefer over header guards\n\n// Includes (grouped and sorted)\n#include <system>      // Standard library\n#include <third-party> // Third-party libraries\n#include \"local.h\"     // Local headers\n\n// Forward declarations\nclass Foo;\n\n// Main declarations\nclass MyClass {\npublic:\n    // Public interface\nprivate:\n    // Private implementation\n};\n```\n\n**Implementation File Pattern**:\n```cpp\n#include \"myclass.h\"   // Corresponding header first\n\n// Other includes\n#include <iostream>\n#include \"other.h\"\n\n// Anonymous namespace for file-local helpers\nnamespace {\n    void helperFunction() { }\n}\n\n// Class implementation\nvoid MyClass::method() {\n    // Implementation\n}\n```\n\n### Code Style\n\n**Indentation**: 4 spaces (no tabs)\n\n**Braces**:\n```cpp\n// Function braces on new line (Windows convention)\nvoid function()\n{\n    if (condition) {\n        // Statement braces on same line\n    }\n}\n```\n\n**Line Length**: 120 characters (flexible)\n\n**Comments**:\n```cpp\n// Single-line comment for brief notes\n\n/**\n * Doxygen comment for documentation\n * @param i_param Description\n * @return Description\n */\n\n///  Triple-slash for member documentation\n```\n\n---\n\n## Platform Abstraction Patterns\n\n### Pattern 1: Interface + Factory\n\n**Interface Definition** (`src/core/platform/`):\n```cpp\n// window_system_interface.h\nclass IWindowSystem {\npublic:\n    virtual ~IWindowSystem() = default;\n    virtual WindowHandle getForegroundWindow() = 0;\n    // ... other methods\n};\n\n// Factory function (implemented per-platform)\nIWindowSystem* createWindowSystem();\n```\n\n**Platform Implementation** (`src/platform/windows/` or `src/platform/linux/`):\n```cpp\n// window_system_win32.cpp\nclass WindowSystemWin32 : public IWindowSystem {\n    WindowHandle getForegroundWindow() override {\n        return ::GetForegroundWindow();\n    }\n};\n\nIWindowSystem* createWindowSystem() {\n    return new WindowSystemWin32();\n}\n```\n\n### Pattern 2: Type Aliases\n\n**Header** (`src/core/platform/types.h`):\n```cpp\nnamespace yamy::platform {\n    #ifdef _WIN32\n        typedef HWND WindowHandle;\n    #else\n        typedef uint64_t WindowHandle;  // X11 Window ID\n    #endif\n}\n```\n\n**Usage**:\n```cpp\nusing yamy::platform::WindowHandle;\nWindowHandle hwnd = windowSystem->getForegroundWindow();\n```\n\n### Pattern 3: Conditional Source Files\n\n**CMakeLists.txt**:\n```cmake\nif(WIN32)\n    set(PLATFORM_SOURCES\n        src/platform/windows/window_system_win32.cpp\n        src/platform/windows/input_injector_win32.cpp\n    )\nelse()\n    set(PLATFORM_SOURCES\n        src/platform/linux/window_system_linux.cpp\n        src/platform/linux/input_injector_linux.cpp\n    )\nendif()\n\nadd_executable(yamy ${CORE_SOURCES} ${PLATFORM_SOURCES})\n```\n\n---\n\n## Module Dependencies\n\n### Dependency Graph\n\n```\n┌─────────────────────────────────────────────────┐\n│                    ui/                           │\n│  (Windows: Win32 GUI, Linux: Qt GUI)            │\n└──────────────────┬──────────────────────────────┘\n                   │\n┌──────────────────▼──────────────────────────────┐\n│            core/engine/                          │\n│  (Platform-agnostic remapping logic)            │\n└┬────────────┬────────────┬──────────────────────┘\n │            │            │\n │            │            └──────┐\n ▼            ▼                   ▼\n┌────────────────┐  ┌──────────────────┐  ┌──────────────┐\n│ core/settings/ │  │ core/functions/  │  │ core/window/ │\n└────────────────┘  └──────────────────┘  └──────────────┘\n         │                   │                     │\n         └───────────────────┴─────────────────────┘\n                             │\n              ┌──────────────▼──────────────┐\n              │   core/platform/            │\n              │  (Interfaces)               │\n              └──────────────┬──────────────┘\n                             │\n              ┌──────────────▼──────────────────────┐\n              │   platform/windows/  OR             │\n              │   platform/linux/                   │\n              │  (OS-specific implementations)      │\n              └─────────────────────────────────────┘\n```\n\n### Layer Rules\n\n1. **UI Layer** may depend on **Core Layer** and **Utils**\n2. **Core Layer** may depend on **Platform Interfaces** and **Utils**\n3. **Platform Implementations** implement **Platform Interfaces**\n4. **Platform Interfaces** depend on **nothing** (pure virtual)\n5. **Utils** depend on **nothing** (leaf nodes)\n\n**Violations** (technical debt):\n- ❌ `core/engine/engine.cpp` includes `windowstool.h` (Windows-specific)\n- ❌ `utils/msgstream.h` uses `PostMessage` (Windows-specific)\n- ❌ `core/functions/function.h` uses `SW_*` constants (Windows-specific)\n\n**Fix**: Track 1 refactoring removes these violations\n\n---\n\n## Build System Patterns\n\n### Target Organization\n\n**Executable Targets**:\n```cmake\nadd_executable(target_name ${SOURCES})\ntarget_link_libraries(target_name PRIVATE dependencies)\ntarget_include_directories(target_name PRIVATE include_dirs)\ntarget_compile_definitions(target_name PRIVATE DEFINES)\n```\n\n**Library Targets**:\n```cmake\nadd_library(library_name STATIC ${SOURCES})\n# OR\nadd_library(library_name SHARED ${SOURCES})\n```\n\n**Conditional Targets**:\n```cmake\nif(WIN32)\n    add_executable(windows_only_target ...)\nelseif(UNIX AND NOT APPLE)\n    add_executable(linux_only_target ...)\nendif()\n```\n\n### Include Directory Hierarchy\n\n**Private Includes** (implementation-only):\n```cmake\ntarget_include_directories(target PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}/internal\n)\n```\n\n**Public Includes** (exported to dependents):\n```cmake\ntarget_include_directories(target PUBLIC\n    ${CMAKE_CURRENT_SOURCE_DIR}/include\n)\n```\n\n**Interface Includes** (header-only libraries):\n```cmake\nadd_library(interface_lib INTERFACE)\ntarget_include_directories(interface_lib INTERFACE\n    ${CMAKE_CURRENT_SOURCE_DIR}/include\n)\n```\n\n---\n\n## Common Patterns & Idioms\n\n### RAII for Resource Management\n\n```cpp\nclass ResourceHolder {\npublic:\n    ResourceHolder() : m_handle(acquire()) { }\n    ~ResourceHolder() { release(m_handle); }\n\n    // Delete copy, allow move\n    ResourceHolder(const ResourceHolder&) = delete;\n    ResourceHolder& operator=(const ResourceHolder&) = delete;\n    ResourceHolder(ResourceHolder&& other) noexcept\n        : m_handle(std::exchange(other.m_handle, nullptr)) { }\n\nprivate:\n    Handle m_handle;\n};\n```\n\n### Singleton Pattern (Engine)\n\n```cpp\nclass Engine {\npublic:\n    static Engine& getInstance() {\n        static Engine instance;\n        return instance;\n    }\n\nprivate:\n    Engine() = default;  // Private constructor\n    ~Engine() = default;\n\n    // Delete copy and move\n    Engine(const Engine&) = delete;\n    Engine& operator=(const Engine&) = delete;\n};\n```\n\n### Interface Segregation\n\n```cpp\n// DON'T: Fat interface\nclass IWindowSystem {\n    virtual void method1() = 0;\n    virtual void method2() = 0;\n    // ... 50 methods\n};\n\n// DO: Split into focused interfaces\nclass IWindowQueries {\n    virtual WindowHandle getForegroundWindow() = 0;\n    virtual std::string getWindowText(WindowHandle) = 0;\n};\n\nclass IWindowManipulation {\n    virtual void moveWindow(WindowHandle, Rect) = 0;\n    virtual void setForegroundWindow(WindowHandle) = 0;\n};\n```\n\n---\n\n## Error Handling Strategy\n\n### Exception Policy\n\n**Core Engine**: NO exceptions (performance-critical)\n```cpp\n// Use return codes or output parameters\nbool loadConfig(const std::string& path, Setting* o_setting);\n```\n\n**UI Layer**: Exceptions OK (Qt uses exceptions)\n```cpp\ntry {\n    dialog.exec();\n} catch (const std::exception& e) {\n    QMessageBox::critical(nullptr, \"Error\", e.what());\n}\n```\n\n### Error Reporting Pattern\n\n```cpp\nenum class ErrorCode {\n    Success,\n    FileNotFound,\n    ParseError,\n    InvalidSyntax\n};\n\nstruct Result {\n    ErrorCode code;\n    std::string message;\n\n    bool ok() const { return code == ErrorCode::Success; }\n    explicit operator bool() const { return ok(); }\n};\n\nResult loadFile(const std::string& path) {\n    if (!fileExists(path)) {\n        return {ErrorCode::FileNotFound, \"File not found: \" + path};\n    }\n    return {ErrorCode::Success, \"\"};\n}\n\n// Usage\nauto result = loadFile(\"config.mayu\");\nif (!result) {\n    log << \"Error: \" << result.message << std::endl;\n}\n```\n\n---\n\n## Testing Patterns\n\n### Unit Test Structure\n\n```cpp\n#include <gtest/gtest.h>\n#include \"myclass.h\"\n\n// Test fixture\nclass MyClassTest : public ::testing::Test {\nprotected:\n    void SetUp() override {\n        // Test setup\n    }\n\n    void TearDown() override {\n        // Test cleanup\n    }\n\n    MyClass testObject;  // Shared test object\n};\n\n// Test case\nTEST_F(MyClassTest, MethodReturnsExpectedValue) {\n    // Arrange\n    int input = 42;\n\n    // Act\n    int result = testObject.method(input);\n\n    // Assert\n    EXPECT_EQ(84, result);\n}\n```\n\n### Parameterized Tests\n\n```cpp\nclass KeymapTest : public ::testing::TestWithParam<std::pair<int, std::string>> {\n};\n\nTEST_P(KeymapTest, LookupsWork) {\n    auto [vk, expected] = GetParam();\n    std::string result = lookupKeyName(vk);\n    EXPECT_EQ(expected, result);\n}\n\nINSTANTIATE_TEST_SUITE_P(\n    KeyNames,\n    KeymapTest,\n    ::testing::Values(\n        std::make_pair(VK_A, \"A\"),\n        std::make_pair(VK_CONTROL, \"Control\"),\n        std::make_pair(VK_ESCAPE, \"Escape\")\n    )\n);\n```\n\n---\n\n## Documentation Patterns\n\n### Header Documentation\n\n```cpp\n/**\n * @file myclass.h\n * @brief Brief description of file purpose\n *\n * Detailed description of what this file contains and how to use it.\n */\n\n/**\n * @class MyClass\n * @brief Brief class description\n *\n * Detailed class description with usage examples:\n * @code\n * MyClass obj;\n * obj.doSomething();\n * @endcode\n */\nclass MyClass {\npublic:\n    /**\n     * @brief Brief method description\n     *\n     * Detailed method description.\n     *\n     * @param i_input Input parameter description\n     * @param o_output Output parameter description (must not be nullptr)\n     * @return true on success, false on failure\n     *\n     * @note Special note about edge cases\n     * @warning Warning about dangerous behavior\n     */\n    bool method(int i_input, int* o_output);\n};\n```\n\n### Implementation Comments\n\n```cpp\nvoid MyClass::complexMethod() {\n    // High-level algorithm overview:\n    // 1. Validate input\n    // 2. Transform data\n    // 3. Perform operation\n    // 4. Cleanup\n\n    validateInput();  // Self-explanatory, no comment needed\n\n    // Edge case: Handle empty list by returning early\n    if (list.empty()) {\n        return;\n    }\n\n    // Performance note: This loop is O(n²), but n is typically <100\n    for (...) {\n        for (...) {\n            // Complex logic explained\n        }\n    }\n}\n```\n\n---\n\n## Anti-Patterns to Avoid\n\n### ❌ Ifdef Hell\n\n```cpp\n// DON'T\nvoid function() {\n    #ifdef _WIN32\n        // 100 lines of Windows code\n    #else\n        // 100 lines of Linux code\n    #endif\n}\n\n// DO: Separate files\n// windows/function_impl.cpp\n// linux/function_impl.cpp\n```\n\n### ❌ God Objects\n\n```cpp\n// DON'T\nclass Mayu {\n    // 5000 lines, does everything\n};\n\n// DO: Split responsibilities\nclass Engine { /* remapping */ };\nclass WindowTracker { /* focus tracking */ };\nclass ConfigManager { /* settings */ };\n```\n\n### ❌ Magic Numbers\n\n```cpp\n// DON'T\nif (value == 9) { ... }\n\n// DO\nconst int RESTORE_FLAG = 9;\nif (value == RESTORE_FLAG) { ... }\n\n// BETTER\nenum class ShowCommand { Restore = 9 };\nif (value == ShowCommand::Restore) { ... }\n```\n\n### ❌ Raw Pointers for Ownership\n\n```cpp\n// DON'T\nThing* thing = new Thing();\n// Who deletes this? When?\n\n// DO\nstd::unique_ptr<Thing> thing = std::make_unique<Thing>();\n// Automatic cleanup\n```\n\n---\n\n## Migration Strategies\n\n### From Windows Types to Platform Types\n\n**Step 1**: Alias (backward compatible)\n```cpp\nusing WindowHandle = HWND;  // Transition step\n```\n\n**Step 2**: Gradual replacement\n```cpp\nvoid method(WindowHandle hwnd);  // Not HWND\n```\n\n**Step 3**: Remove alias\n```cpp\nusing WindowHandle = uint64_t;  // Platform-specific definition\n```\n\n### From Registry to QSettings\n\n**Windows**:\n```cpp\nRegistry::read(\"Software\\\\YAMY\", \".mayu0\", &value);\n```\n\n**Cross-Platform**:\n```cpp\nConfigStore* store = createConfigStore();  // Factory\nstore->read(\"keymaps/configs/0\", &value);\n```\n\n**Linux Implementation**:\n```cpp\n// Uses QSettings under the hood\nQSettings settings(\"YAMY\", \"YAMY\");\nvalue = settings.value(\"keymaps/configs/0\").toString();\n```\n\n---\n\n**Document Version**: 1.0\n**Last Updated**: 2025-12-10\n**Reviewed By**: (Pending approval)\n",
  "fileStats": {
    "size": 22349,
    "lines": 792,
    "lastModified": "2025-12-10T14:58:02.670Z"
  },
  "comments": []
}