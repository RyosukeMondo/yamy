{
  "id": "snapshot_1765381672414_0mvpyptqt",
  "approvalId": "approval_1765381672409_e5qwqfs9e",
  "approvalTitle": "Tasks Document - Linux Complete Port (121 tasks)",
  "version": 1,
  "timestamp": "2025-12-10T15:47:52.414Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks: Linux Complete Port\n\n**Status**: Draft\n**Created**: 2025-12-10\n**Dependencies**: design.md\n**Total Tasks**: 121 tasks across 6 tracks\n\n---\n\n## Track 1: Core Refactoring (60 tasks)\n\n### Batch 1: Foundation (32 tasks - ALL PARALLEL)\n\n- [ ] 1.1.1 Remove tstring from stringtool.h\n  - File: src/utils/stringtool.h\n  - Remove Windows-specific tstring typedef and _T() macros\n  - Convert all function signatures to use std::string\n  - _Leverage: src/utils/stringtool.cpp_\n  - _Requirements: FR-1.2_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Remove all Windows-specific string types from stringtool.h - Step 1: Remove typedef std::basic_string<TCHAR> tstring, Step 2: Remove all _T() macro usages, Step 3: Keep only std::string versions of functions, Step 4: Remove any #ifdef UNICODE blocks, Step 5: Ensure all function signatures use std::string, Verify with grep tstring and grep _T( commands | Restrictions: Do not modify function behavior, Maintain UTF-8 encoding throughout, Ensure file compiles on Linux without windows.h, Do not break existing callers | Success: No tstring references remain, No _T() macros remain, All functions use std::string, File compiles on Linux without windows.h, All unit tests pass | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.2 Remove tstring from stringtool.cpp\n  - File: src/utils/stringtool.cpp\n  - Update implementation to match stringtool.h changes\n  - Convert wstring operations to UTF-8 std::string\n  - _Leverage: src/utils/stringtool.h_\n  - _Requirements: FR-1.2_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Update stringtool.cpp implementation to match stringtool.h changes - Step 1: Remove all tstring usages in function implementations, Step 2: Convert wstring operations to UTF-8 std::string, Step 3: Update string conversions by removing toWide/toNarrow functions and adding UTF-8 conversion utilities if needed for Windows bridge, Step 4: Update all string literals from _T(\"foo\") to \"foo\", Verify with grep commands and unit tests | Restrictions: Maintain UTF-8 encoding, Do not break Windows build (add UTF-8/UTF-16 bridge if needed), Preserve all function semantics | Success: No tstring references, All string literals are plain UTF-8, Unit tests pass on both Linux and Windows | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.3 Clean up config_store.h tstring overloads\n  - File: src/core/settings/config_store.h\n  - Remove duplicate tstring overloads causing link errors\n  - Keep only std::string API versions\n  - _Leverage: src/core/settings/config_store.cpp_\n  - _Requirements: FR-1.2, FR-1.6_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: ConfigStore has duplicate overloads for tstring and std::string causing link errors on Linux, Remove tstring versions - Step 1: Remove overloads bool read(const tstring& key, tstring* value), bool write(const tstring& key, const tstring& value), bool exists(const tstring& key), Step 2: Keep only std::string versions, Step 3: Update internal storage to use std::string keys | Restrictions: Do not break existing callers, Maintain API compatibility where possible, Ensure no ambiguity errors during compilation | Success: No tstring overloads remain, Only std::string API exists, No compilation errors, File compiles on Linux | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.4 Update config_store.cpp implementation\n  - File: src/core/settings/config_store.cpp\n  - Update implementation to use std::string\n  - Add UTF-8 to UTF-16 bridge for Windows registry calls\n  - _Leverage: src/core/settings/config_store.h_\n  - _Requirements: FR-1.2, FR-1.6_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Update ConfigStore implementation to use std::string - Step 1: Remove tstring function implementations, Step 2: On Windows update registry calls to convert UTF-8 to UTF-16 at API boundary using utf8::toWide(key), Step 3: On Linux use QSettings which already handles UTF-8, Step 4: Update internal cache to std::map<std::string, std::string> m_cache | Restrictions: Maintain registry compatibility on Windows, Ensure UTF-8 round-trip works correctly, Do not break config file format | Success: Compiles on both Linux and Windows, Windows uses UTF-8 to UTF-16 bridge at registry API boundary, All tests pass, Config persistence works | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.5 Remove tstring from errormessage.h\n  - File: src/core/settings/errormessage.h\n  - Convert ErrorMessage class to use std::string\n  - Update member variables and method signatures\n  - _Leverage: src/core/settings/errormessage.cpp_\n  - _Requirements: FR-1.2_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: ErrorMessage class uses tstring for message storage, Convert to std::string - Step 1: Change member variable tstring m_message to std::string m_message, Step 2: Update constructor ErrorMessage(const tstring& msg) to ErrorMessage(const std::string& msg), Step 3: Update getter const tstring& getMessage() to const std::string& getMessage(), Step 4: Remove any _T() macros in error messages | Restrictions: Do not change error message content, Maintain API compatibility for error handling code | Success: No tstring in file, std::string used throughout, No _T() macros, All error messages display correctly in UTF-8 | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.6 Update keyboard.cpp string handling\n  - File: src/core/input/keyboard.cpp\n  - Convert key name storage from tstring to std::string\n  - Update key name parsing functions\n  - _Leverage: src/core/input/keyboard.h_\n  - _Requirements: FR-1.2_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Keyboard class uses tstring for key name storage, Convert to std::string - Step 1: Update key name map from std::map<tstring, KeyCode> to std::map<std::string, KeyCode>, Step 2: Update function KeyCode parseKeyName(const tstring& name) to KeyCode parseKeyName(const std::string& name), Step 3: Update string literals in key name table by removing _T() macros, Step 4: Update case-insensitive comparisons to use UTF-8 aware functions if needed | Restrictions: Maintain key name parsing behavior, Ensure all existing key names still work, Do not break .mayu file parsing | Success: No tstring references, Key name map uses std::string, Key name parsing tests pass, All 60+ key names recognized | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.7 Update parser string handling\n  - File: src/core/parser/parser.cpp\n  - Convert parser string handling to std::string\n  - Update token storage and string comparisons\n  - _Leverage: src/core/parser/parser.h_\n  - _Requirements: FR-1.2_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Parser uses tstring for token storage and comparisons, Convert to std::string - Step 1: Update token storage from std::vector<tstring> to std::vector<std::string>, Step 2: Update string comparison functions to use std::string, Step 3: Remove _T() macros from keyword table, Step 4: Ensure UTF-8 file parsing works correctly | Restrictions: Maintain .mayu file parsing compatibility, Ensure line numbers and error positions remain accurate, Do not change parser behavior | Success: No tstring references, Token storage uses std::string, Parser tests pass, .mayu files parse correctly | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.8 Update mayu_scanner.cpp string handling\n  - File: src/core/parser/mayu_scanner.cpp\n  - Convert scanner string buffer to std::string\n  - Update string literal handling\n  - _Leverage: src/core/parser/mayu_scanner.h_\n  - _Requirements: FR-1.2_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Scanner uses tstring for buffer storage, Convert to std::string - Step 1: Update buffer from tstring m_buffer to std::string m_buffer, Step 2: Update getCurrentToken() from returning tstring to std::string, Step 3: Remove _T() macros from scanner error messages, Step 4: Ensure UTF-8 scanning works correctly | Restrictions: Maintain scanner behavior, Preserve token positions for error reporting, Do not break string literal parsing | Success: No tstring references, Buffer uses std::string, Scanner tests pass, String literals scanned correctly | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.9 Create WindowHandle type alias\n  - File: src/platform/types.h\n  - Create platform-agnostic WindowHandle type\n  - Add conditional compilation for Windows HWND vs Linux Window\n  - _Leverage: src/platform/window_system.h_\n  - _Requirements: FR-1.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Create platform-agnostic WindowHandle type - Step 1: Add #ifdef _WIN32 using WindowHandle = HWND else using WindowHandle = unsigned long (X11 Window), Step 2: Define InvalidWindowHandle constant, Step 3: Add utility functions isValidWindow(WindowHandle), Step 4: Document the type in comments | Restrictions: Must support both Windows HWND and X11 Window types, Ensure type safety, Keep overhead minimal (just a typedef) | Success: WindowHandle works on both platforms, Invalid handle detection works, Type is documented, Compiles on both Linux and Windows | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.10 Create IWindowSystem interface\n  - File: src/platform/window_system.h\n  - Define abstract interface for window operations\n  - Include all window management methods\n  - _Leverage: src/platform/types.h, design.md Section 1.2_\n  - _Requirements: FR-1.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Define abstract IWindowSystem interface for window operations - Methods: getForegroundWindow, getWindowText, getWindowClassName, getWindowRect, showWindow, moveWindow, setForegroundWindow, enumWindows - Step 1: Create pure virtual interface class, Step 2: Use WindowHandle type, Step 3: Define Rect structure, Step 4: Add factory function createWindowSystem() | Restrictions: Interface must be platform-agnostic, Do not include platform-specific types in interface, Keep methods minimal and focused | Success: Interface is well-defined, Factory function declared, Compiles on both platforms, Methods cover all window operations needed | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.11 Create WindowSystemWin32 implementation\n  - File: src/platform/win32/window_system_win32.cpp\n  - Implement IWindowSystem for Windows using Win32 API\n  - Wrap existing Win32 window operations\n  - _Leverage: src/platform/window_system.h_\n  - _Requirements: FR-1.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Implement IWindowSystem for Windows - Step 1: Create WindowSystemWin32 class implementing IWindowSystem, Step 2: Wrap GetForegroundWindow, GetWindowText, GetClassName, GetWindowRect, ShowWindow, MoveWindow, SetForegroundWindow, EnumWindows, Step 3: Handle UTF-8 to UTF-16 conversions at API boundary, Step 4: Implement factory function returning WindowSystemWin32 | Restrictions: Maintain existing Windows behavior exactly, Handle string conversions correctly, Ensure proper error handling | Success: All methods implemented correctly, Windows build works, UTF-8 conversions work, Window operations function as before | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.12 Create WindowSystemLinux implementation\n  - File: src/platform/linux/window_system_linux.cpp\n  - Implement IWindowSystem for Linux using X11\n  - Add EWMH support for window operations\n  - _Leverage: src/platform/window_system.h_\n  - _Requirements: FR-1.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with X11 and EWMH expertise | Task: Implement IWindowSystem for Linux - Step 1: Create WindowSystemLinux class implementing IWindowSystem, Step 2: Use XGetInputFocus for getForegroundWindow, Step 3: Use XFetchName/_NET_WM_NAME for getWindowText, Step 4: Use XGetClassHint for getWindowClassName, Step 5: Implement showWindow using XMapWindow/XUnmapWindow/_NET_WM_STATE, Step 6: Implement moveWindow using XMoveResizeWindow, Step 7: Implement factory function returning WindowSystemLinux | Restrictions: Use X11 and EWMH APIs correctly, Handle UTF-8 properly (X11 uses UTF-8 for _NET_WM_NAME), Ensure window operations work with modern window managers | Success: All methods implemented, Linux build works, Window operations tested with various WMs, UTF-8 text retrieved correctly | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.13 Create IInputInjector interface\n  - File: src/platform/input_injector.h\n  - Define abstract interface for input injection\n  - Include keyboard and mouse event injection methods\n  - _Leverage: src/platform/types.h, design.md Section 1.3_\n  - _Requirements: FR-1.3_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Define abstract IInputInjector interface for input injection - Methods: injectKeyDown, injectKeyUp, injectMouseButton, injectMouseMove, injectMouseWheel - Step 1: Create pure virtual interface, Step 2: Define KeyEvent and MouseEvent structures with scancode/keycode/modifiers, Step 3: Add factory function createInputInjector() | Restrictions: Interface must be platform-agnostic, Structures must support both platforms, Keep overhead minimal | Success: Interface is well-defined, Event structures support both platforms, Factory function declared, Compiles on both platforms | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.14 Create InputInjectorWin32 implementation\n  - File: src/platform/win32/input_injector_win32.cpp\n  - Implement IInputInjector for Windows using SendInput\n  - Map virtual keycodes and scan codes\n  - _Leverage: src/platform/input_injector.h_\n  - _Requirements: FR-1.3_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Implement IInputInjector for Windows - Step 1: Create InputInjectorWin32 class implementing IInputInjector, Step 2: Use SendInput API for all injection methods, Step 3: Map KeyEvent to INPUT structure with KEYEVENTF_SCANCODE, Step 4: Map MouseEvent to INPUT structure, Step 5: Implement factory function returning InputInjectorWin32 | Restrictions: Use SendInput not keybd_event/mouse_event (deprecated), Maintain existing Windows input behavior, Handle extended scancodes correctly | Success: All methods implemented, Windows input injection works, Key remapping works as before, No regressions in input handling | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.15 Create InputInjectorLinux implementation\n  - File: src/platform/linux/input_injector_linux.cpp\n  - Implement IInputInjector for Linux using XTest extension\n  - Map keycodes between platforms\n  - _Leverage: src/platform/input_injector.h_\n  - _Requirements: FR-1.3_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with X11 and XTest expertise | Task: Implement IInputInjector for Linux - Step 1: Create InputInjectorLinux class implementing IInputInjector, Step 2: Use XTestFakeKeyEvent for keyboard injection, Step 3: Use XTestFakeButtonEvent for mouse buttons, Step 4: Use XTestFakeMotionEvent for mouse movement, Step 5: Map Windows scancodes to X11 keycodes using lookup table, Step 6: Implement factory function returning InputInjectorLinux | Restrictions: Use XTest extension correctly, Build keycode mapping table for common keys, Ensure XFlush called after injection | Success: All methods implemented, Linux input injection works, Key remapping functional, Keycode mapping covers all common keys | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.16 Create IInputHook interface\n  - File: src/platform/input_hook.h\n  - Define abstract interface for input hooking\n  - Include callback mechanism for key events\n  - _Leverage: src/platform/types.h, design.md Section 1.4_\n  - _Requirements: FR-1.4_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Define abstract IInputHook interface for input hooking - Methods: install, uninstall, isInstalled, setCallback - Step 1: Create pure virtual interface, Step 2: Define HookCallback function type taking KeyEvent and returning bool (true = consume event), Step 3: Add factory function createInputHook() | Restrictions: Interface must support both polling (Windows) and event-driven (Linux) models, Callback must be thread-safe, Keep overhead minimal | Success: Interface is well-defined, Callback mechanism flexible, Factory function declared, Compiles on both platforms | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.17 Create InputHookWin32 implementation\n  - File: src/platform/win32/input_hook_win32.cpp\n  - Implement IInputHook for Windows using low-level keyboard hook\n  - Handle hook callback and event filtering\n  - _Leverage: src/platform/input_hook.h_\n  - _Requirements: FR-1.4_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Implement IInputHook for Windows - Step 1: Create InputHookWin32 class implementing IInputHook, Step 2: Use SetWindowsHookEx with WH_KEYBOARD_LL, Step 3: In hook procedure convert KBDLLHOOKSTRUCT to KeyEvent and invoke callback, Step 4: Return 1 if callback returns true (consume), otherwise CallNextHookEx, Step 5: Implement install/uninstall managing hook handle | Restrictions: Maintain existing Windows hook behavior, Ensure thread-safety in callback invocation, Handle hook errors gracefully | Success: Hook installs correctly, Callbacks invoked properly, Event consumption works, Key remapping functional, No crashes or hangs | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.18 Create InputHookLinux implementation\n  - File: src/platform/linux/input_hook_linux.cpp\n  - Implement IInputHook for Linux using XRecord extension\n  - Handle asynchronous event callbacks\n  - _Leverage: src/platform/input_hook.h_\n  - _Requirements: FR-1.4_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with X11 and XRecord expertise | Task: Implement IInputHook for Linux - Step 1: Create InputHookLinux class implementing IInputHook, Step 2: Use XRecordCreateContext to capture KeyPress/KeyRelease events, Step 3: Run XRecordEnableContext in separate thread for event loop, Step 4: In callback convert XRecordInterceptData to KeyEvent and invoke user callback, Step 5: Use XRecordDisableContext to consume events when callback returns true | Restrictions: Use XRecord extension correctly, Handle threading properly (XRecord runs in separate thread), Ensure proper synchronization with main thread | Success: Hook captures events, Callbacks work correctly, Event consumption works, Key remapping functional, Thread-safe implementation | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.19 Create ShowCommand enum\n  - File: src/platform/types.h\n  - Define platform-agnostic show command enum\n  - Replace SW_HIDE, SW_SHOW, SW_MINIMIZE, etc.\n  - _Leverage: design.md Section 1.5_\n  - _Requirements: FR-1.5_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Create platform-agnostic ShowCommand enum - Step 1: Define enum class ShowCommand with values Hide, Show, ShowNormal, ShowMinimized, ShowMaximized, Restore, Step 2: Add utility function toShowCommand(int win32Code) for Windows conversion, Step 3: Document each enum value | Restrictions: Must cover all used SW_* constants, Ensure enum is type-safe, Keep mapping straightforward | Success: Enum defined, All SW_* constants covered, Conversion function works, Compiles on both platforms | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.20 Replace SW_HIDE in window management code\n  - Files: src/core/window_manager.cpp, src/ui/qt/main_window.cpp\n  - Replace SW_HIDE with ShowCommand::Hide\n  - Update showWindow calls\n  - _Leverage: src/platform/types.h, src/platform/window_system.h_\n  - _Requirements: FR-1.5_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Replace SW_HIDE with ShowCommand::Hide - Step 1: Search for all SW_HIDE usages with grep, Step 2: Replace with ShowCommand::Hide, Step 3: Update function calls from showWindow(hwnd, SW_HIDE) to windowSystem->showWindow(handle, ShowCommand::Hide), Step 4: Verify build on both platforms | Restrictions: Maintain window hiding behavior, Do not break other window operations, Ensure Linux implementation handles Hide correctly | Success: No SW_HIDE references remain, Windows hiding works on both platforms, Builds successfully | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.21 Replace SW_SHOW and SW_SHOWNORMAL\n  - Files: src/core/window_manager.cpp, src/ui/qt/main_window.cpp\n  - Replace with ShowCommand::Show and ShowCommand::ShowNormal\n  - Update window display logic\n  - _Leverage: src/platform/types.h, src/platform/window_system.h_\n  - _Requirements: FR-1.5_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Replace SW_SHOW and SW_SHOWNORMAL - Step 1: Search for SW_SHOW and SW_SHOWNORMAL with grep, Step 2: Replace with ShowCommand::Show and ShowCommand::ShowNormal, Step 3: Update showWindow calls, Step 4: Verify window showing works on both platforms | Restrictions: Maintain window showing behavior exactly, Handle differences between Show and ShowNormal correctly, Ensure Linux XMapWindow works | Success: No SW_SHOW/SW_SHOWNORMAL references, Window showing works on both platforms, Builds successfully | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.22 Replace SW_MINIMIZE and SW_MAXIMIZE\n  - Files: src/core/window_manager.cpp\n  - Replace with ShowCommand::ShowMinimized and ShowCommand::ShowMaximized\n  - Update window state management\n  - _Leverage: src/platform/types.h, src/platform/window_system.h_\n  - _Requirements: FR-1.5_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Replace SW_MINIMIZE and SW_MAXIMIZE - Step 1: Search for SW_MINIMIZE and SW_MAXIMIZE with grep, Step 2: Replace with ShowCommand::ShowMinimized and ShowCommand::ShowMaximized, Step 3: Update showWindow calls, Step 4: Verify window state changes work on Linux using _NET_WM_STATE | Restrictions: Maintain window state behavior, Ensure Linux implementation uses EWMH _NET_WM_STATE_MAXIMIZED_VERT/_HORZ correctly | Success: No SW_MINIMIZE/SW_MAXIMIZE references, Window state changes work on both platforms, EWMH properties set correctly | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.23 Create IIPCChannel interface\n  - File: src/platform/ipc_channel.h\n  - Define abstract interface for IPC communication\n  - Support message passing between instances\n  - _Leverage: design.md Section 1.6_\n  - _Requirements: FR-1.8_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Define abstract IIPCChannel interface for IPC - Methods: send, setMessageHandler, connect, disconnect - Step 1: Create pure virtual interface, Step 2: Define MessageHandler callback taking message data, Step 3: Add factory function createIPCChannel(instanceId) | Restrictions: Interface must support both Windows messages and Linux signals/sockets, Keep message format flexible, Support bidirectional communication | Success: Interface is well-defined, Callback mechanism works, Factory function declared, Compiles on both platforms | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.24 Create IPCChannelWin32 implementation\n  - File: src/platform/win32/ipc_channel_win32.cpp\n  - Implement IIPCChannel using Windows messages\n  - Create hidden window for message handling\n  - _Leverage: src/platform/ipc_channel.h_\n  - _Requirements: FR-1.8_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Implement IIPCChannel for Windows - Step 1: Create IPCChannelWin32 class implementing IIPCChannel, Step 2: Create hidden window with unique class name for receiving messages, Step 3: Use FindWindow to locate other instances, Step 4: Use SendMessage/PostMessage to send data, Step 5: Use WM_COPYDATA for message payload, Step 6: In WndProc invoke MessageHandler callback | Restrictions: Maintain existing IPC behavior for reload/exit commands, Handle multiple instances correctly, Ensure messages delivered reliably | Success: IPC works between instances, Reload and exit commands functional, Messages delivered correctly, No message loss | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.25 Create IPCChannelLinux implementation\n  - File: src/platform/linux/ipc_channel_linux.cpp\n  - Implement IIPCChannel using Unix domain sockets\n  - Handle socket lifecycle and message protocol\n  - _Leverage: src/platform/ipc_channel.h_\n  - _Requirements: FR-1.8_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with Unix IPC expertise | Task: Implement IIPCChannel for Linux - Step 1: Create IPCChannelLinux class implementing IIPCChannel, Step 2: Use Unix domain socket at /tmp/yamy-{instanceId}.sock, Step 3: In connect create and bind socket then listen for connections, Step 4: In send connect to remote socket and write message, Step 5: Run accept loop in thread invoking MessageHandler for received messages, Step 6: Handle socket cleanup on disconnect | Restrictions: Use Unix domain sockets correctly, Handle socket errors gracefully, Ensure thread-safe message handling, Clean up socket files | Success: IPC works between instances, Socket communication reliable, Thread-safe implementation, Socket files cleaned up on exit | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.26 Replace PostMessage in engine.cpp\n  - File: src/core/engine.cpp\n  - Replace PostMessage with IIPCChannel::send\n  - Update IPC initialization and message handling\n  - _Leverage: src/platform/ipc_channel.h_\n  - _Requirements: FR-1.8_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Replace PostMessage with IIPCChannel - Step 1: Search for PostMessage calls with grep, Step 2: Add IIPCChannel* m_ipcChannel member to Engine class, Step 3: In constructor call createIPCChannel(\"yamy-main\") and store in m_ipcChannel, Step 4: Replace PostMessage(hwnd, msg, wparam, lparam) with m_ipcChannel->send(message), Step 5: Set message handler to process reload/exit commands | Restrictions: Maintain existing IPC behavior, Ensure message commands still work, Handle IPC errors gracefully | Success: No PostMessage calls remain, IPC works on both platforms, Reload and exit functional, Builds successfully | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.27 Update main.cpp IPC handling\n  - File: src/app/main.cpp\n  - Replace FindWindow and SendMessage with IIPCChannel\n  - Update single instance check\n  - _Leverage: src/platform/ipc_channel.h_\n  - _Requirements: FR-1.8_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Update main.cpp IPC handling - Step 1: Replace FindWindow with attempt to connect to IPC channel, Step 2: If connection succeeds another instance exists, send command and exit, Step 3: If connection fails this is first instance, create IPC channel for listening, Step 4: Remove all Windows message loop code from main | Restrictions: Maintain single instance behavior, Ensure command-line args sent to running instance correctly, Handle first run vs subsequent runs | Success: Single instance detection works, Commands sent correctly to running instance, First instance listens properly, Builds on both platforms | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.28 Create platform initialization in main.cpp\n  - File: src/app/main.cpp\n  - Initialize platform subsystems at startup\n  - Clean up platform resources on exit\n  - _Leverage: src/platform/window_system.h, src/platform/input_hook.h, src/platform/input_injector.h_\n  - _Requirements: FR-1.1, FR-1.3, FR-1.4_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Create platform initialization in main - Step 1: Add platform init code after QApplication construction: auto windowSystem = createWindowSystem(), auto inputHook = createInputHook(), auto inputInjector = createInputInjector(), Step 2: Pass these to Engine constructor, Step 3: Ensure proper cleanup on exit | Restrictions: Initialize in correct order, Handle initialization failures, Ensure cleanup happens even on errors | Success: Platform initialized correctly, Engine receives platform interfaces, Cleanup works properly, No resource leaks | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.29 Update Engine constructor to accept platform interfaces\n  - File: src/core/engine.h, src/core/engine.cpp\n  - Add parameters for platform interfaces\n  - Store interfaces as member variables\n  - _Leverage: src/platform/window_system.h, src/platform/input_hook.h, src/platform/input_injector.h_\n  - _Requirements: FR-1.1, FR-1.3, FR-1.4_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Update Engine constructor to accept platform interfaces - Step 1: Add parameters Engine(IWindowSystem* ws, IInputHook* ih, IInputInjector* ii, IIPCChannel* ipc), Step 2: Add member variables storing these pointers, Step 3: Update initialization code to use interfaces instead of direct Win32 calls, Step 4: Update all call sites | Restrictions: Maintain Engine behavior, Ensure all dependencies injected properly, Handle null pointers defensively | Success: Engine constructor updated, Platform interfaces stored, All call sites updated, Builds on both platforms | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.30 Replace direct Win32 calls in Engine with platform interfaces\n  - File: src/core/engine.cpp\n  - Replace GetForegroundWindow with windowSystem->getForegroundWindow()\n  - Replace SendInput with inputInjector->injectKey()\n  - _Leverage: src/platform/window_system.h, src/platform/input_injector.h_\n  - _Requirements: FR-1.1, FR-1.3_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Replace direct Win32 calls in Engine - Step 1: Search for GetForegroundWindow, GetWindowText, GetClassName calls with grep, Step 2: Replace with m_windowSystem->getForegroundWindow(), m_windowSystem->getWindowText(), etc, Step 3: Search for SendInput, keybd_event calls, Step 4: Replace with m_inputInjector->injectKeyDown/injectKeyUp, Step 5: Verify all Win32 API calls removed | Restrictions: Maintain exact engine behavior, Ensure key remapping still works correctly, Handle errors from platform interfaces | Success: No direct Win32 calls in Engine, Platform interfaces used throughout, Engine works on both platforms, Key remapping functional | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.31 Add Linux-specific build flags and dependencies\n  - File: CMakeLists.txt\n  - Add X11, XTest, XRecord library dependencies for Linux\n  - Add conditional compilation flags\n  - _Leverage: CMakeLists.txt_\n  - _Requirements: FR-1.1, FR-1.3, FR-1.4_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with CMake expertise | Task: Add Linux build dependencies - Step 1: Add find_package(X11 REQUIRED), find_package(XTest REQUIRED) for Linux, Step 2: Add target_link_libraries with X11, Xtst, Xrecord for Linux target, Step 3: Add platform-specific source files to build: src/platform/linux/*.cpp, Step 4: Add preprocessor defines for platform detection | Restrictions: Maintain Windows build compatibility, Use modern CMake patterns, Ensure all Linux libraries found correctly | Success: CMake finds all Linux dependencies, Linux build compiles successfully, Both platforms build without issues, Libraries linked correctly | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.1.32 Add platform-specific source files to build system\n  - File: CMakeLists.txt\n  - Conditionally compile Win32 and Linux platform implementations\n  - Organize platform code properly\n  - _Leverage: CMakeLists.txt_\n  - _Requirements: FR-1.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with CMake expertise | Task: Add platform-specific source files - Step 1: Create source lists for each platform: WIN32_SOURCES (src/platform/win32/*.cpp), LINUX_SOURCES (src/platform/linux/*.cpp), COMMON_SOURCES (src/platform/*.cpp shared), Step 2: Use if(WIN32) to add WIN32_SOURCES, if(UNIX AND NOT APPLE) to add LINUX_SOURCES, Step 3: Verify both platforms build correctly | Restrictions: Keep build system clean and maintainable, Ensure correct files compiled per platform, Avoid duplicate symbols | Success: Platform files compiled correctly per platform, No symbol conflicts, Both Windows and Linux build successfully, Build system is maintainable | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n### Batch 2: Integration (18 tasks - PARALLEL within batch, SEQUENTIAL after Batch 1)\n\n- [ ] 1.2.1 Update window context tracking in Engine\n  - File: src/core/engine.cpp\n  - Replace HWND-based window context with WindowHandle\n  - Update window focus tracking logic\n  - _Leverage: src/platform/window_system.h, src/platform/types.h_\n  - _Requirements: FR-1.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Update window context tracking - Step 1: Change HWND m_focusedWindow to WindowHandle m_focusedWindow, Step 2: Update updateContext() to use windowSystem->getForegroundWindow(), Step 3: Update window class and title retrieval to use windowSystem methods, Step 4: Verify context-dependent keymapping works | Restrictions: Maintain window context behavior exactly, Ensure per-window keymaps work, Handle invalid windows gracefully | Success: Window context tracked correctly on both platforms, Per-window keymaps functional, Window focus changes detected, Context updates work reliably | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.2 Update keymap activation logic\n  - File: src/core/keymap_layer.cpp\n  - Update condition evaluation for window-based activation\n  - Use platform abstractions for window matching\n  - _Leverage: src/platform/window_system.h_\n  - _Requirements: FR-1.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Update keymap activation logic - Step 1: Update condition evaluation in KeymapLayer::shouldActivate, Step 2: Replace direct window API calls with windowSystem methods, Step 3: Ensure regex matching works with UTF-8 strings, Step 4: Test activation with various window title/class patterns | Restrictions: Maintain activation behavior, Ensure all condition types still work (WindowClass, WindowTitle, etc), Handle UTF-8 properly | Success: Keymap activation works correctly, All condition types functional, Regex patterns match properly, Works on both platforms | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.3 Update modifier state tracking\n  - File: src/core/modifier_state.cpp\n  - Track modifier state using platform-agnostic key codes\n  - Update modifier key detection\n  - _Leverage: src/platform/input_hook.h_\n  - _Requirements: FR-1.4_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Update modifier state tracking - Step 1: Update ModifierState to use platform-agnostic KeyEvent structure, Step 2: Update modifier detection from KeyEvent scancode/keycode, Step 3: Handle both Windows scancodes and Linux keycodes, Step 4: Ensure modifier combinations tracked correctly | Restrictions: Maintain modifier tracking accuracy, Support all modifier keys (Ctrl, Alt, Shift, Win/Super), Handle left/right modifiers separately if needed | Success: Modifier state tracked correctly, All modifiers detected properly, Modifier combinations work, Works on both platforms | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.4 Update key event processing in Engine\n  - File: src/core/engine.cpp\n  - Process KeyEvent structure from input hook\n  - Update event filtering and transformation\n  - _Leverage: src/platform/input_hook.h, src/core/modifier_state.cpp_\n  - _Requirements: FR-1.4_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Update key event processing - Step 1: Update hook callback to receive KeyEvent instead of Windows KBDLLHOOKSTRUCT, Step 2: Update event processing logic to use KeyEvent fields, Step 3: Update modifier state from KeyEvent, Step 4: Update keymap matching using KeyEvent, Step 5: Return true to consume or false to pass through | Restrictions: Maintain event processing behavior, Ensure all key events handled correctly, Preserve event timing and ordering | Success: Key events processed correctly, Event consumption works, Modifier tracking accurate, Key remapping functional on both platforms | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.5 Update key injection in action execution\n  - File: src/core/action.cpp\n  - Use IInputInjector for key injection in actions\n  - Update all action types that inject keys\n  - _Leverage: src/platform/input_injector.h_\n  - _Requirements: FR-1.3_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer refactoring cross-platform keyboard remapping utility | Task: Update key injection in actions - Step 1: Update Action::execute to accept IInputInjector* parameter, Step 2: Replace SendInput calls with inputInjector->injectKeyDown/injectKeyUp, Step 3: Update KeyAction, ModifierAction, StringAction to use injector, Step 4: Ensure key sequences injected correctly | Restrictions: Maintain action behavior exactly, Preserve key injection timing, Handle all action types correctly | Success: All actions use IInputInjector, Key injection works correctly, Action behavior unchanged, Works on both platforms | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.6 Update MainWindow to use IWindowSystem\n  - File: src/ui/qt/main_window.cpp\n  - Replace direct window API calls with IWindowSystem\n  - Update window management in GUI\n  - _Leverage: src/platform/window_system.h_\n  - _Requirements: FR-1.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with Qt expertise | Task: Update MainWindow to use IWindowSystem - Step 1: Add IWindowSystem* m_windowSystem member to MainWindow, Step 2: Accept IWindowSystem in constructor, Step 3: Replace ShowWindow calls with m_windowSystem->showWindow, Step 4: Update window enumeration in investigate dialog to use m_windowSystem->enumWindows | Restrictions: Maintain GUI behavior, Ensure dialogs display correctly, Handle window operations properly | Success: MainWindow uses IWindowSystem, Window operations work correctly, Dialogs display properly, Works on both platforms | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.7 Test basic key remapping on Linux\n  - Test environment: Linux system with X11\n  - Verify basic key remapping works\n  - Test modifier keys and combinations\n  - _Leverage: test .mayu configs, src/core/engine.cpp_\n  - _Requirements: FR-1.1, FR-1.3, FR-1.4_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with Linux system expertise | Task: Test basic key remapping on Linux - Step 1: Create test .mayu config with simple remaps (e.g. a to b), Step 2: Start YAMY on Linux, Step 3: Test basic key remapping in various applications, Step 4: Test modifier keys (Ctrl, Alt, Shift), Step 5: Test modifier combinations, Step 6: Document any issues found | Restrictions: Use real X11 environment (not Wayland), Test in multiple applications (terminal, browser, editor), Verify events not duplicated | Success: Basic remapping works, Modifier keys work correctly, Combinations functional, No event duplication, Key presses recognized reliably | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.8 Test window-context dependent keymaps on Linux\n  - Test environment: Linux with multiple applications\n  - Verify window title/class matching works\n  - Test keymap switching between windows\n  - _Leverage: test .mayu configs with window conditions_\n  - _Requirements: FR-1.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with Linux system expertise | Task: Test window-context keymaps - Step 1: Create .mayu config with window-specific keymaps using window class/title conditions, Step 2: Start YAMY, Step 3: Switch between applications and verify correct keymap activates, Step 4: Test window title patterns with regex, Step 5: Test window class matching, Step 6: Document any window detection issues | Restrictions: Test with real applications (Firefox, Gnome Terminal, etc), Verify X11 window properties retrieved correctly, Test focus change detection | Success: Window contexts detected correctly, Keymaps switch properly between windows, Title and class patterns match, Focus changes handled, No keymap activation delays | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.9 Test IPC between multiple instances on Linux\n  - Test environment: Linux system\n  - Verify single instance detection works\n  - Test reload and exit commands via IPC\n  - _Leverage: src/platform/linux/ipc_channel_linux.cpp_\n  - _Requirements: FR-1.8_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with Linux IPC expertise | Task: Test IPC on Linux - Step 1: Start first YAMY instance, Step 2: Attempt to start second instance and verify it exits, Step 3: Send reload command via yamy --reload and verify first instance reloads, Step 4: Send exit command via yamy --exit and verify first instance exits, Step 5: Verify socket files cleaned up, Step 6: Test error handling when socket locked | Restrictions: Test with real Unix domain sockets, Verify socket cleanup, Test permission issues, Check /tmp/yamy-*.sock files | Success: Single instance works, Reload command functional, Exit command functional, Socket cleanup works, No orphaned sockets, Error handling correct | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.10 Fix compilation errors in Core module\n  - Files: src/core/*.cpp\n  - Fix any remaining type mismatches and API changes\n  - Resolve linker errors\n  - _Leverage: Compiler error messages_\n  - _Requirements: FR-1.1 through FR-1.8_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer | Task: Fix compilation errors in Core - Step 1: Run cmake and make on Linux, Step 2: Fix tstring-related errors, Step 3: Fix HWND-related errors, Step 4: Fix missing include directives, Step 5: Fix linker errors for platform functions, Step 6: Iterate until Core module compiles cleanly | Restrictions: Fix errors without changing behavior, Add includes as needed, Ensure Windows build not broken | Success: Core module compiles on Linux, No compiler errors, No linker errors, Windows build still works, All platform abstractions used correctly | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.11 Fix compilation errors in UI module\n  - Files: src/ui/qt/*.cpp\n  - Fix Qt-specific compilation issues\n  - Resolve UI-related type mismatches\n  - _Leverage: Compiler error messages_\n  - _Requirements: FR-1.1, FR-1.5_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with Qt expertise | Task: Fix compilation errors in UI - Step 1: Run cmake and make on Linux, Step 2: Fix tstring to QString conversion issues, Step 3: Fix ShowCommand usage, Step 4: Fix include directives for Qt headers, Step 5: Iterate until UI module compiles cleanly | Restrictions: Fix errors without breaking UI behavior, Ensure QString UTF-8 handling correct, Maintain Qt best practices | Success: UI module compiles on Linux, No compiler errors, Qt integration works, Windows build unaffected, GUI displays correctly | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.12 Fix compilation errors in Platform module\n  - Files: src/platform/linux/*.cpp, src/platform/win32/*.cpp\n  - Fix platform-specific compilation issues\n  - Resolve X11 and Win32 API usage errors\n  - _Leverage: Compiler error messages_\n  - _Requirements: FR-1.1 through FR-1.8_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with platform API expertise | Task: Fix compilation errors in Platform - Step 1: Run cmake and make on Linux, Step 2: Fix X11 API usage errors, Step 3: Fix include directives for X11 headers, Step 4: Fix XTest and XRecord usage, Step 5: Verify Windows platform code still compiles, Step 6: Iterate until Platform module compiles cleanly on both platforms | Restrictions: Ensure proper X11 header includes, Link against correct libraries, Maintain Windows compatibility | Success: Platform module compiles on Linux, Windows code still compiles, No API usage errors, Libraries linked correctly, Both platforms build successfully | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.13 Create unit tests for WindowSystemLinux\n  - File: tests/platform/window_system_linux_test.cpp\n  - Test X11 window operations\n  - Verify EWMH property handling\n  - _Leverage: src/platform/linux/window_system_linux.cpp, tests/helpers/x11_test_utils.cpp_\n  - _Requirements: FR-1.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with X11 expertise | Task: Create unit tests for WindowSystemLinux - Step 1: Create test fixture with mock X11 display, Step 2: Test getForegroundWindow returns correct window, Step 3: Test getWindowText retrieves _NET_WM_NAME correctly, Step 4: Test getWindowClassName retrieves WM_CLASS correctly, Step 5: Test showWindow with various ShowCommand values, Step 6: Test moveWindow changes window geometry | Restrictions: Use mock X11 functions or test in controlled environment, Ensure tests run in CI without X11 server, Test error handling | Success: All WindowSystemLinux methods tested, Tests pass reliably, Edge cases covered, Error handling verified, Tests run in CI | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.14 Create unit tests for InputInjectorLinux\n  - File: tests/platform/input_injector_linux_test.cpp\n  - Test XTest input injection\n  - Verify keycode mapping\n  - _Leverage: src/platform/linux/input_injector_linux.cpp, tests/helpers/x11_test_utils.cpp_\n  - _Requirements: FR-1.3_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with X11 and input system expertise | Task: Create unit tests for InputInjectorLinux - Step 1: Create test fixture with mock X11 display, Step 2: Test injectKeyDown/injectKeyUp generate correct XTest events, Step 3: Test keycode mapping from Windows scancodes to X11 keycodes, Step 4: Test mouse button and motion injection, Step 5: Test modifier key injection, Step 6: Verify XFlush called after injection | Restrictions: Mock XTest functions or use test environment, Ensure tests reliable, Test keycode mapping for common keys | Success: All InputInjectorLinux methods tested, XTest usage verified, Keycode mapping tested for 50+ keys, Mouse injection tested, Tests pass reliably | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.15 Create unit tests for InputHookLinux\n  - File: tests/platform/input_hook_linux_test.cpp\n  - Test XRecord event capture\n  - Verify callback invocation and event consumption\n  - _Leverage: src/platform/linux/input_hook_linux.cpp, tests/helpers/x11_test_utils.cpp_\n  - _Requirements: FR-1.4_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with X11 and threading expertise | Task: Create unit tests for InputHookLinux - Step 1: Create test fixture with mock XRecord functions, Step 2: Test install creates XRecord context, Step 3: Test callback invoked when key event captured, Step 4: Test event consumption when callback returns true, Step 5: Test thread-safety of callback invocation, Step 6: Test uninstall cleans up properly | Restrictions: Mock XRecord or use test environment, Test threading behavior, Ensure tests don't interfere with system | Success: All InputHookLinux methods tested, Callback behavior verified, Event consumption tested, Thread-safety confirmed, Cleanup verified, Tests pass reliably | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.16 Create unit tests for IPCChannelLinux\n  - File: tests/platform/ipc_channel_linux_test.cpp\n  - Test Unix domain socket communication\n  - Verify message sending and receiving\n  - _Leverage: src/platform/linux/ipc_channel_linux.cpp, tests/helpers/socket_test_utils.cpp_\n  - _Requirements: FR-1.8_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with Unix IPC expertise | Task: Create unit tests for IPCChannelLinux - Step 1: Create test fixture with temp socket paths, Step 2: Test connect creates and binds socket, Step 3: Test send delivers message to remote socket, Step 4: Test MessageHandler callback invoked on message receipt, Step 5: Test disconnect cleans up socket file, Step 6: Test error handling for connection failures | Restrictions: Use temporary socket paths for testing, Clean up sockets after tests, Test thread-safety, Verify file permissions | Success: All IPCChannelLinux methods tested, Socket communication verified, Callback behavior tested, Cleanup confirmed, Error handling tested, Tests pass reliably | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.17 Add integration test for full key remapping flow\n  - File: tests/integration/key_remapping_integration_test.cpp\n  - Test end-to-end key remapping on Linux\n  - Verify hook  engine  injection flow\n  - _Leverage: All platform implementations, src/core/engine.cpp_\n  - _Requirements: All FR-1 requirements_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with integration testing expertise | Task: Create integration test for key remapping - Step 1: Create test fixture initializing all platform components, Step 2: Create Engine with platform interfaces, Step 3: Load test .mayu config with simple remap, Step 4: Simulate key event via input hook, Step 5: Verify engine processes event correctly, Step 6: Verify correct key injected via input injector, Step 7: Test modifier combinations, Step 8: Test window-context switching | Restrictions: Use mocks where needed to avoid system interference, Test full flow from hook to injection, Verify event ordering | Success: Integration test passes, Full remapping flow verified, Event flow correct, Modifier handling works, Context switching works, Test reliable and reproducible | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.2.18 Document platform abstraction architecture\n  - File: docs/architecture/platform-abstraction.md\n  - Document interface design and implementation strategy\n  - Provide examples for future platform additions\n  - _Leverage: src/platform/*.h, design.md_\n  - _Requirements: FR-1.1 through FR-1.8_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer with C++ expertise | Task: Document platform abstraction - Step 1: Create architecture document describing interface design, Step 2: Document each platform interface (IWindowSystem, IInputInjector, IInputHook, IIPCChannel), Step 3: Explain Windows and Linux implementations, Step 4: Provide code examples showing usage, Step 5: Add guidelines for adding new platforms, Step 6: Document type abstractions (WindowHandle, ShowCommand) | Restrictions: Keep documentation clear and concise, Use code examples, Include diagrams if helpful, Ensure accuracy | Success: Documentation complete and accurate, All interfaces documented, Implementation strategies explained, Examples provided, Guidelines for future platforms clear | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n### Batch 3: Polish (10 tasks - PARALLEL within batch, SEQUENTIAL after Batch 2)\n\n- [ ] 1.3.1 Add error handling for X11 connection failures\n  - Files: src/platform/linux/window_system_linux.cpp, src/platform/linux/input_injector_linux.cpp, src/platform/linux/input_hook_linux.cpp\n  - Handle XOpenDisplay failures gracefully\n  - Provide user-friendly error messages\n  - _Leverage: src/utils/errorHandler.cpp_\n  - _Requirements: NF-4 Reliability_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with X11 expertise | Task: Add error handling for X11 failures - Step 1: Check XOpenDisplay return value, throw exception if null, Step 2: Add try-catch in factory functions to catch X11 errors, Step 3: Display user-friendly error message suggesting DISPLAY env check, Step 4: Add XSetErrorHandler to catch X11 protocol errors, Step 5: Log X11 errors for debugging | Restrictions: Don't crash on X11 errors, Provide actionable error messages, Log errors for troubleshooting | Success: X11 connection failures handled gracefully, User-friendly errors displayed, No crashes on X11 errors, Errors logged appropriately | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.3.2 Add error handling for XTest/XRecord unavailable\n  - Files: src/platform/linux/input_injector_linux.cpp, src/platform/linux/input_hook_linux.cpp\n  - Check for XTest and XRecord extensions\n  - Fail gracefully if extensions missing\n  - _Leverage: src/utils/errorHandler.cpp_\n  - _Requirements: NF-4 Reliability_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with X11 expertise | Task: Add error handling for missing extensions - Step 1: Call XTestQueryExtension and XRecordQueryVersion to check availability, Step 2: Throw exception with clear message if extension missing, Step 3: Suggest installing xserver-xorg-input-all or similar package, Step 4: Add extension check to factory functions | Restrictions: Check extensions early in initialization, Provide helpful installation instructions, Don't proceed without required extensions | Success: Missing extensions detected, User-friendly error with install instructions, No crashes, Application fails safely | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.3.3 Add logging for platform operations\n  - Files: src/platform/linux/*.cpp, src/platform/win32/*.cpp\n  - Add debug logging for window operations, input events, IPC\n  - Use consistent logging format\n  - _Leverage: src/utils/logger.cpp_\n  - _Requirements: NF-4 Reliability, NF-6 Security_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer | Task: Add logging for platform operations - Step 1: Add log statements in window operations (getForegroundWindow, getWindowText, etc), Step 2: Log input events in hook callbacks (key down/up with scancode), Step 3: Log IPC messages (send/receive), Step 4: Use log levels appropriately (DEBUG for frequent events, INFO for important operations, ERROR for failures), Step 5: Ensure no PII logged | Restrictions: Use structured logging, Don't log sensitive data, Keep overhead minimal, Use appropriate log levels | Success: Platform operations logged, Logs help debugging, No PII in logs, Logging overhead acceptable, Both platforms have consistent logging | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.3.4 Optimize X11 window text retrieval\n  - File: src/platform/linux/window_system_linux.cpp\n  - Cache window properties to reduce X11 round-trips\n  - Implement efficient property retrieval\n  - _Leverage: X11 XGetWindowProperty API_\n  - _Requirements: NF-1 Performance_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with X11 performance expertise | Task: Optimize window text retrieval - Step 1: Implement property cache with timeout, Step 2: Retrieve _NET_WM_NAME and WM_NAME in single call if possible, Step 3: Use XGetWindowProperty efficiently (check property existence first), Step 4: Add cache invalidation on window change events, Step 5: Benchmark and ensure <10ms retrieval time | Restrictions: Maintain correctness, Ensure cache doesn't serve stale data, Keep memory overhead minimal | Success: Window text retrieval <10ms, Cache reduces X11 calls by 80%, No stale data served, Memory overhead <1KB per window, Performance measurably improved | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.3.5 Optimize keycode mapping table\n  - File: src/platform/linux/input_injector_linux.cpp\n  - Pre-build keycode mapping table at initialization\n  - Use efficient lookup structure\n  - _Leverage: std::unordered_map_\n  - _Requirements: NF-1 Performance_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer | Task: Optimize keycode mapping - Step 1: Create static std::unordered_map<uint16_t, KeyCode> mapping Windows scancodes to X11 keycodes, Step 2: Initialize map at static initialization time, Step 3: Use const lookup in injectKey methods, Step 4: Benchmark and ensure <1s lookup time, Step 5: Cover all 100+ common keys | Restrictions: Use efficient data structure, Ensure complete key coverage, Keep lookup time minimal | Success: Keycode lookup <1s, All common keys covered, Map initialized efficiently, No runtime overhead, Both directions supported if needed | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.3.6 Add performance metrics collection\n  - File: src/utils/metrics.cpp, src/core/engine.cpp\n  - Collect latency metrics for key event processing\n  - Report average, p95, p99 latencies\n  - _Leverage: std::chrono_\n  - _Requirements: NF-1 Performance_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with performance monitoring expertise | Task: Add performance metrics - Step 1: Add metrics collection class with methods recordLatency(operation, duration), Step 2: Instrument Engine::processKeyEvent with timing measurement, Step 3: Instrument input hook callback, Step 4: Instrument input injection, Step 5: Compute and log average/p95/p99 every 60 seconds, Step 6: Add /metrics IPC command to query metrics | Restrictions: Keep instrumentation overhead minimal (<1% CPU), Use thread-safe collection, Don't impact key processing latency | Success: Metrics collected accurately, Overhead <1% CPU, Stats logged periodically, /metrics command works, Performance baseline established | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.3.7 Add memory leak detection\n  - Files: src/app/main.cpp, tests/leak_test.cpp\n  - Integrate AddressSanitizer or Valgrind checks\n  - Verify no memory leaks in platform code\n  - _Leverage: AddressSanitizer, Valgrind_\n  - _Requirements: NF-4 Reliability_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with memory debugging expertise | Task: Add memory leak detection - Step 1: Add CMake option to enable AddressSanitizer (ENABLE_ASAN), Step 2: Add compiler flags -fsanitize=address -fno-omit-frame-pointer when enabled, Step 3: Create leak test running full lifecycle (init, process events, cleanup), Step 4: Run test under ASAN and verify no leaks, Step 5: Document ASAN usage in docs, Step 6: Add Valgrind suppression file if needed | Restrictions: Ensure ASAN build works, Test covers all code paths, Fix any leaks found, Don't break release build | Success: ASAN build compiles, Leak test passes with no leaks, X11 resources freed properly, Platform code leak-free, Documentation updated | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.3.8 Add automated regression tests\n  - File: tests/regression/regression_suite.cpp\n  - Create test suite covering all platform functionality\n  - Run tests in CI pipeline\n  - _Leverage: Google Test, existing unit tests_\n  - _Requirements: NF-4 Reliability_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with CI/CD expertise | Task: Add regression tests - Step 1: Create regression test suite aggregating all unit tests, Step 2: Add integration tests to suite, Step 3: Configure CMake to build test suite, Step 4: Add CI job running test suite on every commit, Step 5: Ensure tests run without X11 server (use Xvfb), Step 6: Report test results and coverage | Restrictions: Tests must run in CI environment, Use Xvfb for X11 tests, Ensure tests don't interfere with each other, Require 80% coverage | Success: Regression suite runs in CI, All tests pass, Coverage 80%, Tests reliable, No flaky tests, CI reports results clearly | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.3.9 Add code quality checks to CI\n  - File: .github/workflows/ci.yml or similar\n  - Add linter (cpplint, clang-tidy), formatter (clang-format) checks\n  - Enforce code quality standards\n  - _Leverage: clang-tidy, clang-format_\n  - _Requirements: NF-5 Maintainability_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: DevOps Engineer with C++ tooling expertise | Task: Add code quality checks - Step 1: Add .clang-format config matching project style, Step 2: Add clang-format check to CI verifying all files formatted, Step 3: Add clang-tidy config with common checks enabled, Step 4: Add clang-tidy check to CI reporting violations, Step 5: Fix any violations found in platform code, Step 6: Document how to run locally | Restrictions: Use project coding style, Enable relevant checks (no noisy warnings), Fix violations before merging, Don't break build on warnings initially | Success: Linter and formatter configured, CI runs checks on every commit, Platform code passes all checks, Violations reported clearly, Documentation updated | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 1.3.10 Create platform abstraction migration guide\n  - File: docs/migration/platform-abstraction-migration.md\n  - Document migration from Win32 to platform abstraction\n  - Provide examples and common pitfalls\n  - _Leverage: Code changes from Track 1_\n  - _Requirements: NF-5 Maintainability_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer with C++ expertise | Task: Create migration guide - Step 1: Document step-by-step migration process from Win32 to platform abstraction, Step 2: Provide before/after code examples for common operations (window management, input injection, etc), Step 3: Document common pitfalls (string encoding, handle lifetime, thread-safety), Step 4: Add troubleshooting section for compilation errors, Step 5: Link to platform abstraction architecture doc | Restrictions: Keep guide practical with examples, Cover common issues, Ensure accuracy, Link to related docs | Success: Migration guide complete, Examples clear and tested, Common issues covered, Troubleshooting helpful, Guide follows documentation standards | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n---\n\n## Track 2: Configuration Management (15 tasks)\n\n**Purpose**: Implement multi-configuration support and GUI config management\n\n### Batch 1: Configuration Backend (8 tasks - ALL PARALLEL)\n\n- [ ] 2.1.1 Implement ConfigManager class\n  - File: src/core/settings/config_manager.h, src/core/settings/config_manager.cpp\n  - Manage list of available configurations\n  - Track active configuration\n  - _Leverage: src/core/settings/config_store.h_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer | Task: Implement ConfigManager - Create singleton managing vector of config file paths, Track active config index, Methods: listConfigs, getActiveConfig, setActiveConfig, addConfig, removeConfig, refreshList - Use ConfigStore for persistence, Scan ~/.yamy/ directory for .mayu files | Restrictions: Thread-safe access, Validate config paths exist, Handle missing files gracefully | Success: ConfigManager manages config list, Active config tracked, Persistence works, Thread-safe, Config scanning works | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.1.2 Add config switching API to Engine\n  - File: src/core/engine.h, src/core/engine.cpp\n  - Add method switchConfiguration(configPath)\n  - Reload parser and keymaps with new config\n  - _Leverage: src/core/settings/config_manager.h_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer | Task: Add config switching to Engine - Add method bool switchConfiguration(const std::string& configPath), Unload current keymaps, Parse new config file, Rebuild keymap tree, Update ConfigManager active config, Emit notification to GUI, Return false on parse errors | Restrictions: Handle parse errors gracefully, Maintain engine state, Don't crash on invalid config, Rollback on failure | Success: Config switching works, Keymaps reloaded correctly, Errors handled gracefully, GUI notified, No crashes on invalid config | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.1.3 Add config file validation\n  - File: src/core/parser/config_validator.h, src/core/parser/config_validator.cpp\n  - Validate .mayu syntax before loading\n  - Report specific errors with line numbers\n  - _Leverage: src/core/parser/parser.h_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer | Task: Implement config validator - Create ConfigValidator class, Method: vector<ValidationError> validate(configPath), Check syntax errors, Check semantic errors (undefined keys, circular references), Return errors with line numbers and messages, Use existing parser for syntax checking | Restrictions: Don't load config into engine, Fast validation (<100ms for typical config), Comprehensive error reporting | Success: Validator catches syntax errors, Semantic errors detected, Line numbers accurate, Fast validation, Error messages helpful | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.1.4 Add config file watcher\n  - File: src/core/settings/config_watcher.h, src/core/settings/config_watcher.cpp\n  - Watch active config file for changes\n  - Auto-reload on modification\n  - _Leverage: QFileSystemWatcher or inotify_\n  - _Requirements: FR-2.2_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer | Task: Implement config file watcher - Create ConfigWatcher class, Use QFileSystemWatcher on Qt platforms or inotify on Linux, Watch active config file path, On file modified signal call Engine::switchConfiguration, Add debouncing to avoid multiple reloads, Methods: start, stop, setConfigPath | Restrictions: Handle file deletion gracefully, Debounce rapid changes (300ms), Don't reload if parsing fails, Stop watching when disabled | Success: Watcher detects file changes, Auto-reload works, Debouncing prevents excessive reloads, File deletion handled, Can be disabled | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.1.5 Add config backup and restore\n  - File: src/core/settings/config_manager.cpp\n  - Backup config before modifications\n  - Allow restore from backup\n  - _Leverage: std::filesystem_\n  - _Requirements: FR-2.3_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer | Task: Implement config backup - Add methods to ConfigManager: createBackup(configPath) copies to .bak file with timestamp, listBackups(configPath) returns vector of backup paths, restoreBackup(backupPath) copies back to original, deleteBackup(backupPath), Keep max 10 backups per config, Auto-backup before any modification | Restrictions: Use filesystem copy, Handle copy errors, Limit backup count, Use safe file operations | Success: Backup creates .bak file with timestamp, Restore works correctly, Old backups deleted automatically, Backup limit enforced, File operations safe | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.1.6 Add config import/export\n  - File: src/core/settings/config_manager.cpp\n  - Export config with dependencies to archive\n  - Import config from archive\n  - _Leverage: libarchive or QZip_\n  - _Requirements: FR-2.4_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer | Task: Implement config import/export - Add methods to ConfigManager: exportConfig(configPath, archivePath) creates zip with config and included files, importConfig(archivePath, targetDir) extracts to target directory, Parse include directives to find dependencies, Validate archive contents on import, Use zip format for portability | Restrictions: Handle missing includes gracefully, Validate archive integrity, Don't overwrite without confirmation, Use standard zip format | Success: Export creates zip with all dependencies, Import extracts correctly, Include dependencies resolved, Archive validated, Portable across systems | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.1.7 Add config metadata storage\n  - File: src/core/settings/config_metadata.h, src/core/settings/config_metadata.cpp\n  - Store config name, description, author, last modified\n  - Persist metadata separately from .mayu file\n  - _Leverage: src/core/settings/config_store.h_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer | Task: Implement config metadata - Create ConfigMetadata class with fields: name, description, author, createdDate, modifiedDate, tags, Create metadata file .mayu.meta in JSON format alongside .mayu file, Methods: load, save, update, Store in ~/.yamy/.metadata/ directory, Auto-update modifiedDate on config changes | Restrictions: Use JSON format, Handle missing metadata gracefully, Don't require metadata, Auto-create if missing | Success: Metadata stored separately, JSON format parseable, Auto-updated on changes, Optional (works without), Backward compatible | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.1.8 Add config templates\n  - Files: src/resources/templates/default.mayu, src/resources/templates/emacs.mayu, src/resources/templates/vim.mayu\n  - Create preset configurations for common use cases\n  - Allow creating new config from template\n  - _Leverage: src/core/settings/config_manager.h_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Keyboard remapping expert | Task: Create config templates - Create 3 template configs: default.mayu (basic remaps, CapsLock to Ctrl), emacs.mayu (Emacs keybindings), vim.mayu (Vim keybindings in other apps), Include comments explaining each section, Add method to ConfigManager: createFromTemplate(templateName, targetPath), Copy template and update metadata | Restrictions: Templates must be valid .mayu files, Include helpful comments, Cover common use cases, Keep simple and understandable | Success: 3 templates created, Templates parse correctly, Templates functional, createFromTemplate works, Comments helpful | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n### Batch 2: Configuration GUI (7 tasks - PARALLEL within batch, SEQUENTIAL after Batch 1)\n\n- [ ] 2.2.1 Create configuration menu in system tray\n  - File: src/ui/qt/system_tray.cpp\n  - Add \"Configurations\" submenu to tray icon\n  - List available configs with checkmark on active\n  - _Leverage: QMenu, src/core/settings/config_manager.h_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Qt GUI developer | Task: Create configuration menu - Add QMenu* m_configMenu to SystemTray class, In buildMenu add submenu \"Configurations\", Populate submenu with config list from ConfigManager, Add checkmark (QAction::setCheckable) on active config, Connect action triggered to Engine::switchConfiguration, Add \"Manage Configurations...\" action opening dialog | Restrictions: Update menu dynamically when configs change, Show checkmark correctly, Handle long config lists gracefully | Success: Configuration submenu appears, Configs listed correctly, Active config has checkmark, Clicking switches config, Manage action opens dialog | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.2.2 Create ConfigManagerDialog GUI\n  - File: src/ui/qt/config_manager_dialog.h, src/ui/qt/config_manager_dialog.cpp, src/ui/qt/config_manager_dialog.ui\n  - GUI for managing configurations\n  - List, add, remove, rename, edit configs\n  - _Leverage: QDialog, QListWidget, src/core/settings/config_manager.h_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Qt GUI developer | Task: Create ConfigManagerDialog - Create QDialog with QListWidget showing configs, Add buttons: New, Duplicate, Delete, Rename, Edit, Import, Export, Set as Active, Each config item shows name and path, Double-click or Edit button opens config in default editor, Connect buttons to ConfigManager methods, Update list when configs change | Restrictions: Confirm before deleting, Validate names, Disable buttons when no selection, Update list dynamically | Success: Dialog displays config list, All buttons functional, Deletion requires confirmation, Names validated, Edit opens editor, List updates correctly | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.2.3 Add config editor integration\n  - File: src/ui/qt/config_manager_dialog.cpp\n  - Open config in external or internal editor\n  - Support for syntax-aware editors\n  - _Leverage: QProcess, QDesktopServices_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Qt GUI developer | Task: Add config editor integration - Add preference for editor command (default: xdg-open or system default), In Edit action: launch editor with QProcess or QDesktopServices::openUrl, On Windows use configured editor or notepad, On Linux use $EDITOR or xdg-open, Allow configuring editor in preferences, Show error if editor fails to launch | Restrictions: Handle editor launch failures, Support spaces in editor path, Use system defaults if not configured | Success: Edit action launches editor, Config file opened, Configurable editor works, System defaults used appropriately, Errors handled gracefully | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.2.4 Add config validation feedback in GUI\n  - File: src/ui/qt/config_manager_dialog.cpp\n  - Show validation status for each config\n  - Display errors inline with line numbers\n  - _Leverage: src/core/parser/config_validator.h_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Qt GUI developer | Task: Add validation feedback - Run ConfigValidator on each config in list, Show icon indicating status (valid, invalid, warning), On selection show validation errors in detail view below list, Format errors with line numbers: \"Line 42: Unknown key 'Foobar'\", Use red icon for errors, yellow for warnings, green for valid | Restrictions: Validate in background thread, Don't block UI, Update validation when file changes, Limit validation frequency | Success: Validation status shown, Errors displayed with line numbers, Icons indicate status, Validation doesn't block UI, Status updates on file change | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.2.5 Add config quick-switch hotkey\n  - File: src/core/engine.cpp, src/ui/qt/system_tray.cpp\n  - Assign global hotkey to cycle through configs\n  - Show notification on config switch\n  - _Leverage: src/platform/input_hook.h, QSystemTrayIcon_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Senior C++ developer with Qt expertise | Task: Add quick-switch hotkey - Add preference for quick-switch hotkey (default: Ctrl+Alt+C), In Engine hook callback check for hotkey, On hotkey call ConfigManager::setNextConfig(), Show tray notification with new config name, Add to system tray tooltip, Support disabled hotkey (set to none) | Restrictions: Don't conflict with other hotkeys, Allow customization, Notification should be brief, Hotkey must work even when YAMY is remapping | Success: Hotkey cycles configs, Notification shows config name, Hotkey customizable, Works with remapping active, Can be disabled | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.2.6 Add config metadata editor\n  - File: src/ui/qt/config_metadata_dialog.h, src/ui/qt/config_metadata_dialog.cpp\n  - Edit config name, description, tags\n  - Display creation and modification dates\n  - _Leverage: QDialog, src/core/settings/config_metadata.h_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Qt GUI developer | Task: Create metadata editor - Create QDialog with fields: Name (QLineEdit), Description (QTextEdit), Author (QLineEdit), Tags (QLineEdit comma-separated), Display dates as read-only labels, Save button updates metadata, Cancel button discards changes, Show from ConfigManagerDialog context menu or double-click | Restrictions: Validate name not empty, Handle missing metadata gracefully, Update modifiedDate automatically | Success: Metadata editor displays current values, All fields editable except dates, Save updates metadata, Validation prevents empty name, Dates updated automatically | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n- [ ] 2.2.7 Add config search and filter\n  - File: src/ui/qt/config_manager_dialog.cpp\n  - Search configs by name, description, tags\n  - Filter by validation status\n  - _Leverage: QLineEdit, QComboBox_\n  - _Requirements: FR-2.1_\n  - _Prompt: Implement the task for spec linux-complete-port, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Qt GUI developer | Task: Add search and filter - Add QLineEdit for search above config list, Filter list as user types (search name, description, tags), Add QComboBox for status filter: All, Valid, Invalid, Warnings, Combine search and filter (AND logic), Update list dynamically, Clear search button | Restrictions: Case-insensitive search, Real-time filtering, Don't block UI on large lists, Handle special characters in search | Success: Search filters list correctly, Status filter works, Filters combine properly, Real-time updates, Clear button works, Handles large lists | After completion: 1) Mark task as in-progress [-] in tasks.md before starting, 2) Log implementation using log-implementation tool with detailed artifacts, 3) Mark task as complete [x] in tasks.md_\n\n---\n\n## Track 3: Investigate Dialog Enhancements (10 tasks)\n\nSee design.md Track 3 for complete specifications.\n\n- [ ] 3.1 Implement crosshair cursor for window selection\n- [ ] 3.2 Add window highlight overlay during selection\n- [ ] 3.3 Implement window information capture\n- [ ] 3.4 Create real-time window info display\n- [ ] 3.5 Add window hierarchy tree view\n- [ ] 3.6 Implement process information display\n- [ ] 3.7 Add copy-to-clipboard functionality\n- [ ] 3.8 Implement window condition generator\n- [ ] 3.9 Add visual feedback during capture\n- [ ] 3.10 Create comprehensive tests for investigate dialog\n\n_Note: Tasks 3.1-3.10 follow similar structure to Tracks 1-2. Refer to design.md Section 3 for detailed specifications._\n\n---\n\n## Track 4: Log Dialog Enhancements (12 tasks)\n\nSee design.md Track 4 for complete specifications.\n\n- [ ] 4.1 Implement structured logging system\n- [ ] 4.2 Add log filtering and search\n- [ ] 4.3 Implement log level controls\n- [ ] 4.4 Add log export functionality\n- [ ] 4.5 Implement key event visualization\n- [ ] 4.6 Add window context display in logs\n- [ ] 4.7 Implement log auto-scroll and pause\n- [ ] 4.8 Add log statistics and metrics\n- [ ] 4.9 Implement log persistence\n- [ ] 4.10 Add log playback and debugging\n- [ ] 4.11 Create log analysis tools\n- [ ] 4.12 Create comprehensive tests for log dialog\n\n_Note: Tasks 4.1-4.12 follow similar structure to Tracks 1-2. Refer to design.md Section 4 for detailed specifications._\n\n---\n\n## Track 5: Engine Notification System (15 tasks)\n\nSee design.md Track 5 for complete specifications.\n\n- [ ] 5.1 Design notification event system\n- [ ] 5.2 Implement notification dispatcher\n- [ ] 5.3 Add configuration reload notifications\n- [ ] 5.4 Implement error notifications\n- [ ] 5.5 Add warning notifications\n- [ ] 5.6 Implement info notifications\n- [ ] 5.7 Add notification queue and priority\n- [ ] 5.8 Implement notification persistence\n- [ ] 5.9 Add notification filtering\n- [ ] 5.10 Implement notification callbacks\n- [ ] 5.11 Add GUI notification display\n- [ ] 5.12 Implement notification history\n- [ ] 5.13 Add notification preferences\n- [ ] 5.14 Create notification tests\n- [ ] 5.15 Document notification system\n\n_Note: Tasks 5.1-5.15 follow similar structure to Tracks 1-2. Refer to design.md Section 5 for detailed specifications._\n\n---\n\n## Track 6: Advanced Features (19 tasks)\n\nSee design.md Track 6 for complete specifications.\n\n- [ ] 6.1 Implement session state management\n- [ ] 6.2 Add session persistence\n- [ ] 6.3 Implement session restoration\n- [ ] 6.4 Add CLI for session management\n- [ ] 6.5 Implement IPC command API\n- [ ] 6.6 Add JSON-RPC protocol for IPC\n- [ ] 6.7 Implement IPC authentication\n- [ ] 6.8 Add IPC command documentation\n- [ ] 6.9 Create help menu with documentation\n- [ ] 6.10 Add version information dialog\n- [ ] 6.11 Implement online help integration\n- [ ] 6.12 Add tutorial system\n- [ ] 6.13 Implement crash reporting\n- [ ] 6.14 Add automatic updates\n- [ ] 6.15 Implement telemetry (opt-in)\n- [ ] 6.16 Add preferences dialog\n- [ ] 6.17 Implement plugin system foundation\n- [ ] 6.18 Create comprehensive integration tests\n- [ ] 6.19 Create end-user documentation\n\n_Note: Tasks 6.1-6.19 follow similar structure to Tracks 1-2. Refer to design.md Section 6 for detailed specifications._\n\n---\n\n## Task Execution Guidelines\n\n### Parallel Execution\n- Within each batch, tasks CAN be executed in parallel by multiple AI agents\n- Batch 1 must complete before starting Batch 2\n- Batch 2 must complete before starting Batch 3\n\n### Dependencies\n- Tasks within a batch have minimal dependencies\n- Dependencies are explicitly noted in the _Dependencies field\n- Cross-batch dependencies are enforced by batch ordering\n\n### Verification\n- Each task includes specific success criteria\n- Run unit tests after completing each task\n- Verify builds on both Linux and Windows when applicable\n\n### Progress Tracking\n- Mark tasks as `- [-]` when starting implementation\n- Mark tasks as `- [x]` when completed and tested\n- Update this file after completing each task\n",
  "fileStats": {
    "size": 101111,
    "lines": 743,
    "lastModified": "2025-12-10T15:47:35.719Z"
  },
  "comments": []
}