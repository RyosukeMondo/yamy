{
  "id": "snapshot_1765593021723_xsjpuvidr",
  "approvalId": "approval_1765593021719_i0qo80yvj",
  "approvalTitle": "Design: Qt Engine Integration",
  "version": 1,
  "timestamp": "2025-12-13T02:30:21.723Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design: Qt Engine Integration\n\n## Architecture Overview\n\n### Current State (Stub Implementation)\n```\nmain_qt.cpp\n├── class Engine { } (stub - 172 lines)\n│   ├── Mock methods (getIsEnabled, start, stop, etc.)\n│   └── Fake data (m_keyCount, m_configPath, etc.)\n├── TrayIconQt (Qt GUI)\n├── IPCControlServer (IPC commands)\n└── SessionManager (state persistence)\n```\n\n### Target State (Real Engine Integration)\n```\nmain_qt.cpp\n├── #include \"core/engine/engine.h\" (real engine)\n├── Engine* g_engine (real instance)\n│   ├── InputHookLinux (evdev input capture)\n│   ├── InputInjectorLinux (uinput key injection)\n│   ├── WindowSystemLinux (X11 window management)\n│   └── Setting/Parser (`.mayu` file processing)\n├── EngineAdapter (bridge between Qt GUI and core Engine)\n├── TrayIconQt (Qt GUI - unchanged)\n├── IPCControlServer (enhanced with real commands)\n└── SessionManager (enhanced state management)\n```\n\n## Component Design\n\n### 1. Engine Initialization\n\n#### Current Stub\n```cpp\n// Stub Engine class definition in main_qt.cpp (lines 21-172)\nclass Engine {\n    bool m_enabled = true;\n    bool m_running = false;\n    std::string m_configPath;\n    // ... mock implementation\n};\n\nEngine* engine = new Engine();\n```\n\n#### Proposed Design\n```cpp\n#include \"core/engine/engine.h\"\n#include \"platform/linux/input_hook_linux.h\"\n#include \"platform/linux/input_injector_linux.h\"\n#include \"platform/linux/window_system_linux.h\"\n\n// Create platform implementations\nauto inputHook = std::make_unique<yamy::platform::InputHookLinux>();\nauto inputInjector = std::make_unique<yamy::platform::InputInjectorLinux>();\nauto windowSystem = std::make_unique<yamy::platform::WindowSystemLinux>();\n\n// Create real engine with platform dependencies\nEngine* engine = new Engine(\n    std::move(inputHook),\n    std::move(inputInjector),\n    std::move(windowSystem)\n);\n```\n\n**Rationale**: Dependency injection allows the Engine to remain platform-agnostic while using Linux-specific implementations.\n\n### 2. EngineAdapter Pattern\n\nThe Qt GUI expects a simpler interface than the full Engine API. We'll create an adapter.\n\n#### Interface Design\n```cpp\nclass EngineAdapter {\npublic:\n    explicit EngineAdapter(Engine* engine) : m_engine(engine) {}\n\n    // Status queries (matching stub interface)\n    bool getIsEnabled() const { return m_engine->m_isEnabled; }\n    bool isRunning() const { return m_engine->isRunning(); }\n    uint64_t keyCount() const { return m_engine->getKeyCount(); }\n\n    // Control methods\n    void enable() { m_engine->enable(); }\n    void disable() { m_engine->disable(); }\n    void start();  // Complex - needs thread management\n    void stop();   // Complex - needs cleanup\n\n    // Configuration\n    bool loadConfig(const std::string& path);\n    std::string getConfigPath() const;\n\n    // JSON status (for IPC compatibility)\n    std::string getStatusJson() const;\n    std::string getConfigJson() const;\n    std::string getKeymapsJson() const;\n    std::string getMetricsJson() const;\n\nprivate:\n    Engine* m_engine;\n    std::string m_configPath;\n    std::thread m_engineThread;\n};\n```\n\n**Rationale**: The adapter pattern decouples the Qt GUI from the complex Engine API, providing a stable interface that matches the stub.\n\n### 3. Configuration Loading Flow\n\n```mermaid\nsequenceDiagram\n    participant GUI as Qt Settings Dialog\n    participant Adapter as EngineAdapter\n    participant Engine as Real Engine\n    participant Parser as Setting/Parser\n    participant Notif as NotificationSystem\n\n    GUI->>Adapter: loadConfig(\"/path/to/master.mayu\")\n    Adapter->>Engine: stop() (if running)\n    Adapter->>Parser: loadSetting(\"/path/to/master.mayu\")\n\n    alt Parsing Success\n        Parser-->>Adapter: Setting object\n        Adapter->>Engine: setSetting(setting)\n        Adapter->>Engine: start()\n        Adapter-->>GUI: success\n        GUI->>Notif: showNotification(\"Config loaded\")\n    else Parsing Error\n        Parser-->>Adapter: throw exception\n        Adapter-->>GUI: error message\n        GUI->>Notif: showNotification(\"Parse error: ...\")\n    end\n```\n\n### 4. IPC Command Integration\n\nThe IPCControlServer needs to be enhanced to work with the real Engine.\n\n#### Command Mapping\n| IPC Command | Current Stub | Real Engine Integration |\n|-------------|--------------|-------------------------|\n| `start` | `engine->start()` | `adapter->start()` (creates thread, calls `engine->start()`) |\n| `stop` | `engine->stop()` | `adapter->stop()` (signals thread, calls `engine->stop()`) |\n| `reload` | `engine->setConfigPath()` | `adapter->loadConfig()` (full reload with parsing) |\n| `status` | `engine->getStatusJson()` | `adapter->getStatusJson()` (real metrics) |\n| `config` | Mock data | Real config path and loaded keymaps |\n| `metrics` | Mock metrics | Real performance metrics from Engine |\n\n#### Implementation Strategy\n```cpp\n// In main_qt.cpp IPC handler\ncase yamy::platform::ControlCommand::Reload: {\n    try {\n        bool success = adapter->loadConfig(data);\n        if (success) {\n            result.success = true;\n            result.message = \"Configuration reloaded: \" + data;\n        } else {\n            result.success = false;\n            result.message = \"Failed to load configuration\";\n        }\n    } catch (const std::exception& e) {\n        result.success = false;\n        result.message = std::string(\"Error: \") + e.what();\n    }\n    break;\n}\n```\n\n### 5. Thread Management\n\nThe real Engine runs keyboard event processing in a separate thread. We need proper lifecycle management.\n\n#### Design\n```cpp\nvoid EngineAdapter::start() {\n    if (m_engineThread.joinable()) {\n        stop(); // Ensure clean state\n    }\n\n    m_engine->enable();\n    m_engineThread = std::thread([this]() {\n        m_engine->start(); // Blocks until stop() is called\n    });\n}\n\nvoid EngineAdapter::stop() {\n    if (m_engineThread.joinable()) {\n        m_engine->stop(); // Signals engine to exit\n        m_engineThread.join(); // Wait for thread to finish\n    }\n    m_engine->disable();\n}\n\nEngineAdapter::~EngineAdapter() {\n    stop(); // Ensure thread is joined on destruction\n}\n```\n\n**Rationale**: RAII ensures the engine thread is properly cleaned up.\n\n### 6. Session State Management\n\nExtend SessionManager to persist real engine configuration.\n\n#### Current Schema\n```cpp\nstruct SessionData {\n    std::string activeConfigPath;\n    bool engineWasRunning;\n    QDateTime savedAt;\n};\n```\n\n#### Enhanced Schema\n```cpp\nstruct SessionData {\n    std::string activeConfigPath;\n    bool engineWasRunning;\n    bool engineWasEnabled;\n    std::string currentKeymap; // From real engine\n    QDateTime savedAt;\n    std::vector<std::string> recentConfigs; // History\n};\n```\n\n### 7. Error Handling Strategy\n\n#### Parsing Errors\n```cpp\nbool EngineAdapter::loadConfig(const std::string& path) {\n    try {\n        // Validate file exists\n        if (!std::filesystem::exists(path)) {\n            throw std::runtime_error(\"Config file not found: \" + path);\n        }\n\n        // Parse configuration\n        Setting* setting = loadSetting(path);\n\n        // Apply to engine\n        m_engine->setSetting(setting);\n        m_configPath = path;\n\n        return true;\n\n    } catch (const ParserException& e) {\n        // Log parse error with line number\n        std::cerr << \"Parse error in \" << path << \":\"\n                  << e.lineNumber() << \" - \" << e.what() << std::endl;\n        return false;\n    } catch (const std::exception& e) {\n        std::cerr << \"Failed to load config: \" << e.what() << std::endl;\n        return false;\n    }\n}\n```\n\n#### Runtime Errors\n- Input device errors: Log and continue with available devices\n- Window system errors: Graceful degradation\n- IPC errors: Return error status, don't crash\n\n### 8. Notification Integration\n\nConnect engine events to Qt notifications.\n\n```cpp\n// In EngineAdapter or main_qt.cpp\nvoid EngineAdapter::start() {\n    // ... start engine thread ...\n\n    emit engineStateChanged(MessageType::EngineStarting);\n\n    // After successful start\n    emit engineStateChanged(MessageType::EngineRunning);\n}\n```\n\n## Data Flow\n\n### Configuration Reload Flow\n```\nUser → Settings Dialog → adapter->loadConfig(path)\n    → Engine::stop()\n    → Parser::loadSetting(path)\n    → Engine::setSetting(setting)\n    → Engine::start()\n    → SessionManager::save(configPath)\n    → NotificationSystem::show(\"Config loaded\")\n```\n\n### Keyboard Event Flow\n```\nPhysical Key Press\n    → evdev (InputHookLinux)\n    → Engine::processKeyEvent()\n    → Keymap lookup & transformation\n    → Engine::injectKey() (via InputInjectorLinux)\n    → uinput device\n    → Virtual Key Press\n```\n\n## File Structure\n\n```\nsrc/app/main_qt.cpp\n├── Remove stub Engine class (lines 21-172)\n├── Add EngineAdapter class\n├── Update engine initialization\n└── Update IPC command handlers\n\nsrc/app/engine_adapter.h (new file)\n└── EngineAdapter class declaration\n\nsrc/app/engine_adapter.cpp (new file)\n└── EngineAdapter implementation\n```\n\n## Testing Strategy\n\n### Unit Tests\n- EngineAdapter methods (start, stop, loadConfig)\n- JSON serialization (getStatusJson, etc.)\n- Error handling paths\n\n### Integration Tests\n1. **Config Loading Test**: Load a valid .mayu file, verify engine applies it\n2. **Error Handling Test**: Load invalid .mayu file, verify error is caught\n3. **IPC Test**: Send reload command via socket, verify config is reloaded\n4. **Session Test**: Save/restore engine state across restart\n\n### Manual Testing\n1. Start yamy, load master.mayu, press remapped keys\n2. Enable/disable via tray icon, verify key remapping stops\n3. Reload config via Settings dialog, verify changes apply\n4. Use yamy-ctl commands, verify real engine responds\n\n## Performance Considerations\n\n### Optimization Strategies\n1. **Lazy Initialization**: Only parse config when needed\n2. **Thread Pool**: Reuse engine thread instead of recreating\n3. **Config Caching**: Cache parsed settings to avoid re-parsing\n\n### Memory Management\n- Engine owns platform implementations (unique_ptr)\n- EngineAdapter owns Engine instance\n- Qt application owns EngineAdapter\n- RAII ensures proper cleanup\n\n## Migration Plan\n\n### Phase 1: Stub Replacement (Non-functional)\n1. Remove stub Engine class\n2. Include real Engine headers\n3. Create EngineAdapter skeleton\n4. Update main() to instantiate real Engine\n5. Verify compilation\n\n### Phase 2: Basic Integration (Minimal functionality)\n1. Implement EngineAdapter::start/stop\n2. Implement basic status queries\n3. Update IPC handlers\n4. Verify GUI still works (even if engine doesn't remap keys yet)\n\n### Phase 3: Configuration Loading\n1. Implement loadConfig()\n2. Connect Settings dialog to adapter\n3. Add error notifications\n4. Test with real .mayu files\n\n### Phase 4: Full Integration\n1. Implement all JSON status methods\n2. Add session persistence\n3. Connect all IPC commands\n4. Performance testing and optimization\n\n## Risk Mitigation\n\n| Risk | Mitigation |\n|------|-----------|\n| Engine API incompatibility | Use adapter pattern for abstraction |\n| Threading issues | RAII for thread lifecycle, proper synchronization |\n| Config parsing failures | Comprehensive error handling, validation |\n| Performance degradation | Profile and optimize, maintain <10ms latency |\n| GUI responsiveness | Engine runs in separate thread, IPC is async |\n\n## Acceptance Criteria\n\n- [ ] Real Engine is instantiated instead of stub\n- [ ] Configuration files (.mayu) are parsed and applied\n- [ ] Keyboard input is actually remapped\n- [ ] All Qt GUI features continue to work\n- [ ] IPC commands return real data\n- [ ] Session state is persisted and restored\n- [ ] No memory leaks or crashes during operation\n- [ ] Performance meets NFR-1 requirements\n",
  "fileStats": {
    "size": 11784,
    "lines": 401,
    "lastModified": "2025-12-13T02:27:57.750Z"
  },
  "comments": []
}