{
  "id": "snapshot_1765379658743_2bqtf7hwt",
  "approvalId": "approval_1765379658741_zcu5qvrda",
  "approvalTitle": "Spec: Design (Linux Complete Port)",
  "version": 1,
  "timestamp": "2025-12-10T15:14:18.743Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design: Linux Complete Port\n\n**Status**: Draft\n**Created**: 2025-12-10\n**Dependencies**: requirements.md\n**Implements**: All user stories (US-1 through US-12)\n\n---\n\n## Design Overview\n\nThis document describes the technical design for achieving complete Windows feature parity on Linux. The design is organized into 6 tracks executed sequentially, with maximum parallelism within each track.\n\n### Design Principles\n\n1. **Platform Abstraction First** - No Linux code touches Windows types\n2. **Interface Segregation** - Small, focused interfaces per subsystem\n3. **Dependency Injection** - All platform dependencies injected via factory functions\n4. **Zero Breaking Changes** - Existing .mayu files work without modification\n5. **Performance Non-Negotiable** - <1ms latency maintained throughout refactoring\n\n---\n\n## Architecture Overview\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    UI Layer (Qt5/Win32)                 │\n│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │\n│  │ Tray Icon    │  │ Settings Dlg │  │ Investigate  │  │\n│  │ (Platform)   │  │ (Platform)   │  │ (Platform)   │  │\n│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  │\n└─────────┼──────────────────┼──────────────────┼─────────┘\n          │                  │                  │\n          v                  v                  v\n┌─────────────────────────────────────────────────────────┐\n│              Core Engine (Platform-Agnostic)            │\n│  ┌──────────────────────────────────────────────────┐   │\n│  │  Engine Orchestrator                             │   │\n│  │  - State machine (Stopped/Running/Error)         │   │\n│  │  - Configuration loader                          │   │\n│  │  - Notification dispatcher                       │   │\n│  └────┬─────────────────────────────────────────┬───┘   │\n│       │                                         │       │\n│  ┌────v──────────┐  ┌─────────────┐  ┌─────────v────┐  │\n│  │ Input Mapper  │  │ Window Mgr  │  │ Function Sys │  │\n│  │ (60+ cmds)    │  │ (Focus)     │  │ (Actions)    │  │\n│  └───────────────┘  └─────────────┘  └──────────────┘  │\n└─────────┬─────────────────┬─────────────────┬───────────┘\n          │                 │                 │\n          v                 v                 v\n┌─────────────────────────────────────────────────────────┐\n│         Platform Abstraction Layer (Interfaces)         │\n│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │\n│  │ IInputHook   │  │ IWindowSys   │  │ IIPCChannel  │  │\n│  │ IInputInject │  │ IInputDriver │  │ IFileSystem  │  │\n│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  │\n└─────────┼──────────────────┼──────────────────┼─────────┘\n          │                  │                  │\n    ┌─────┴─────┐      ┌─────┴─────┐      ┌────┴────┐\n    │  Windows  │      │   Linux   │      │  macOS  │\n    │ (Win32)   │      │(X11/evdev)│      │ (Future)│\n    └───────────┘      └───────────┘      └─────────┘\n```\n\n---\n\n## Track 1: Core Refactoring\n\n**Goal**: Remove all Windows-specific types from core engine (FR-1)\n**Duration**: 80 hours | **Tasks**: 60 | **Parallelism**: 3 batches\n\n### 1.1 Type System Migration\n\n#### 1.1.1 String Type Unification\n\n**Problem**: Core engine uses `tstring` (typedef for `std::wstring` or `std::string`), causing link errors on Linux.\n\n**Design Decision**: Standardize on UTF-8 `std::string` everywhere.\n\n**Rationale**:\n- Linux ecosystem is UTF-8 native (X11, evdev, Qt5)\n- Modern C++ has `std::filesystem::u8path` for UTF-8\n- Windows `WideCharToMultiByte` available when interfacing with Win32\n\n**Changes**:\n```cpp\n// Before (Windows-centric)\ntypedef std::basic_string<TCHAR> tstring;\n#define _T(x) L##x  // Wide strings on Windows\n\n// After (Platform-agnostic)\nusing String = std::string;  // Always UTF-8\n// No preprocessor macros\n```\n\n**Affected Files** (10 files):\n- `src/utils/stringtool.h/cpp` - Remove all `tstring` typedefs\n- `src/core/settings/config_store.h` - Remove `tstring` overloads\n- `src/core/settings/errormessage.h` - Convert to `std::string`\n- `src/core/input/keyboard.cpp` - String conversions\n- `src/core/engine/engine.cpp` - Remove `_T()` macros\n- `src/core/window/layoutmanager.cpp` - Window text handling\n- `src/core/functions/function.cpp` - Command name strings\n- `src/app/mayu.cpp` - Win32 bridge conversions\n- `src/ui/dlgsetting.cpp` - ListView string conversions\n- `src/ui/qt/dialog_settings_qt.cpp` - QSettings UTF-8 keys\n\n**API Example**:\n```cpp\n// Old Windows-only API\nclass ConfigStore {\n    bool read(const tstring& key, tstring* value);\n    bool write(const tstring& key, const tstring& value);\n};\n\n// New platform-agnostic API\nclass ConfigStore {\n    bool read(const std::string& key, std::string* value);\n    bool write(const std::string& key, const std::string& value);\n\nprivate:\n    #ifdef _WIN32\n        std::wstring toWide(const std::string& utf8);  // Win32 bridge\n        std::string toUtf8(const std::wstring& wide);\n    #endif\n};\n```\n\n#### 1.1.2 Window Handle Abstraction\n\n**Problem**: `HWND` (Windows handle) used throughout engine for window identification.\n\n**Design Decision**: Platform-agnostic `WindowHandle` type.\n\n**Implementation**:\n```cpp\n// src/platform/types.h\nnamespace yamy::platform {\n\n#ifdef _WIN32\n    using WindowHandle = HWND;\n#elif __linux__\n    struct WindowHandle {\n        uint64_t xid;      // X11 Window ID\n        uint32_t pid;      // Process ID (for Wayland)\n\n        bool operator==(const WindowHandle& other) const {\n            return xid == other.xid && pid == other.pid;\n        }\n        bool isValid() const { return xid != 0; }\n    };\n#endif\n\n    constexpr WindowHandle NULL_WINDOW = {};\n\n}  // namespace yamy::platform\n```\n\n**Affected Components**:\n- `src/core/window/target.h/cpp` - 19 HWND references\n- `src/core/window/focus.h/cpp` - 15 HWND references\n- `src/core/window/layoutmanager.h/cpp` - 12 HWND references\n- `src/core/engine/engine.h` - 8 HWND parameters\n- `src/utils/msgstream.h` - 10 HWND references\n\n**Migration Strategy**:\n```cpp\n// Step 1: Find all HWND usages\n//   grep -r \"HWND\" src/core/ | wc -l  → 64 occurrences\n\n// Step 2: Replace type declarations\n//   HWND hwnd; → WindowHandle hwnd;\n\n// Step 3: Replace null checks\n//   if (hwnd == NULL) → if (!hwnd.isValid())\n\n// Step 4: Replace API calls (next section)\n```\n\n### 1.2 Platform API Abstraction\n\n#### 1.2.1 Window System Interface\n\n**Problem**: Direct Win32 calls (`GetForegroundWindow`, `GetWindowRect`, `SetForegroundWindow`) in core engine.\n\n**Design**: `IWindowSystem` interface with platform-specific implementations.\n\n**Interface Design**:\n```cpp\n// src/platform/window_system.h\nnamespace yamy::platform {\n\nstruct Rect {\n    int32_t left, top, right, bottom;\n    int32_t width() const { return right - left; }\n    int32_t height() const { return bottom - top; }\n};\n\nenum class ShowCommand {\n    Hide = 0,\n    Normal = 1,\n    Minimized = 2,\n    Maximized = 3,\n    ShowNoActivate = 4,\n    Show = 5,\n    Minimize = 6,\n    ShowMinNoActive = 7,\n    ShowNA = 8,\n    Restore = 9,\n    ShowDefault = 10,\n    ForceMinimize = 11\n};\n\nclass IWindowSystem {\npublic:\n    virtual ~IWindowSystem() = default;\n\n    // Window queries\n    virtual WindowHandle getForegroundWindow() = 0;\n    virtual WindowHandle getDesktopWindow() = 0;\n    virtual std::string getWindowText(WindowHandle hwnd) = 0;\n    virtual std::string getClassName(WindowHandle hwnd) = 0;\n    virtual Rect getWindowRect(WindowHandle hwnd) = 0;\n    virtual bool isWindow(WindowHandle hwnd) = 0;\n    virtual bool isWindowVisible(WindowHandle hwnd) = 0;\n\n    // Window manipulation\n    virtual void setForegroundWindow(WindowHandle hwnd) = 0;\n    virtual void showWindow(WindowHandle hwnd, ShowCommand cmd) = 0;\n    virtual void moveWindow(WindowHandle hwnd, const Rect& rect) = 0;\n    virtual void closeWindow(WindowHandle hwnd) = 0;\n\n    // Caret/cursor (for &WindowCaret function)\n    virtual bool getCaretPos(int32_t* x, int32_t* y) = 0;\n    virtual WindowHandle getCaretWindow() = 0;\n};\n\n// Factory function (defined per-platform)\nIWindowSystem* createWindowSystem();\n\n}  // namespace yamy::platform\n```\n\n**Windows Implementation**:\n```cpp\n// src/platform/windows/window_system_win32.cpp\nclass WindowSystemWin32 : public IWindowSystem {\npublic:\n    WindowHandle getForegroundWindow() override {\n        return ::GetForegroundWindow();\n    }\n\n    std::string getWindowText(WindowHandle hwnd) override {\n        wchar_t buf[256];\n        ::GetWindowTextW(hwnd, buf, 256);\n        return utf8::fromWide(buf);  // UTF-8 conversion\n    }\n\n    void moveWindow(WindowHandle hwnd, const Rect& rect) override {\n        ::MoveWindow(hwnd, rect.left, rect.top, rect.width(), rect.height(), TRUE);\n    }\n\n    // ... other methods\n};\n\nIWindowSystem* createWindowSystem() {\n    return new WindowSystemWin32();\n}\n```\n\n**Linux Implementation**:\n```cpp\n// src/platform/linux/window_system_x11.cpp\n#include <X11/Xlib.h>\n#include <X11/Xatom.h>\n\nclass WindowSystemX11 : public IWindowSystem {\npublic:\n    WindowSystemX11() {\n        display_ = XOpenDisplay(nullptr);\n        root_ = DefaultRootWindow(display_);\n        // Cache atom IDs\n        net_active_window_ = XInternAtom(display_, \"_NET_ACTIVE_WINDOW\", False);\n        net_wm_name_ = XInternAtom(display_, \"_NET_WM_NAME\", False);\n    }\n\n    WindowHandle getForegroundWindow() override {\n        Window focused;\n        int revert;\n        XGetInputFocus(display_, &focused, &revert);\n        return WindowHandle{focused, 0};\n    }\n\n    std::string getWindowText(WindowHandle hwnd) override {\n        Atom actual_type;\n        int actual_format;\n        unsigned long nitems, bytes_after;\n        unsigned char* prop = nullptr;\n\n        XGetWindowProperty(display_, hwnd.xid, net_wm_name_,\n                          0, 1024, False, AnyPropertyType,\n                          &actual_type, &actual_format, &nitems,\n                          &bytes_after, &prop);\n\n        std::string result((char*)prop);\n        XFree(prop);\n        return result;  // Already UTF-8 on X11\n    }\n\n    void moveWindow(WindowHandle hwnd, const Rect& rect) override {\n        XMoveResizeWindow(display_, hwnd.xid,\n                         rect.left, rect.top, rect.width(), rect.height());\n        XFlush(display_);\n    }\n\nprivate:\n    Display* display_;\n    Window root_;\n    Atom net_active_window_, net_wm_name_;\n};\n\nIWindowSystem* createWindowSystem() {\n    return new WindowSystemX11();\n}\n```\n\n**Integration**:\n```cpp\n// src/core/engine/engine.cpp\nclass Engine {\npublic:\n    Engine(IWindowSystem* windowSys, IInputHook* inputHook)\n        : m_windowSystem(windowSys), m_inputHook(inputHook) {}\n\n    void handleWindowCommand(ShowCommand cmd) {\n        WindowHandle hwnd = m_windowSystem->getForegroundWindow();\n        m_windowSystem->showWindow(hwnd, cmd);\n    }\n\nprivate:\n    IWindowSystem* m_windowSystem;\n    IInputHook* m_inputHook;\n};\n\n// src/app/main_qt.cpp (Linux)\nint main(int argc, char** argv) {\n    IWindowSystem* windowSys = yamy::platform::createWindowSystem();\n    IInputHook* inputHook = yamy::platform::createInputHook();\n\n    Engine engine(windowSys, inputHook);\n    engine.load(\"config.mayu\");\n\n    // ...\n}\n```\n\n#### 1.2.2 IPC Abstraction\n\n**Problem**: `PostMessage()` (Windows mailslots) used for engine→GUI communication.\n\n**Design**: `IIPCChannel` interface with queue-based messaging.\n\n**Interface**:\n```cpp\n// src/platform/ipc.h\nnamespace yamy::platform {\n\nenum class MessageType : uint32_t {\n    // Engine → GUI notifications\n    EngineStarted = 0x1000,\n    EngineStopped = 0x1001,\n    EngineError = 0x1002,\n    ConfigLoaded = 0x1003,\n    ConfigError = 0x1004,\n    LogMessage = 0x1005,\n    KeyEvent = 0x1006,\n\n    // GUI → Engine commands\n    CmdReload = 0x2000,\n    CmdStop = 0x2001,\n    CmdInvestigate = 0x2002,\n    CmdToggleEngine = 0x2003,\n\n    // Custom range\n    UserDefined = 0x3000\n};\n\nstruct Message {\n    MessageType type;\n    uint32_t wparam;\n    uint64_t lparam;\n    std::string data;  // For complex payloads\n};\n\nclass IIPCChannel {\npublic:\n    virtual ~IIPCChannel() = default;\n\n    // Sender interface\n    virtual bool send(const Message& msg) = 0;\n    virtual bool sendAsync(const Message& msg) = 0;\n\n    // Receiver interface\n    virtual bool poll(Message* outMsg) = 0;\n    virtual void setCallback(std::function<void(const Message&)> callback) = 0;\n\n    // Lifecycle\n    virtual bool connect(const std::string& channelName) = 0;\n    virtual void disconnect() = 0;\n    virtual bool isConnected() const = 0;\n};\n\nIIPCChannel* createIPCChannel();\n\n}  // namespace yamy::platform\n```\n\n**Windows Implementation**:\n```cpp\n// src/platform/windows/ipc_mailslot.cpp\nclass IPCMailslot : public IIPCChannel {\npublic:\n    bool send(const Message& msg) override {\n        HWND hwnd = FindWindow(MAYU_WINDOW_CLASS, nullptr);\n        if (!hwnd) return false;\n\n        ::PostMessage(hwnd, static_cast<UINT>(msg.type),\n                     msg.wparam, msg.lparam);\n        return true;\n    }\n\n    bool poll(Message* outMsg) override {\n        MSG msg;\n        if (::PeekMessage(&msg, m_hwnd, 0, 0, PM_REMOVE)) {\n            outMsg->type = static_cast<MessageType>(msg.message);\n            outMsg->wparam = msg.wParam;\n            outMsg->lparam = msg.lParam;\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    HWND m_hwnd;\n};\n```\n\n**Linux Implementation**:\n```cpp\n// src/platform/linux/ipc_socket.cpp\n#include <sys/socket.h>\n#include <sys/un.h>\n\nclass IPCUnixSocket : public IIPCChannel {\npublic:\n    bool connect(const std::string& channelName) override {\n        socket_fd_ = socket(AF_UNIX, SOCK_DGRAM, 0);\n\n        sockaddr_un addr{};\n        addr.sun_family = AF_UNIX;\n        snprintf(addr.sun_path, sizeof(addr.sun_path),\n                \"/tmp/yamy-%d.sock\", getuid());\n\n        bind(socket_fd_, (sockaddr*)&addr, sizeof(addr));\n        return true;\n    }\n\n    bool send(const Message& msg) override {\n        // Serialize message to buffer\n        std::vector<uint8_t> buf(16 + msg.data.size());\n        memcpy(&buf[0], &msg.type, 4);\n        memcpy(&buf[4], &msg.wparam, 4);\n        memcpy(&buf[8], &msg.lparam, 8);\n        memcpy(&buf[16], msg.data.data(), msg.data.size());\n\n        // Send to peer socket\n        sockaddr_un peer_addr{};\n        peer_addr.sun_family = AF_UNIX;\n        snprintf(peer_addr.sun_path, sizeof(peer_addr.sun_path),\n                \"/tmp/yamy-%d-gui.sock\", getuid());\n\n        sendto(socket_fd_, buf.data(), buf.size(), 0,\n              (sockaddr*)&peer_addr, sizeof(peer_addr));\n        return true;\n    }\n\n    bool poll(Message* outMsg) override {\n        std::vector<uint8_t> buf(4096);\n        ssize_t n = recv(socket_fd_, buf.data(), buf.size(), MSG_DONTWAIT);\n        if (n < 16) return false;\n\n        memcpy(&outMsg->type, &buf[0], 4);\n        memcpy(&outMsg->wparam, &buf[4], 4);\n        memcpy(&outMsg->lparam, &buf[8], 8);\n        outMsg->data.assign((char*)&buf[16], n - 16);\n        return true;\n    }\n\nprivate:\n    int socket_fd_;\n};\n\nIIPCChannel* createIPCChannel() {\n    return new IPCUnixSocket();\n}\n```\n\n**Qt Integration** (Linux GUI):\n```cpp\n// src/ui/qt/tray_icon_qt.cpp\nclass TrayIconQt : public QSystemTrayIcon {\npublic:\n    TrayIconQt() {\n        ipc_ = yamy::platform::createIPCChannel();\n        ipc_->connect(\"yamy-gui\");\n\n        // Use QSocketNotifier to integrate with Qt event loop\n        int fd = ipc_->getFileDescriptor();\n        notifier_ = new QSocketNotifier(fd, QSocketNotifier::Read, this);\n        connect(notifier_, &QSocketNotifier::activated,\n                this, &TrayIconQt::onIPCMessage);\n    }\n\n    void onIPCMessage() {\n        yamy::platform::Message msg;\n        while (ipc_->poll(&msg)) {\n            handleEngineMessage(msg);\n        }\n    }\n\n    void handleEngineMessage(const yamy::platform::Message& msg) {\n        switch (msg.type) {\n            case MessageType::EngineStarted:\n                setToolTip(\"YAMY - Running\");\n                break;\n            case MessageType::EngineStopped:\n                setToolTip(\"YAMY - Stopped\");\n                break;\n            case MessageType::LogMessage:\n                emit logReceived(QString::fromStdString(msg.data));\n                break;\n        }\n    }\n\nprivate:\n    IIPCChannel* ipc_;\n    QSocketNotifier* notifier_;\n};\n```\n\n### 1.3 Batched Execution Plan\n\n**Batch 1: Foundation** (32 tasks, ALL PARALLEL)\n- Group A: String cleanup (10 tasks)\n- Group B: SW_* → ShowCommand (12 tasks)\n- Group C: Message constants (10 tasks)\n\n**Batch 2: Window System** (15 tasks, ALL PARALLEL after Batch 1)\n- Group D: HWND → WindowHandle (8 tasks)\n- Group E: IPC abstraction (7 tasks)\n\n**Batch 3: Integration** (13 tasks, ALL PARALLEL after Batch 2)\n- Group F: Window functions integration (13 tasks)\n\n**Verification**: After each batch, run:\n```bash\nmkdir build-linux && cd build-linux\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake -j$(nproc)  # Should compile without Windows headers\n```\n\n---\n\n## Track 2: Configuration Management\n\n**Goal**: Multi-config support with GUI editor (FR-2)\n**Duration**: 45 hours | **Tasks**: 15\n\n### 2.1 Data Model\n\n**Configuration Structure**:\n```cpp\n// src/core/settings/mayu_configuration.h\nnamespace yamy {\n\nstruct MayuConfiguration {\n    std::string name;              // Display name\n    std::string mayuPath;          // Absolute path to .mayu file\n    std::vector<std::string> symbols;  // Preprocessor defines\n    bool isActive;                 // Currently loaded\n\n    // Metadata\n    std::string description;\n    time_t lastModified;\n    time_t lastUsed;\n\n    bool isValid() const {\n        return !name.empty() && std::filesystem::exists(mayuPath);\n    }\n};\n\nclass ConfigurationManager {\npublic:\n    // CRUD operations\n    bool addConfiguration(const MayuConfiguration& config);\n    bool removeConfiguration(const std::string& name);\n    bool updateConfiguration(const std::string& name, const MayuConfiguration& newConfig);\n    std::vector<MayuConfiguration> getAllConfigurations() const;\n\n    // Activation\n    bool setActiveConfiguration(const std::string& name);\n    MayuConfiguration getActiveConfiguration() const;\n\n    // Persistence\n    bool save();\n    bool load();\n\nprivate:\n    std::vector<MayuConfiguration> m_configs;\n    std::string m_activeConfigName;\n    platform::IFileSystem* m_fileSystem;\n};\n\n}  // namespace yamy\n```\n\n**Storage Format** (QSettings on Linux, Registry on Windows):\n```ini\n# ~/.config/yamy/configurations.ini\n[general]\nactiveConfig=work\n\n[configurations/work]\nname=Work Layout\nmayuPath=/home/user/.config/yamy/work.mayu\nsymbols=OFFICE_MODE,ENABLE_VIM\ndescription=9-5 office configuration\n\n[configurations/gaming]\nname=Gaming\nmayuPath=/home/user/.config/yamy/gaming.mayu\nsymbols=GAMING_MODE\ndescription=FPS-optimized\n```\n\n### 2.2 GUI Components\n\n#### 2.2.1 Settings Dialog Enhancements\n\n**Current State** (Phase 8):\n- Basic file list with Add/Remove buttons\n- No symbol editor\n- No multi-select\n\n**Enhanced Design**:\n```\n┌─ Edit Setting ─────────────────────────────────────┐\n│ Configurations:                                    │\n│ ┌────────────────────────────────────────────────┐ │\n│ │ ● Work Layout          work.mayu     [Edit]    │ │\n│ │   Gaming               gaming.mayu   [Edit]    │ │\n│ │   Writing              writing.mayu  [Edit]    │ │\n│ └────────────────────────────────────────────────┘ │\n│ [Add New...]  [Duplicate]  [Remove]                │\n│                                                    │\n│ Selected Configuration: Work Layout                │\n│ ┌────────────────────────────────────────────────┐ │\n│ │ Name: [Work Layout___________________]          │ │\n│ │ File: [/home/user/.mayu] [Browse...]            │ │\n│ │                                                 │ │\n│ │ Preprocessor Symbols:                           │ │\n│ │ ┌─────────────────────────────────────────────┐ │ │\n│ │ │ OFFICE_MODE                    [Remove]     │ │ │\n│ │ │ ENABLE_VIM                     [Remove]     │ │ │\n│ │ └─────────────────────────────────────────────┘ │ │\n│ │ [Add Symbol...]                                 │ │\n│ │                                                 │ │\n│ │ Description:                                    │ │\n│ │ ┌─────────────────────────────────────────────┐ │ │\n│ │ │ 9-5 office configuration with Emacs         │ │ │\n│ │ │ bindings and window management              │ │ │\n│ │ └─────────────────────────────────────────────┘ │ │\n│ └────────────────────────────────────────────────┘ │\n│                                       [OK] [Cancel] │\n└────────────────────────────────────────────────────┘\n```\n\n**Implementation**:\n```cpp\n// src/ui/qt/dialog_settings_qt.cpp\nclass DialogSettingsQt : public QDialog {\npublic:\n    DialogSettingsQt(ConfigurationManager* configMgr, QWidget* parent = nullptr)\n        : QDialog(parent), m_configMgr(configMgr) {\n        setupUI();\n        loadConfigurations();\n    }\n\nprivate:\n    void setupUI() {\n        auto* layout = new QVBoxLayout(this);\n\n        // Configuration list\n        m_configList = new QListWidget(this);\n        connect(m_configList, &QListWidget::currentRowChanged,\n                this, &DialogSettingsQt::onConfigSelected);\n\n        // Buttons\n        auto* btnLayout = new QHBoxLayout();\n        auto* btnAdd = new QPushButton(\"Add New...\", this);\n        auto* btnDuplicate = new QPushButton(\"Duplicate\", this);\n        auto* btnRemove = new QPushButton(\"Remove\", this);\n\n        connect(btnAdd, &QPushButton::clicked, this, &DialogSettingsQt::onAddConfig);\n        connect(btnDuplicate, &QPushButton::clicked, this, &DialogSettingsQt::onDuplicateConfig);\n        connect(btnRemove, &QPushButton::clicked, this, &DialogSettingsQt::onRemoveConfig);\n\n        btnLayout->addWidget(btnAdd);\n        btnLayout->addWidget(btnDuplicate);\n        btnLayout->addWidget(btnRemove);\n\n        // Configuration editor\n        m_editorGroup = new QGroupBox(\"Selected Configuration\", this);\n        auto* editorLayout = new QFormLayout(m_editorGroup);\n\n        m_nameEdit = new QLineEdit(this);\n        m_pathEdit = new QLineEdit(this);\n        auto* btnBrowse = new QPushButton(\"Browse...\", this);\n        connect(btnBrowse, &QPushButton::clicked, this, &DialogSettingsQt::onBrowseMayu);\n\n        auto* pathLayout = new QHBoxLayout();\n        pathLayout->addWidget(m_pathEdit);\n        pathLayout->addWidget(btnBrowse);\n\n        // Symbol editor\n        m_symbolList = new QListWidget(this);\n        auto* btnAddSymbol = new QPushButton(\"Add Symbol...\", this);\n        auto* btnRemoveSymbol = new QPushButton(\"Remove\", this);\n        connect(btnAddSymbol, &QPushButton::clicked, this, &DialogSettingsQt::onAddSymbol);\n        connect(btnRemoveSymbol, &QPushButton::clicked, this, &DialogSettingsQt::onRemoveSymbol);\n\n        m_descEdit = new QTextEdit(this);\n        m_descEdit->setMaximumHeight(80);\n\n        editorLayout->addRow(\"Name:\", m_nameEdit);\n        editorLayout->addRow(\"File:\", pathLayout);\n        editorLayout->addRow(\"Symbols:\", m_symbolList);\n        editorLayout->addRow(\"\", btnAddSymbol);\n        editorLayout->addRow(\"Description:\", m_descEdit);\n\n        layout->addWidget(m_configList);\n        layout->addLayout(btnLayout);\n        layout->addWidget(m_editorGroup);\n\n        auto* buttonBox = new QDialogButtonBox(\n            QDialogButtonBox::Ok | QDialogButtonBox::Cancel, this);\n        connect(buttonBox, &QDialogButtonBox::accepted, this, &DialogSettingsQt::onOk);\n        connect(buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);\n        layout->addWidget(buttonBox);\n    }\n\n    void loadConfigurations() {\n        m_configList->clear();\n\n        auto configs = m_configMgr->getAllConfigurations();\n        for (const auto& config : configs) {\n            auto* item = new QListWidgetItem(\n                QString::fromStdString(config.name), m_configList);\n\n            // Radio button for active config\n            if (config.isActive) {\n                item->setIcon(QIcon::fromTheme(\"emblem-default\"));\n            }\n\n            item->setData(Qt::UserRole, QString::fromStdString(config.name));\n            m_configList->addItem(item);\n        }\n    }\n\n    void onConfigSelected(int row) {\n        if (row < 0) return;\n\n        auto* item = m_configList->item(row);\n        std::string name = item->data(Qt::UserRole).toString().toStdString();\n\n        auto configs = m_configMgr->getAllConfigurations();\n        auto it = std::find_if(configs.begin(), configs.end(),\n            [&](const MayuConfiguration& c) { return c.name == name; });\n\n        if (it != configs.end()) {\n            m_nameEdit->setText(QString::fromStdString(it->name));\n            m_pathEdit->setText(QString::fromStdString(it->mayuPath));\n            m_descEdit->setPlainText(QString::fromStdString(it->description));\n\n            m_symbolList->clear();\n            for (const auto& symbol : it->symbols) {\n                m_symbolList->addItem(QString::fromStdString(symbol));\n            }\n        }\n    }\n\n    void onAddSymbol() {\n        bool ok;\n        QString symbol = QInputDialog::getText(this, \"Add Symbol\",\n            \"Symbol name:\", QLineEdit::Normal, \"\", &ok);\n\n        if (ok && !symbol.isEmpty()) {\n            m_symbolList->addItem(symbol);\n        }\n    }\n\n    void onOk() {\n        // Save all changes back to ConfigurationManager\n        // ... (update logic)\n        accept();\n    }\n\nprivate:\n    ConfigurationManager* m_configMgr;\n    QListWidget* m_configList;\n    QGroupBox* m_editorGroup;\n    QLineEdit* m_nameEdit;\n    QLineEdit* m_pathEdit;\n    QListWidget* m_symbolList;\n    QTextEdit* m_descEdit;\n};\n```\n\n#### 2.2.2 Reload Submenu\n\n**Design**:\n```\nTray Icon Context Menu:\n├─ Version\n├─ Reload ▶\n│  ├─ ● Work Layout\n│  ├─   Gaming\n│  ├─   Writing\n│  ├─ ──────────\n│  └─ Manage Configurations...\n├─ Edit Setting...\n├─ Investigate\n├─ Task Tray\n├─ Log\n└─ Exit\n```\n\n**Implementation**:\n```cpp\n// src/ui/qt/tray_icon_qt.cpp\nvoid TrayIconQt::buildReloadMenu() {\n    if (!m_reloadMenu) {\n        m_reloadMenu = new QMenu(\"Reload\");\n        m_contextMenu->insertMenu(m_contextMenu->actions()[1], m_reloadMenu);\n    }\n\n    m_reloadMenu->clear();\n\n    // Get all configurations\n    auto configs = m_configMgr->getAllConfigurations();\n    auto activeConfig = m_configMgr->getActiveConfiguration();\n\n    // Add configuration actions\n    for (const auto& config : configs) {\n        QAction* action = m_reloadMenu->addAction(\n            QString::fromStdString(config.name));\n\n        action->setCheckable(true);\n        action->setChecked(config.name == activeConfig.name);\n\n        connect(action, &QAction::triggered, [this, name = config.name]() {\n            onReloadConfiguration(name);\n        });\n    }\n\n    m_reloadMenu->addSeparator();\n\n    QAction* manageAction = m_reloadMenu->addAction(\"Manage Configurations...\");\n    connect(manageAction, &QAction::triggered, this, &TrayIconQt::onEditSetting);\n}\n\nvoid TrayIconQt::onReloadConfiguration(const std::string& name) {\n    // Send reload command to engine\n    yamy::platform::Message msg;\n    msg.type = yamy::platform::MessageType::CmdReload;\n    msg.data = name;\n\n    m_ipc->send(msg);\n\n    // Update checkmarks\n    buildReloadMenu();\n}\n```\n\n### 2.3 Engine Integration\n\n**Configuration Loading Flow**:\n```\nGUI: User selects config from Reload submenu\n  ↓\nGUI: Send IPC message {CmdReload, configName}\n  ↓\nEngine: Receive message\n  ↓\nEngine: configMgr->setActiveConfiguration(configName)\n  ↓\nEngine: config = configMgr->getActiveConfiguration()\n  ↓\nEngine: parser->parse(config.mayuPath, config.symbols)\n  ↓\nEngine: Apply new key mappings\n  ↓\nEngine: Send IPC message {ConfigLoaded, configName}\n  ↓\nGUI: Update tray tooltip \"YAMY - Work Layout\"\n```\n\n**Implementation**:\n```cpp\n// src/core/engine/engine.cpp\nvoid Engine::handleIPCMessage(const platform::Message& msg) {\n    switch (msg.type) {\n        case platform::MessageType::CmdReload: {\n            std::string configName = msg.data;\n            if (m_configMgr->setActiveConfiguration(configName)) {\n                auto config = m_configMgr->getActiveConfiguration();\n                reload(config);\n\n                // Notify GUI\n                platform::Message response;\n                response.type = platform::MessageType::ConfigLoaded;\n                response.data = configName;\n                m_ipc->send(response);\n            } else {\n                // Error\n                platform::Message response;\n                response.type = platform::MessageType::ConfigError;\n                response.data = \"Configuration not found: \" + configName;\n                m_ipc->send(response);\n            }\n            break;\n        }\n        // ... other commands\n    }\n}\n\nvoid Engine::reload(const MayuConfiguration& config) {\n    // Stop current engine\n    stop();\n\n    // Parse new configuration\n    m_parser = std::make_unique<MayuParser>();\n    for (const auto& symbol : config.symbols) {\n        m_parser->define(symbol, \"1\");\n    }\n\n    if (!m_parser->parse(config.mayuPath)) {\n        throw std::runtime_error(\"Failed to parse: \" + config.mayuPath);\n    }\n\n    // Rebuild keymaps\n    m_keymaps = m_parser->getKeymaps();\n\n    // Restart engine\n    start();\n}\n```\n\n---\n\n## Track 3: Investigate Dialog\n\n**Goal**: Full window inspector with crosshair (FR-3)\n**Duration**: 60 hours | **Tasks**: 18\n\n### 3.1 Component Architecture\n\n**Dialog Structure**:\n```\nInvestigateDialog (QDialog)\n├─ CrosshairWidget (Custom QWidget for drag interaction)\n├─ WindowInfoPanel (QGroupBox)\n│  ├─ Window handle (hex)\n│  ├─ Window text (title)\n│  ├─ Class name\n│  ├─ Process name\n│  ├─ Geometry (x, y, w, h)\n│  └─ State (visible, focused, topmost)\n├─ KeymapStatusPanel (QGroupBox)\n│  ├─ Matched window regex\n│  ├─ Active keymap name\n│  └─ Effective modifiers\n├─ LiveLogPanel (QTextEdit)\n│  └─ Real-time key events from engine\n└─ Buttons (QDialogButtonBox)\n   └─ Close\n```\n\n### 3.2 Crosshair Implementation\n\n**Approach**: Transparent overlay window with custom cursor.\n\n**Linux X11 Implementation**:\n```cpp\n// src/ui/qt/crosshair_widget_qt.cpp\n#include <X11/Xlib.h>\n#include <X11/cursorfont.h>\n\nclass CrosshairWidget : public QWidget {\npublic:\n    CrosshairWidget(QWidget* parent = nullptr) : QWidget(parent) {\n        setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::Tool);\n        setAttribute(Qt::WA_TranslucentBackground);\n        setAttribute(Qt::WA_NoSystemBackground);\n        setMouseTracking(true);\n\n        // Load crosshair cursor\n        Display* display = QX11Info::display();\n        Cursor cursor = XCreateFontCursor(display, XC_crosshair);\n        setCursor(QCursor(Qt::CrossCursor));\n\n        // Make window click-through but still receive mouse events\n        XSetWindowAttributes attrs;\n        attrs.event_mask = ButtonPressMask | ButtonReleaseMask | PointerMotionMask;\n        XChangeWindowAttributes(display, winId(), CWEventMask, &attrs);\n    }\n\n    void activate() {\n        showFullScreen();\n        grabMouse();\n        setFocus();\n    }\n\n    void deactivate() {\n        releaseMouse();\n        hide();\n    }\n\nprotected:\n    void paintEvent(QPaintEvent* event) override {\n        // Draw crosshair lines\n        QPainter painter(this);\n        painter.setRenderHint(QPainter::Antialiasing);\n\n        QPoint center = mapFromGlobal(QCursor::pos());\n\n        // Vertical line\n        painter.setPen(QPen(QColor(255, 0, 0, 200), 2));\n        painter.drawLine(center.x(), 0, center.x(), height());\n\n        // Horizontal line\n        painter.drawLine(0, center.y(), width(), center.y());\n\n        // Center dot\n        painter.setBrush(QBrush(QColor(255, 0, 0)));\n        painter.drawEllipse(center, 4, 4);\n    }\n\n    void mousePressEvent(QMouseEvent* event) override {\n        if (event->button() == Qt::LeftButton) {\n            // Get window under cursor\n            WindowHandle hwnd = getWindowAtCursor();\n            emit windowSelected(hwnd);\n            deactivate();\n        }\n    }\n\n    void mouseMoveEvent(QMouseEvent* event) override {\n        update();  // Redraw crosshair\n    }\n\nsignals:\n    void windowSelected(WindowHandle hwnd);\n\nprivate:\n    WindowHandle getWindowAtCursor() {\n        Display* display = QX11Info::display();\n        Window root = DefaultRootWindow(display);\n\n        int root_x, root_y, win_x, win_y;\n        unsigned int mask;\n        Window child;\n\n        XQueryPointer(display, root, &root, &child,\n                     &root_x, &root_y, &win_x, &win_y, &mask);\n\n        // Traverse to leaf window\n        Window target = child;\n        while (child != None) {\n            target = child;\n            XQueryPointer(display, target, &root, &child,\n                         &root_x, &root_y, &win_x, &win_y, &mask);\n        }\n\n        return WindowHandle{target, 0};\n    }\n};\n```\n\n### 3.3 Window Information Panel\n\n**Data Source**: `IWindowSystem` interface + `/proc` filesystem.\n\n**Implementation**:\n```cpp\n// src/ui/qt/dialog_investigate_qt.cpp\nclass DialogInvestigateQt : public QDialog {\npublic:\n    void updateWindowInfo(WindowHandle hwnd) {\n        auto* windowSys = yamy::platform::createWindowSystem();\n\n        // Basic window properties\n        std::string title = windowSys->getWindowText(hwnd);\n        std::string className = windowSys->getClassName(hwnd);\n        auto rect = windowSys->getWindowRect(hwnd);\n        bool visible = windowSys->isWindowVisible(hwnd);\n\n        // Process information (Linux-specific)\n        std::string processName = getProcessName(hwnd.pid);\n        std::string processPath = getProcessPath(hwnd.pid);\n\n        // Update UI\n        m_handleLabel->setText(QString(\"0x%1\").arg(hwnd.xid, 0, 16));\n        m_titleLabel->setText(QString::fromStdString(title));\n        m_classLabel->setText(QString::fromStdString(className));\n        m_processLabel->setText(QString::fromStdString(processName));\n        m_geometryLabel->setText(QString(\"(%1, %2) %3x%4\")\n            .arg(rect.left).arg(rect.top).arg(rect.width()).arg(rect.height()));\n        m_stateLabel->setText(visible ? \"Visible\" : \"Hidden\");\n\n        // Query engine for keymap status\n        queryKeymapStatus(hwnd);\n\n        delete windowSys;\n    }\n\nprivate:\n    std::string getProcessName(uint32_t pid) {\n        std::ifstream comm(\"/proc/\" + std::to_string(pid) + \"/comm\");\n        std::string name;\n        std::getline(comm, name);\n        return name;\n    }\n\n    std::string getProcessPath(uint32_t pid) {\n        char path[PATH_MAX];\n        std::string exePath = \"/proc/\" + std::to_string(pid) + \"/exe\";\n        ssize_t len = readlink(exePath.c_str(), path, sizeof(path) - 1);\n        if (len != -1) {\n            path[len] = '\\0';\n            return std::string(path);\n        }\n        return \"\";\n    }\n\n    void queryKeymapStatus(WindowHandle hwnd) {\n        // Send IPC request to engine\n        yamy::platform::Message msg;\n        msg.type = yamy::platform::MessageType::CmdInvestigate;\n        msg.lparam = hwnd.xid;\n\n        m_ipc->send(msg);\n\n        // Engine will respond with keymap info\n    }\n};\n```\n\n### 3.4 Engine Investigation Support\n\n**Engine Side**:\n```cpp\n// src/core/engine/engine.cpp\nvoid Engine::handleInvestigateRequest(WindowHandle hwnd) {\n    // Find matching keymap\n    std::string windowText = m_windowSystem->getWindowText(hwnd);\n    std::string className = m_windowSystem->getClassName(hwnd);\n\n    Keymap* matchedKeymap = nullptr;\n    std::string matchedRegex;\n\n    for (auto& keymap : m_keymaps) {\n        if (keymap->matchesWindow(windowText, className)) {\n            matchedKeymap = keymap;\n            matchedRegex = keymap->getWindowRegex();\n            break;\n        }\n    }\n\n    // Build response\n    yamy::platform::Message response;\n    response.type = yamy::platform::MessageType::KeyEvent;  // Reuse\n\n    if (matchedKeymap) {\n        response.data = \"Keymap: \" + matchedKeymap->getName() + \"\\n\";\n        response.data += \"Matched: \" + matchedRegex + \"\\n\";\n        response.data += \"Modifiers: \" + formatModifiers(matchedKeymap->getModifiers());\n    } else {\n        response.data = \"No matching keymap (using default)\";\n    }\n\n    m_ipc->send(response);\n}\n```\n\n### 3.5 Live Log Integration\n\n**Approach**: Engine sends log events to Investigate dialog when open.\n\n```cpp\n// src/core/engine/engine.cpp\nvoid Engine::processKey(const KeyEvent& event) {\n    // Normal processing\n    // ...\n\n    // If investigate mode active, send log\n    if (m_investigateMode) {\n        yamy::platform::Message msg;\n        msg.type = yamy::platform::MessageType::LogMessage;\n        msg.data = formatKeyEvent(event);\n        m_ipc->send(msg);\n    }\n}\n\nstd::string Engine::formatKeyEvent(const KeyEvent& event) {\n    std::ostringstream oss;\n    oss << \"[\" << event.timestamp << \"] \";\n    oss << (event.isPressed ? \"DOWN\" : \"UP\") << \" \";\n    oss << \"Key: \" << event.keyCode << \" \";\n    oss << \"Mods: \" << formatModifiers(event.modifiers) << \" \";\n    oss << \"→ \" << (event.handled ? \"HANDLED\" : \"PASSED\");\n    return oss.str();\n}\n```\n\n---\n\n## Track 4: Log Dialog Enhancement\n\n**Goal**: Feature parity with Windows log viewer (FR-4)\n**Duration**: 20 hours | **Tasks**: 6\n\n### 4.1 Log Levels and Filtering\n\n**Enhanced Log Structure**:\n```cpp\n// src/core/logging/log_entry.h\nnamespace yamy {\n\nenum class LogLevel {\n    Trace = 0,\n    Info = 1,\n    Warning = 2,\n    Error = 3\n};\n\nstruct LogEntry {\n    time_t timestamp;\n    LogLevel level;\n    std::string category;  // \"Engine\", \"Parser\", \"Input\", \"Window\"\n    std::string message;\n\n    std::string format() const {\n        std::ostringstream oss;\n        oss << \"[\" << formatTime(timestamp) << \"] \";\n        oss << levelToString(level) << \" \";\n        oss << \"[\" << category << \"] \";\n        oss << message;\n        return oss.str();\n    }\n};\n\nclass Logger {\npublic:\n    static Logger& instance();\n\n    void log(LogLevel level, const std::string& category, const std::string& msg);\n    void setMinLevel(LogLevel level);\n    void addListener(std::function<void(const LogEntry&)> listener);\n\nprivate:\n    LogLevel m_minLevel = LogLevel::Info;\n    std::vector<std::function<void(const LogEntry&)>> m_listeners;\n    std::mutex m_mutex;\n};\n\n}  // namespace yamy\n```\n\n**GUI Integration**:\n```cpp\n// src/ui/qt/dialog_log_qt.cpp\nclass DialogLogQt : public QDialog {\npublic:\n    DialogLogQt(QWidget* parent = nullptr) : QDialog(parent) {\n        setupUI();\n\n        // Subscribe to logger\n        yamy::Logger::instance().addListener(\n            [this](const yamy::LogEntry& entry) {\n                QMetaObject::invokeMethod(this, \"appendLog\",\n                    Qt::QueuedConnection,\n                    Q_ARG(QString, QString::fromStdString(entry.format())));\n            });\n    }\n\nprivate:\n    void setupUI() {\n        auto* layout = new QVBoxLayout(this);\n\n        // Filter controls\n        auto* filterLayout = new QHBoxLayout();\n        filterLayout->addWidget(new QLabel(\"Detail Level:\"));\n\n        m_levelCombo = new QComboBox(this);\n        m_levelCombo->addItem(\"Trace\", static_cast<int>(LogLevel::Trace));\n        m_levelCombo->addItem(\"Info\", static_cast<int>(LogLevel::Info));\n        m_levelCombo->addItem(\"Warning\", static_cast<int>(LogLevel::Warning));\n        m_levelCombo->addItem(\"Error\", static_cast<int>(LogLevel::Error));\n        m_levelCombo->setCurrentIndex(1);  // Default: Info\n\n        connect(m_levelCombo, QOverload<int>::of(&QComboBox::currentIndexChanged),\n                this, &DialogLogQt::onLevelChanged);\n\n        filterLayout->addWidget(m_levelCombo);\n        filterLayout->addStretch();\n\n        // Category filters\n        m_chkEngine = new QCheckBox(\"Engine\", this);\n        m_chkParser = new QCheckBox(\"Parser\", this);\n        m_chkInput = new QCheckBox(\"Input\", this);\n        m_chkWindow = new QCheckBox(\"Window\", this);\n\n        m_chkEngine->setChecked(true);\n        m_chkParser->setChecked(true);\n        m_chkInput->setChecked(true);\n        m_chkWindow->setChecked(true);\n\n        connect(m_chkEngine, &QCheckBox::toggled, this, &DialogLogQt::onFilterChanged);\n        connect(m_chkParser, &QCheckBox::toggled, this, &DialogLogQt::onFilterChanged);\n        connect(m_chkInput, &QCheckBox::toggled, this, &DialogLogQt::onFilterChanged);\n        connect(m_chkWindow, &QCheckBox::toggled, this, &DialogLogQt::onFilterChanged);\n\n        filterLayout->addWidget(m_chkEngine);\n        filterLayout->addWidget(m_chkParser);\n        filterLayout->addWidget(m_chkInput);\n        filterLayout->addWidget(m_chkWindow);\n\n        layout->addLayout(filterLayout);\n\n        // Log display\n        m_logEdit = new QTextEdit(this);\n        m_logEdit->setReadOnly(true);\n        m_logEdit->setFont(QFontDatabase::systemFont(QFontDatabase::FixedFont));\n        layout->addWidget(m_logEdit);\n\n        // Font selector\n        auto* fontLayout = new QHBoxLayout();\n        fontLayout->addWidget(new QLabel(\"Font:\"));\n\n        m_fontCombo = new QFontComboBox(this);\n        m_fontCombo->setCurrentFont(m_logEdit->font());\n        connect(m_fontCombo, &QFontComboBox::currentFontChanged,\n                this, &DialogLogQt::onFontChanged);\n\n        m_fontSizeSpin = new QSpinBox(this);\n        m_fontSizeSpin->setRange(6, 24);\n        m_fontSizeSpin->setValue(10);\n        connect(m_fontSizeSpin, QOverload<int>::of(&QSpinBox::valueChanged),\n                this, &DialogLogQt::onFontSizeChanged);\n\n        fontLayout->addWidget(m_fontCombo);\n        fontLayout->addWidget(m_fontSizeSpin);\n        fontLayout->addStretch();\n\n        auto* btnClear = new QPushButton(\"Clear\", this);\n        connect(btnClear, &QPushButton::clicked, m_logEdit, &QTextEdit::clear);\n        fontLayout->addWidget(btnClear);\n\n        layout->addLayout(fontLayout);\n\n        resize(800, 600);\n    }\n\n    Q_SLOT void appendLog(const QString& text) {\n        // Apply filters\n        if (!shouldDisplay(text)) return;\n\n        // Syntax highlighting\n        QString formatted = text;\n        if (formatted.contains(\"ERROR\"))\n            formatted = \"<span style='color: red;'>\" + formatted + \"</span>\";\n        else if (formatted.contains(\"WARNING\"))\n            formatted = \"<span style='color: orange;'>\" + formatted + \"</span>\";\n\n        m_logEdit->append(formatted);\n\n        // Auto-scroll to bottom\n        QTextCursor cursor = m_logEdit->textCursor();\n        cursor.movePosition(QTextCursor::End);\n        m_logEdit->setTextCursor(cursor);\n    }\n\n    void onLevelChanged(int index) {\n        LogLevel level = static_cast<LogLevel>(m_levelCombo->currentData().toInt());\n        yamy::Logger::instance().setMinLevel(level);\n    }\n\n    bool shouldDisplay(const QString& text) {\n        if (!m_chkEngine->isChecked() && text.contains(\"[Engine]\")) return false;\n        if (!m_chkParser->isChecked() && text.contains(\"[Parser]\")) return false;\n        if (!m_chkInput->isChecked() && text.contains(\"[Input]\")) return false;\n        if (!m_chkWindow->isChecked() && text.contains(\"[Window]\")) return false;\n        return true;\n    }\n\nprivate:\n    QComboBox* m_levelCombo;\n    QCheckBox* m_chkEngine;\n    QCheckBox* m_chkParser;\n    QCheckBox* m_chkInput;\n    QCheckBox* m_chkWindow;\n    QTextEdit* m_logEdit;\n    QFontComboBox* m_fontCombo;\n    QSpinBox* m_fontSizeSpin;\n};\n```\n\n---\n\n## Track 5: Engine Notification System\n\n**Goal**: Real-time engine status updates to GUI (FR-5)\n**Duration**: 35 hours | **Tasks**: 10\n\n### 5.1 Notification Types\n\n**Message Types**:\n```cpp\n// src/platform/ipc.h (extension)\nenum class MessageType : uint32_t {\n    // ... existing messages\n\n    // Engine lifecycle\n    EngineStarting = 0x1007,\n    EngineStarted = 0x1000,\n    EngineStopping = 0x1008,\n    EngineStopped = 0x1001,\n    EngineError = 0x1002,\n\n    // Configuration\n    ConfigLoading = 0x1009,\n    ConfigLoaded = 0x1003,\n    ConfigError = 0x1004,\n    ConfigValidating = 0x100A,\n\n    // Runtime events\n    KeymapSwitched = 0x100B,\n    FocusChanged = 0x100C,\n    ModifierChanged = 0x100D,\n\n    // Performance\n    LatencyReport = 0x100E,\n    CpuUsageReport = 0x100F,\n};\n```\n\n### 5.2 Engine State Machine\n\n**States**:\n```\n┌─────────┐ start()  ┌─────────┐ validate() ┌─────────┐\n│ Stopped ├─────────→│ Loading ├───────────→│ Running │\n└────┬────┘          └────┬────┘            └────┬────┘\n     ↑                    │                      │\n     │ stop()             │ error()              │ error()\n     │                    ↓                      ↓\n     │               ┌────────┐                  │\n     └───────────────┤ Error  │←─────────────────┘\n                     └────────┘\n```\n\n**Implementation**:\n```cpp\n// src/core/engine/engine_state.h\nnamespace yamy {\n\nenum class EngineState {\n    Stopped,\n    Loading,\n    Running,\n    Error\n};\n\nclass Engine {\npublic:\n    void start() {\n        if (m_state == EngineState::Running) return;\n\n        setState(EngineState::Loading);\n        notifyGUI(MessageType::EngineStarting);\n\n        try {\n            // Load configuration\n            loadConfiguration();\n\n            // Initialize input hooks\n            m_inputHook->install();\n\n            setState(EngineState::Running);\n            notifyGUI(MessageType::EngineStarted);\n\n        } catch (const std::exception& e) {\n            setState(EngineState::Error);\n\n            Message msg;\n            msg.type = MessageType::EngineError;\n            msg.data = e.what();\n            m_ipc->send(msg);\n        }\n    }\n\n    void stop() {\n        if (m_state == EngineState::Stopped) return;\n\n        setState(EngineState::Stopped);\n        notifyGUI(MessageType::EngineStopping);\n\n        m_inputHook->uninstall();\n\n        notifyGUI(MessageType::EngineStopped);\n    }\n\nprivate:\n    void setState(EngineState newState) {\n        m_state = newState;\n        Logger::instance().log(LogLevel::Info, \"Engine\",\n            \"State: \" + stateToString(newState));\n    }\n\n    void notifyGUI(MessageType type) {\n        Message msg;\n        msg.type = type;\n        msg.wparam = static_cast<uint32_t>(m_state);\n        m_ipc->send(msg);\n    }\n\n    EngineState m_state = EngineState::Stopped;\n};\n\n}  // namespace yamy\n```\n\n### 5.3 GUI Status Display\n\n**Tray Icon Updates**:\n```cpp\n// src/ui/qt/tray_icon_qt.cpp\nvoid TrayIconQt::handleEngineMessage(const Message& msg) {\n    switch (msg.type) {\n        case MessageType::EngineStarting:\n            setIcon(QIcon(\":/icons/tray_loading.png\"));\n            setToolTip(\"YAMY - Starting...\");\n            break;\n\n        case MessageType::EngineStarted:\n            setIcon(QIcon(\":/icons/tray_running.png\"));\n            setToolTip(\"YAMY - Running\");\n            m_actionToggle->setText(\"Stop Engine\");\n            break;\n\n        case MessageType::EngineStopped:\n            setIcon(QIcon(\":/icons/tray_stopped.png\"));\n            setToolTip(\"YAMY - Stopped\");\n            m_actionToggle->setText(\"Start Engine\");\n            break;\n\n        case MessageType::EngineError:\n            setIcon(QIcon(\":/icons/tray_error.png\"));\n            setToolTip(\"YAMY - Error: \" + QString::fromStdString(msg.data));\n            showMessage(\"Engine Error\", QString::fromStdString(msg.data),\n                       QSystemTrayIcon::Critical, 5000);\n            break;\n\n        case MessageType::ConfigLoaded: {\n            std::string configName = msg.data;\n            setToolTip(\"YAMY - \" + QString::fromStdString(configName));\n            buildReloadMenu();  // Update checkmarks\n            break;\n        }\n\n        case MessageType::KeymapSwitched:\n            // Update status (if status bar exists)\n            break;\n    }\n}\n```\n\n---\n\n## Track 6: Advanced Features\n\n**Goal**: Session management, IPC API, help menu (FR-6, FR-7, FR-9)\n**Duration**: 45 hours | **Tasks**: 12\n\n### 6.1 Session Management\n\n**Auto-Start Integration**:\n```cpp\n// src/core/settings/session_manager.h\nnamespace yamy {\n\nclass SessionManager {\npublic:\n    bool enableAutoStart();\n    bool disableAutoStart();\n    bool isAutoStartEnabled();\n\n    // Session restoration\n    void saveSession();\n    void restoreSession();\n\nprivate:\n    #ifdef __linux__\n        void createDesktopEntry();\n        void removeDesktopEntry();\n        std::filesystem::path getAutoStartPath();\n    #endif\n};\n\n// Linux implementation\n#ifdef __linux__\nstd::filesystem::path SessionManager::getAutoStartPath() {\n    const char* xdg_config = getenv(\"XDG_CONFIG_HOME\");\n    std::filesystem::path config_dir = xdg_config\n        ? std::filesystem::path(xdg_config)\n        : std::filesystem::path(getenv(\"HOME\")) / \".config\";\n\n    return config_dir / \"autostart\";\n}\n\nvoid SessionManager::createDesktopEntry() {\n    auto autostart_dir = getAutoStartPath();\n    std::filesystem::create_directories(autostart_dir);\n\n    std::ofstream desktop_file(autostart_dir / \"yamy.desktop\");\n    desktop_file << \"[Desktop Entry]\\n\"\n                 << \"Type=Application\\n\"\n                 << \"Name=YAMY\\n\"\n                 << \"Exec=\" << std::filesystem::current_path() / \"yamy\" << \"\\n\"\n                 << \"Icon=yamy\\n\"\n                 << \"Comment=Keyboard remapping utility\\n\"\n                 << \"X-GNOME-Autostart-enabled=true\\n\";\n\n    Logger::instance().log(LogLevel::Info, \"Session\",\n        \"Created autostart entry\");\n}\n\nbool SessionManager::enableAutoStart() {\n    try {\n        createDesktopEntry();\n        return true;\n    } catch (const std::exception& e) {\n        Logger::instance().log(LogLevel::Error, \"Session\",\n            \"Failed to enable autostart: \" + std::string(e.what()));\n        return false;\n    }\n}\n#endif\n\n}  // namespace yamy\n```\n\n### 6.2 External IPC API\n\n**Command-Line Tool**:\n```bash\n# Reload current configuration\n$ yamy-ctl reload\n\n# Switch to specific configuration\n$ yamy-ctl reload --config gaming\n\n# Get engine status\n$ yamy-ctl status\nEngine: Running\nConfig: work.mayu (Work Layout)\nUptime: 2h 15m\nKeys processed: 12,453\n\n# Stop/start engine\n$ yamy-ctl stop\n$ yamy-ctl start\n\n# Query active keymap for current window\n$ yamy-ctl query-keymap\nWindow: \"Visual Studio Code\"\nKeymap: emacs-mode\n```\n\n**Implementation**:\n```cpp\n// src/app/yamy_ctl.cpp\n#include \"platform/ipc.h\"\n\nint main(int argc, char** argv) {\n    if (argc < 2) {\n        std::cerr << \"Usage: yamy-ctl <command> [args]\\n\";\n        return 1;\n    }\n\n    std::string command = argv[1];\n\n    // Connect to running engine\n    auto* ipc = yamy::platform::createIPCChannel();\n    if (!ipc->connect(\"yamy-engine\")) {\n        std::cerr << \"Error: YAMY engine is not running\\n\";\n        return 1;\n    }\n\n    // Send command\n    yamy::platform::Message msg;\n\n    if (command == \"reload\") {\n        msg.type = yamy::platform::MessageType::CmdReload;\n        if (argc >= 4 && std::string(argv[2]) == \"--config\") {\n            msg.data = argv[3];\n        }\n    } else if (command == \"stop\") {\n        msg.type = yamy::platform::MessageType::CmdStop;\n    } else if (command == \"start\") {\n        msg.type = yamy::platform::MessageType::CmdToggleEngine;\n    } else if (command == \"status\") {\n        msg.type = yamy::platform::MessageType::CmdInvestigate;\n    } else {\n        std::cerr << \"Unknown command: \" << command << \"\\n\";\n        return 1;\n    }\n\n    ipc->send(msg);\n\n    // Wait for response\n    yamy::platform::Message response;\n    if (ipc->poll(&response)) {\n        std::cout << response.data << \"\\n\";\n    }\n\n    delete ipc;\n    return 0;\n}\n```\n\n### 6.3 Help Menu\n\n**Help System Design**:\n```\nHelp Menu:\n├─ Online Documentation (opens browser)\n├─ Keyboard Shortcuts Reference (QDialog)\n├─ Configuration Examples (QDialog with code samples)\n├─ Report Bug (opens GitHub issues)\n├─ ──────────\n└─ About (version, license, contributors)\n```\n\n**Implementation**:\n```cpp\n// src/ui/qt/dialog_help_qt.cpp\nclass DialogHelpQt : public QDialog {\npublic:\n    DialogHelpQt(QWidget* parent = nullptr) : QDialog(parent) {\n        setupUI();\n        loadShortcuts();\n    }\n\nprivate:\n    void setupUI() {\n        auto* layout = new QVBoxLayout(this);\n\n        auto* tabs = new QTabWidget(this);\n\n        // Shortcuts tab\n        auto* shortcutsTab = new QWidget();\n        auto* shortcutsLayout = new QVBoxLayout(shortcutsTab);\n\n        m_shortcutTable = new QTableWidget(this);\n        m_shortcutTable->setColumnCount(2);\n        m_shortcutTable->setHorizontalHeaderLabels({\"Action\", \"Shortcut\"});\n        m_shortcutTable->horizontalHeader()->setStretchLastSection(true);\n\n        shortcutsLayout->addWidget(m_shortcutTable);\n        tabs->addTab(shortcutsTab, \"Keyboard Shortcuts\");\n\n        // Examples tab\n        auto* examplesTab = new QWidget();\n        auto* examplesLayout = new QVBoxLayout(examplesTab);\n\n        auto* exampleList = new QListWidget(this);\n        exampleList->addItem(\"Basic Remapping\");\n        exampleList->addItem(\"Emacs Bindings\");\n        exampleList->addItem(\"Vim Modal Editing\");\n        exampleList->addItem(\"Window Management\");\n\n        auto* exampleCode = new QTextEdit(this);\n        exampleCode->setReadOnly(true);\n        exampleCode->setFont(QFontDatabase::systemFont(QFontDatabase::FixedFont));\n\n        connect(exampleList, &QListWidget::currentRowChanged,\n                [this, exampleCode](int row) {\n                    exampleCode->setPlainText(getExample(row));\n                });\n\n        examplesLayout->addWidget(exampleList, 1);\n        examplesLayout->addWidget(exampleCode, 3);\n        tabs->addTab(examplesTab, \"Examples\");\n\n        layout->addWidget(tabs);\n\n        auto* buttonBox = new QDialogButtonBox(QDialogButtonBox::Close, this);\n        connect(buttonBox, &QDialogButtonBox::rejected, this, &QDialog::accept);\n        layout->addWidget(buttonBox);\n\n        resize(700, 500);\n    }\n\n    void loadShortcuts() {\n        QStringList shortcuts = {\n            \"Open Settings|Ctrl+Shift+S\",\n            \"Reload Configuration|Ctrl+Shift+R\",\n            \"Open Log|Ctrl+Shift+L\",\n            \"Investigate Window|Ctrl+Shift+I\",\n            \"Toggle Engine|Ctrl+Shift+E\",\n            \"Show Help|F1\"\n        };\n\n        m_shortcutTable->setRowCount(shortcuts.size());\n\n        for (int i = 0; i < shortcuts.size(); ++i) {\n            QStringList parts = shortcuts[i].split('|');\n            m_shortcutTable->setItem(i, 0, new QTableWidgetItem(parts[0]));\n            m_shortcutTable->setItem(i, 1, new QTableWidgetItem(parts[1]));\n        }\n    }\n\n    QString getExample(int index) {\n        switch (index) {\n            case 0:  // Basic Remapping\n                return R\"(# Basic key remapping\nkeymap Global\n    # Swap Caps Lock and Control\n    key CapsLock = Control\n    key Control = CapsLock\n\n    # Arrow keys on right hand\n    mod Control += {\n        key H = Left\n        key J = Down\n        key K = Up\n        key L = Right\n    }\n)\";\n            case 1:  // Emacs Bindings\n                return R\"(# Emacs-style bindings\nkeymap Global\n    mod Control += {\n        key P = Up\n        key N = Down\n        key B = Left\n        key F = Right\n        key A = Home\n        key E = End\n        key K = S-End Delete\n        key W = C-X\n    }\n)\";\n            // ... more examples\n        }\n        return \"\";\n    }\n\n    QTableWidget* m_shortcutTable;\n};\n```\n\n---\n\n## Integration Testing Strategy\n\n### Test Plan\n\n**Unit Tests** (Per-track):\n- Track 1: 60 unit tests (one per file refactored)\n- Track 2: 15 tests (ConfigurationManager CRUD)\n- Track 3: 18 tests (Window inspection, crosshair)\n- Track 4: 6 tests (Log filtering, formatting)\n- Track 5: 10 tests (Notification delivery)\n- Track 6: 12 tests (Session mgmt, IPC)\n\n**Integration Tests**:\n1. **End-to-End Configuration Flow**\n   - Add config in GUI → Engine reloads → Verify keymaps active\n2. **Cross-Platform .mayu Compatibility**\n   - Load same .mayu on Windows and Linux → Verify identical behavior\n3. **IPC Stress Test**\n   - Send 1000 messages/sec → Verify no dropped messages\n4. **Performance Benchmarks**\n   - Key latency < 1ms (99th percentile)\n   - CPU usage < 1% idle\n   - Memory < 10MB RSS\n\n**Test Automation**:\n```bash\n# CMakeLists.txt\nenable_testing()\nadd_subdirectory(tests)\n\n# Run all tests\nctest --output-on-failure\n\n# Run with coverage\ncmake -DCOVERAGE=ON ..\nmake test\nlcov --capture --directory . --output-file coverage.info\ngenhtml coverage.info --output-directory coverage_report\n```\n\n---\n\n## Rollout Strategy\n\n### Phase 1: Alpha (Internal Testing)\n- Deploy Track 1-3 to core maintainers\n- Validate basic functionality\n- Fix P0 bugs\n\n### Phase 2: Beta (Community Testing)\n- Deploy Track 1-6 to 20 beta testers\n- Collect feedback via GitHub discussions\n- Performance tuning\n\n### Phase 3: Release Candidate\n- All features complete\n- Zero P0 bugs\n- Documentation finalized\n- Pass integration test suite\n\n### Phase 4: v1.0 Launch\n- AUR, PPA, Copr packages\n- GitHub release with binaries\n- Announcement on HN, Reddit\n- Tutorial video series\n\n---\n\n## Risk Mitigation\n\n### Technical Risks\n\n**Risk**: X11 window APIs behave differently than Win32\n**Mitigation**: Extensive integration testing, fallback strategies\n\n**Risk**: Performance degradation on older hardware\n**Mitigation**: Profiling on Raspberry Pi, optimization passes\n\n**Risk**: Wayland incomplete support\n**Mitigation**: Clear documentation of X11 requirement, Wayland planned for v1.1\n\n### Schedule Risks\n\n**Risk**: 60 parallel tasks may have hidden dependencies\n**Mitigation**: 3-batch structure, strict acceptance criteria per task\n\n**Risk**: Qt GUI complexity underestimated\n**Mitigation**: Track 3 (Investigate) has buffer time (60h allocated)\n\n---\n\n## Success Criteria\n\n**Track 1**: ✅ Engine compiles on Linux without Windows headers\n**Track 2**: ✅ Can manage 3+ configurations via GUI\n**Track 3**: ✅ Investigate dialog shows all window info + keymap status\n**Track 4**: ✅ Log filtering works, 4 detail levels\n**Track 5**: ✅ Tray icon updates in <100ms after engine state change\n**Track 6**: ✅ `yamy-ctl` controls running engine, autostart works\n\n**Overall**: ✅ Pass 100% of Windows integration tests on Linux\n\n---\n\n**Document Version**: 1.0\n**Last Updated**: 2025-12-10\n**Implements**: requirements.md (all FR-1 through FR-9, NFR-1 through NFR-6)\n**Ready for**: Approval → Task Breakdown → Implementation\n",
  "fileStats": {
    "size": 61438,
    "lines": 1996,
    "lastModified": "2025-12-10T15:08:09.558Z"
  },
  "comments": []
}