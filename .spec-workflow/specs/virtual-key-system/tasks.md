# Tasks: Virtual Key System

- [x] 1.1. Define Virtual Key Ranges
  - File: src/platform/linux/keycode_mapping.h
  - Add keycode range definitions for virtual keys (V_*), modifiers (M00-MFF), and locks (L00-LFF)
  - Define YAMY_VIRTUAL_KEY_BASE (0xE000), YAMY_MOD_00 (0xF000), YAMY_LOCK_00 (0xF100)
  - Add helper functions: isVirtualKey(), isModifier(), isLock(), getModifierNumber(), getLockNumber()
  - Purpose: Establish keycode ranges for virtual key system
  - _Leverage: src/platform/linux/keycode_mapping.h_
  - _Requirements: US9_
  - _Prompt: Role: C++ systems developer working on keyboard input processing | Task: Add keycode range definitions for virtual key system - Virtual regular keys (V_*) 0xE000-0xEFFF, Modal modifiers (M00-MFF) 0xF000-0xF0FF, Lock keys (L00-LFF) 0xF100-0xF1FF, plus helper functions isVirtualKey(), isModifier(), isLock(), getModifierNumber(), getLockNumber() | Restrictions: Do NOT modify existing keycode ranges, do NOT change existing function signatures, use inline functions for helpers | Success: All ranges defined with #define, helper functions compile without errors, no overlap with existing keycode ranges, clear comments explain purpose of each range | After completing: Mark task 1.1 as [-] in tasks.md, implement the code, call log-implementation tool with taskId "1.1" and detailed artifacts, mark task 1.1 as [x]_

- [x] 1.2. Implement ModifierState Class Updates
  - File: src/core/input/modifier_state.h
  - File: src/core/input/modifier_state.cpp
  - Update ModifierState to support 256 modifiers (M00-MFF) using bitmask array
  - Change m_modal from single uint32_t to array uint32_t m_modal[8]
  - Update activate(), deactivate(), isActive() methods with array indexing
  - Add getter: const uint32_t* getModifierBits() const
  - Purpose: Expand modifier state storage from 20 to 256 modifiers
  - _Leverage: src/core/input/modifier_state.h, existing bit manipulation patterns_
  - _Requirements: US5, US9_
  - _Prompt: Role: C++ developer specializing in state management | Task: Update ModifierState class to support 256 modal modifiers using efficient bitmask storage - change m_modal to uint32_t[8] array, update activate/deactivate/isActive methods with array indexing (word_idx = mod_num/32, bit_idx = mod_num%32), add getModifierBits() getter | Restrictions: Do NOT change existing method signatures for hardware modifiers, do NOT break backward compatibility with Shift/Ctrl/Alt/Win modifiers, keep O(1) complexity, no dynamic allocation | Success: All 256 modifiers can be activated/deactivated, isActive() returns correct state for all M00-MFF, no performance degradation, existing hardware modifier code still works | After completing: Mark as [-], implement, log with detailed artifacts, mark as [x]_

- [x] 1.3. Implement LockState Class
  - File: src/core/input/lock_state.h (new)
  - File: src/core/input/lock_state.cpp (new)
  - Create new LockState class to manage 256 lock keys with toggle functionality
  - Implement toggleLock(), isLockActive(), getLockBits(), notifyGUI() methods
  - Use uint32_t m_locks[8] for 256 bits storage
  - Send IPC message on lock state change
  - Purpose: Manage persistent toggle state for L00-LFF lock keys
  - _Leverage: ModifierState implementation as reference, existing IPC notification patterns_
  - _Requirements: US6, US7, US8, US9_
  - _Prompt: Role: C++ developer creating new state management class | Task: Create LockState class for managing 256 toggle-able lock keys with GUI notifications - implement toggleLock() using XOR to toggle bits, isLockActive() to check bit state, getLockBits() to get full bitmask, notifyGUI() to send IPC message with lock state | Restrictions: Do NOT add dependencies on GUI libraries, keep IPC notification generic, no dynamic allocation, thread-safe not required | Success: LockState can toggle all 256 locks, isLockActive() returns correct state, notifyGUI() sends IPC message, no memory leaks | After completing: Mark as [-], implement, log with class/method artifacts, mark as [x]_

- [x] 2.1. Add Token Recognition for V_, M, L Prefixes
  - File: src/core/settings/setting_loader.h
  - File: src/core/settings/setting_loader.cpp
  - Update parser to recognize V_KeyName, M00-MFF, and L00-LFF tokens
  - Parse V_* tokens: extract key name, return YAMY_VIRTUAL_KEY_BASE + base_code
  - Parse M[0-9A-F]{2} tokens: convert hex to number, return YAMY_MOD_00 + number
  - Parse L[0-9A-F]{2} tokens: convert hex to number, return YAMY_LOCK_00 + number
  - Purpose: Enable parser to understand new virtual key syntax
  - _Leverage: Existing key name lookup functions, existing token parsing patterns_
  - _Requirements: US1, US2, US3_
  - _Prompt: Role: Parser developer working on .mayu configuration file parsing | Task: Add token recognition for new virtual key syntax - if token starts with "V_" extract key name and return YAMY_VIRTUAL_KEY_BASE + base_code, if matches "M[0-9A-F]{2}" extract hex and return YAMY_MOD_00 + number, if matches "L[0-9A-F]{2}" extract hex and return YAMY_LOCK_00 + number | Restrictions: Do NOT break existing key name parsing, validate hex digits are valid (0-9, A-F, case insensitive), return error for invalid formats, do NOT modify grammar rules yet | Success: Parser recognizes V_A/V_Enter/etc, M00-MFF all 256, L00-LFF all 256, invalid tokens return error with clear message, existing key parsing still works | After completing: Mark as [-], implement, log with function artifacts, mark as [x]_

- [x] 2.2. Add "mod assign" Grammar Rule
  - File: src/core/settings/setting_loader.cpp
  - Add parser support for "mod assign M00 = *Enter" syntax to define tap actions
  - Parse pattern: "mod" "assign" MODIFIER "=" "*" KEY
  - Store in map: m_modTapActions[mod_num] = key_code
  - Pass to Engine during configuration loading
  - Purpose: Enable modifier tap action definitions
  - _Leverage: Existing grammar parsing patterns, existing key parsing after '*' operator_
  - _Requirements: US4_
  - _Prompt: Role: Parser developer adding new grammar rules | Task: Add "mod assign" statement parsing for modifier tap actions - parse pattern "mod assign M00 = *Enter", extract modifier number (00-FF from M00-MFF) and tap output key code, store in map m_modTapActions[mod_num] = key_code, handle errors for invalid modifiers or keys | Restrictions: Do NOT change existing "mod" syntax for hardware modifiers, do NOT require mod assign for modifiers to work (it's optional), do NOT parse old "mod mod0 = !!Key" syntax | Success: "mod assign M00 = *Enter" parses successfully, m_modTapActions map populated correctly, parser error for invalid syntax, duplicate assignments handled gracefully | After completing: Mark as [-], implement, log artifacts, mark as [x]_

- [x] 3.1. Update Substitution Layer to Handle Virtual Keys
  - File: src/core/engine/engine_event_processor.cpp
  - Update Layer 2a substitution to properly handle V_, M, L virtual keys in substitution table
  - Verify substitution table lookup happens BEFORE modifier/lock processing
  - Ensure virtual keys are not output to evdev layer
  - Update documentation/comments to clarify virtual key support
  - Purpose: Enable substitution to virtual keys without code changes
  - _Leverage: Existing substitution table in engine_event_processor.cpp_
  - _Requirements: US1, US3_
  - _Prompt: Role: Systems developer working on event processing pipeline | Task: Update substitution layer to handle virtual keys - verify existing substitution table already supports any uint16_t → uint16_t mapping (no code changes needed), ensure lookup happens BEFORE modifier/lock processing, verify virtual keys are not output to evdev, update comments to clarify virtual key support with examples | Restrictions: Do NOT change substitution table data structure, do NOT add special cases for virtual keys, keep existing performance (O(1) hash lookup) | Success: Substitution table can store virtual key mappings, lookup returns virtual key codes correctly, comments explain virtual key support, no performance regression | After completing: Mark as [-], implement, log, mark as [x]_

- [x] 3.2. Implement Modifier Processing with Tap/Hold Detection
  - File: src/core/engine/modifier_key_handler.h
  - File: src/core/engine/modifier_key_handler.cpp
  - Replace broken modal modifier logic with new M00-MFF processing
  - Add tap/hold state tracking with ModState struct (press_time, is_pressed, tap_output)
  - Implement PRESS: record timestamp, return WAITING_FOR_THRESHOLD
  - Implement RELEASE: check duration, if <200ms output tap action, if ≥200ms deactivate modifier
  - Load tap actions from parser m_modTapActions
  - Purpose: Implement working modifier tap/hold behavior
  - _Leverage: Existing event processing patterns, std::chrono for timing_
  - _Requirements: US4, US5_
  - _Prompt: Role: Developer implementing tap/hold key detection logic | Task: Implement modifier processing with tap/hold detection for M00-MFF - add struct ModState with press_time/is_pressed/tap_output, create map<uint8_t, ModState> m_modStates with TAP_THRESHOLD_MS=200, on PRESS record timestamp and return WAITING, on RELEASE check duration and either output tap action (<threshold) or deactivate modifier (≥threshold), load tap actions from SettingLoader | Restrictions: Do NOT block event processing thread, do NOT use sleep() or blocking waits, keep state machine simple (IDLE → PRESSED → TAP/HOLD), do NOT remove existing hardware modifier code | Success: Quick tap (<200ms) outputs tap action, hold (≥200ms) activates modifier without output, multiple modifiers can be active simultaneously, no blocking or thread safety issues | After completing: Mark as [-], implement, log with detailed artifacts, mark as [x]_

- [x] 3.3. Implement Lock Processing
  - File: src/core/engine/engine_event_processor.cpp
  - Add lock key processing that toggles lock state on press
  - Add detection: if (isLock(yamy_code)) return processLock()
  - Implement processLock(): if PRESS toggle lock state and return 0 (suppress), if RELEASE return 0
  - Call lockState->toggleLock(lock_num) which calls notifyGUI() automatically
  - Purpose: Enable lock key toggle functionality
  - _Leverage: LockState class from task 1.3, isLock() helper from task 1.1_
  - _Requirements: US6_
  - _Prompt: Role: Developer implementing lock key toggle logic | Task: Add lock key processing to EventProcessor - add lock detection if (isLock(yamy_code)) in processEvent(), implement processLock() to toggle lock on PRESS and suppress output (return 0) on both PRESS and RELEASE, lock state changes call lockState->toggleLock(lock_num) which triggers notifyGUI() automatically | Restrictions: Do NOT output lock keys to evdev layer, do NOT toggle on both PRESS and RELEASE (only PRESS), keep logic simple (no timing required) | Success: Press L00 toggles lock on/off, lock state persists across events, lock keys never output to system, GUI notification sent on toggle | After completing: Mark as [-], implement, log, mark as [x]_

- [ ] 3.4. Implement Keymap Matching with Specificity
  - File: src/core/engine/engine_event_processor.cpp
  - File: src/core/engine/engine.h
  - Implement keymap lookup with modifier/lock matching and specificity-based priority
  - Extend KeymapEntry structure with required_mods[8], required_locks[8], input_key, output_key, specificity
  - Sort keymap by specificity (DESC) after loading
  - Implement lookupKeymap(): iterate keymap (most specific first), check input_key matches, check all required modifiers are active using bitmask matching
  - Purpose: Enable complex modifier/lock combinations with correct priority
  - _Leverage: ModifierState::getModifierBits(), LockState::getLockBits()_
  - _Requirements: US5, US7_
  - _Prompt: Role: Developer implementing keymap matching logic | Task: Implement keymap lookup with modifier/lock combination matching and specificity rules - extend KeymapEntry with uint32_t required_mods[8]/required_locks[8]/specificity fields, sort by specificity DESC, implement lookupKeymap() to iterate most specific first and check (active_mods[i] & required_mods[i]) == required_mods[i] for all words, same for locks, return first match | Restrictions: Do NOT use complex data structures (keep vector), do NOT break existing keymap parsing, keep O(n) complexity (acceptable for <1000 entries) | Success: M00-M01-A matches when both M00 and M01 are active, more specific matches take priority, L00-L01-A matches when both locks are active, mixed M00-L00-A works correctly | After completing: Mark as [-], implement, log with detailed artifacts, mark as [x]_

- [ ] 3.5. Update Layer 3 to Suppress Virtual Keys
  - File: src/core/engine/engine_event_processor.cpp
  - Update YAMY→evdev conversion to suppress virtual keys (don't output them)
  - Add check: if (isVirtualKey(yamy) || isModifier(yamy) || isLock(yamy)) return 0
  - Ensure 0 return value is handled correctly by calling code
  - Purpose: Prevent virtual keys from being output to system
  - _Leverage: Helper functions isVirtualKey(), isModifier(), isLock(), existing layer3_yamyToEvdev()_
  - _Requirements: US1_
  - _Prompt: Role: Developer updating output layer logic | Task: Suppress virtual keys in YAMY→evdev conversion layer - update layer3_yamyToEvdev() to check if (isVirtualKey(yamy) || isModifier(yamy) || isLock(yamy)) return 0 before calling yamyToEvdevKeyCode(), verify calling code handles 0 correctly and skips output | Restrictions: Do NOT change existing yamyToEvdevKeyCode() function, do NOT suppress physical keys, keep existing error handling | Success: V_A/V_B/etc return 0 (not output), M00-MFF return 0 (not output), L00-LFF return 0 (not output), physical keys still output correctly | After completing: Mark as [-], implement, log, mark as [x]_

- [ ] 4.1. Add Lock Status IPC Message
  - File: src/core/ipc/ipc_messages.h
  - File: src/core/engine/engine.h
  - Define IPC message structure for lock status updates
  - Add to MessageType enum: LockStatusUpdate = 0x0200
  - Define struct LockStatusMessage with uint32_t lockBits[8]
  - Implement notifyGUI() in LockState to create message and send via Engine::notifyGUI()
  - Purpose: Enable lock state communication to GUI
  - _Leverage: Existing MessageType enum, existing notifyGUI() patterns in Engine_
  - _Requirements: US8_
  - _Prompt: Role: Developer adding IPC message types | Task: Add LockStatusUpdate message for GUI communication - add MessageType::LockStatusUpdate = 0x0200 to enum, define struct LockStatusMessage { uint32_t lockBits[8]; }, implement notifyGUI() in LockState to create LockStatusMessage, copy m_locks to lockBits, send via Engine::notifyGUI() | Restrictions: Do NOT break existing IPC messages, keep message size small (<64 bytes), use existing IPC send mechanism | Success: LockStatusMessage defined, notifyGUI() sends message via IPC, message size is minimal, no IPC compatibility issues | After completing: Mark as [-], implement, log, mark as [x]_

- [ ] 4.2. Implement Lock Indicator Widget (Qt)
  - File: src/ui/qt/lock_indicator_widget.h (new)
  - File: src/ui/qt/lock_indicator_widget.cpp (new)
  - Create Qt widget to display lock status with visual indicators
  - Define LockIndicatorWidget class with updateLockStatus(const uint32_t lockBits[8])
  - Create indicators on demand (not all 256 upfront), show only active or recently used locks
  - Update colors: green = active, gray = inactive
  - UI layout: vertical list with "Lxx [●]" format where ● is colored dot
  - Purpose: Provide visual feedback for lock state
  - _Leverage: Existing Qt widget patterns in src/ui/qt/, existing IPC receive handling_
  - _Requirements: US8_
  - _Prompt: Role: Qt GUI developer creating status indicators | Task: Create LockIndicatorWidget to show which locks are active - create class with updateLockStatus(lockBits[8]) method, create indicators on demand (not all 256 upfront), implement setLockActive(lock_num, active) to update colors (green=active, gray=inactive), layout as vertical list "Lxx [●]" where ● is colored QLabel with stylesheet | Restrictions: Do NOT create all 256 indicators at startup, do NOT block UI thread with updates, keep visual design simple and clear | Success: Widget displays lock indicators, colors update when locks toggle, UI is responsive and clean, memory usage is reasonable | After completing: Mark as [-], implement, log with component artifacts, mark as [x]_

- [ ] 5.1. Create E2E Test Scenarios
  - File: tests/scenarios/virtual-keys-basic.json (new)
  - File: tests/scenarios/modifiers-tap-hold.json (new)
  - File: tests/scenarios/locks-combinatorial.json (new)
  - Create E2E test scenarios for virtual key system using existing test infrastructure
  - virtual-keys-basic: Test V_ virtual keys, verify physical vs virtual distinction
  - modifiers-tap-hold: Test M00 tap/hold, verify tap outputs Enter, verify hold activates modifier
  - locks-combinatorial: Test L00/L01 toggle, verify single lock and combo lock behavior
  - Purpose: Validate virtual key system functionality end-to-end
  - _Leverage: Existing test scenarios in tests/scenarios/, existing test runner framework, E2E testing infrastructure_
  - _Requirements: All user stories_
  - _Prompt: Role: QA engineer writing E2E tests | Task: Create test scenarios for virtual key system - create virtual-keys-basic.json (test V_ keys with config def subst *A = *V_B, key M00-B = *C, key M00-V_B = *D), modifiers-tap-hold.json (test M00 tap/hold with config def subst *B = *M00, mod assign M00 = *Enter), locks-combinatorial.json (test L00/L01 toggle with single lock key L00-A = *B and combo key L00-L01-A = *C) - each includes config file, input sequence, expected output, success criteria | Restrictions: Use existing test framework format, do NOT create new test infrastructure, keep tests atomic and focused | Success: All test scenarios pass, tests cover major features, test output is clear and actionable, tests can run automatically | After completing: Mark as [-], create test files, log, mark as [x]_

- [ ] 5.2. Update Documentation and Migration Guide
  - File: docs/VIRTUAL_KEYS.md (new)
  - File: docs/MIGRATION.md (new)
  - Create user documentation and migration guide for virtual key system
  - VIRTUAL_KEYS.md: Overview of V_/M00-MFF/L00-LFF, syntax examples, common patterns (Space Cadet, Vim mode), troubleshooting
  - MIGRATION.md: Old syntax → New syntax table, migration steps, example conversions, breaking changes
  - Include clear examples, visual diagrams (ASCII art), common pitfalls, FAQ section
  - Purpose: Enable users to adopt and migrate to new virtual key system
  - _Leverage: Design document for technical details, Requirements for user stories, existing documentation style_
  - _Requirements: All user stories_
  - _Prompt: Role: Technical writer creating user documentation | Task: Write comprehensive documentation for virtual key system - create VIRTUAL_KEYS.md with overview, syntax examples for V_/M/L, common patterns (Space Cadet: def subst *B = *M00, mod assign M00 = *Enter, key M00-H = *Left), troubleshooting tips - create MIGRATION.md with old→new syntax table (old: mod mod0 = !!B → new: def subst *B = *M00), migration steps, example conversions, breaking changes list - include clear copy-paste examples, visual diagrams, pitfalls, FAQ | Restrictions: Do NOT create video tutorials, keep language simple and clear, include copy-paste examples, no technical jargon without explanation | Success: Documentation is clear and complete, migration guide covers all breaking changes, examples are copy-paste ready, no unexplained jargon | After completing: Mark as [-], write documentation, log, mark as [x]_
